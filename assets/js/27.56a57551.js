(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{311:function(a,t){a.exports="data:image/png;base64,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"},312:function(a,t){a.exports="data:image/png;base64,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"},381:function(a,t,s){"use strict";s.r(t);var e=s(14),n=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"java并发基石-jmm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java并发基石-jmm"}},[a._v("#")]),a._v(" Java并发基石——JMM")]),a._v(" "),t("p",[a._v("JMM，Java Memory Model，中文叫 Java内存模型（请注意区分Java内存结构），JMM描述的是一组规范。")]),a._v(" "),t("p",[a._v("JMM解决了上篇文章提到的三个并发编程的问题，我们依次来看具体是如何解决的。")]),a._v(" "),t("h2",{attrs:{id:"_1、解决可见性-内存的抽象划分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、解决可见性-内存的抽象划分"}},[a._v("#")]),a._v(" 1、解决可见性：内存的抽象划分")]),a._v(" "),t("p",[a._v("为了解决可见性，JMM提出了两个抽象(并非物理上)的概念：「线程本地内存」和「主存」。每个线程创建时，JVM都会为其分配「线程本地内存」，而用「主存」代表线程共享的所有资源。")]),a._v(" "),t("p",[a._v("JMM规定："),t("strong",[a._v("线程对共享变量的所有操作都必须在自己的「线程本地内存」中进行，不能直接从「主存」中读取。「线程本地内存」是线程私有的，别的线程无法访问。")])]),a._v(" "),t("p",[t("strong",[a._v("注意：这不代表「线程本地内存」内的变量别的线程无法拥有。两个「线程本地内存」可以获得来自「主存」的一模一样的变量的副本")]),a._v("。见下图：")]),a._v(" "),t("img",{staticStyle:{zoom:"80%"},attrs:{src:s(311)}}),a._v(" "),t("p",[a._v("JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证。")]),a._v(" "),t("blockquote",[t("p",[a._v("光看图你可能会觉得很简单，但请记住「线程本地内存」的概念是抽象的。并且：")]),a._v(" "),t("ul",[t("li",[a._v("「线程本地内存」物理上是什么？")]),a._v(" "),t("li",[a._v("JMM具体如何控制「线程本地内存」和「主存」的交互？")])]),a._v(" "),t("p",[a._v("非常多的问题等着我们去解答。")])]),a._v(" "),t("h3",{attrs:{id:"线程本地内存的本质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程本地内存的本质"}},[a._v("#")]),a._v(" 线程本地内存的本质")]),a._v(" "),t("p",[a._v("「线程本地内存」是JMM提出的一个"),t("strong",[a._v("抽象的概念，并不真实存在")]),a._v("。")]),a._v(" "),t("p",[a._v("在物理层面上，「线程本地内存」涵盖了**缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。**因为硬件这么多，实现各不相同，依赖于硬件是不可靠的，因此需要这一个抽象的概念来表示："),t("strong",[a._v("所有由于某种原因导致线程操作的数据不会立即写回到内存，或是通知其它CPU核心，从而造成一致性问题的潜在因素的集合")]),a._v("。")]),a._v(" "),t("blockquote",[t("p",[a._v("你可能会说，解决CPU缓存一致性有MESI协议呀，但实际上，上层语言不能完全依赖于硬件提供的某些功能，假如某CPU不支持该协议呢？ 像解决CPU缓存一致性的协议还有：MSI、MOSI、和 Dragon Protocol等等。那Java并发编程在这个硬件上就毫无意义。因此需要JMM来定义这样的规范，从而"),t("strong",[a._v("屏蔽硬件的不可靠性")]),a._v("。")])]),a._v(" "),t("h3",{attrs:{id:"java内存模型与内存结构的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java内存模型与内存结构的关系"}},[a._v("#")]),a._v(" Java内存模型与内存结构的关系")]),a._v(" "),t("p",[a._v("如果你学过 JVM，知道「Java内存结构」，是否会将「线程本地内存、主存」的概念和「Java内存结构」的概念拿来比较从而导致有疑问？在此做一个简单的解释。")]),a._v(" "),t("p",[a._v("「线程本地内存」是抽象的概念，Java内存结构中线程私有的「栈，程序计数器，本地方法栈」是物理的概念。「栈，程序计数器，本地方法栈」可以被划分到「线程本地内存」，甚至可以不属于「线程本地内存」，尽管只有该线程有访问它们的权限，更不能完全代表「线程本地内存」。")]),a._v(" "),t("h3",{attrs:{id:"本地内存-与-堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本地内存-与-堆"}},[a._v("#")]),a._v(" 本地内存 与 堆")]),a._v(" "),t("p",[a._v("你可能会问："),t("strong",[a._v("Java线程持有堆对象的引用，那会直接操作堆吗")]),a._v("？")]),a._v(" "),t("p",[a._v("堆是 Java 内存结构的一部分，属于共享区域，如果线程直接操作堆，就与JMM冲突了。")]),a._v(" "),t("p",[a._v("虽然Java采用直接指针的方式访问对象，但实际上"),t("strong",[a._v("并不会直接操作堆对象")]),a._v("，毕竟堆也属于内存，也就是JMM的主存区域，Java线程的做法是："),t("strong",[a._v("将堆对象拷贝到线程自己的本地内存来进行操作")]),a._v("（如果对象很大只会拷贝一部分）。本地内存确实是线程私有的，但请不要和「JVM运行时数据结构的那些线程私有的栈等」划上等号，本地内存是抽象的。")]),a._v(" "),t("h3",{attrs:{id:"线程本地内存-和-主存-具体如何交互"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程本地内存-和-主存-具体如何交互"}},[a._v("#")]),a._v(" 线程本地内存 和 主存 具体如何交互")]),a._v(" "),t("p",[a._v("如果你读懂了JMM的内存抽象划分，再加上 Java的并发编程工作模型是「共享内存并发模型」，那你会发现："),t("strong",[a._v("线程之间的通信只能通过「主存」来实现")]),a._v("。既然如此，让你来设计一个线程通信的工作模型，你会怎么做呢？")]),a._v(" "),t("p",[a._v("比如：线程A希望与线程B通信，它们的本地内存都持有变量 i 的副本，在线程A修改了i后，A必须立刻将变量 i 的值写回到主内存中，并且当线程B要操作变量 i 之前，必须重新从主存中读取变量 i 的值。")]),a._v(" "),t("p",[a._v("是不是和你想的一样呢？实际上，Java也确实有一个关键字，volatile，实现了上述功能。实际上，Java关键字的语义往往是复合的，不是只能解决可见性。但本章节主要分析JMM的思想与理论基础，因此留到后文再详细介绍。")]),a._v(" "),t("h3",{attrs:{id:"线程本地内存小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程本地内存小结"}},[a._v("#")]),a._v(" 线程本地内存小结")]),a._v(" "),t("p",[a._v("一个线程无论操作什么数据，包括修改堆对象的某个字段，都是在自己的本地内存上操作的，且不能直接操作主存。并且线程的本地内存是线程私有的，其它线程访问不到。本地内存是抽象的概念。")]),a._v(" "),t("p",[a._v("这样规范的原因是：硬件提供缓存一致不可靠，那我们只能认为线程对数据的所有操作都是脏的（线程私有的栈等除外，因为这些内容根本不会写入主存），因为从本地内存写回到主存的时机我们不知道。")]),a._v(" "),t("h2",{attrs:{id:"_2、解决有序性-禁止重排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、解决有序性-禁止重排序"}},[a._v("#")]),a._v(" 2、解决有序性：禁止重排序")]),a._v(" "),t("h3",{attrs:{id:"什么是重排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是重排序"}},[a._v("#")]),a._v(" 什么是重排序")]),a._v(" "),t("p",[a._v("上篇文章已经详细介绍过，这里简单提一下。")]),a._v(" "),t("p",[a._v("重排序的概念是：计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。")]),a._v(" "),t("p",[a._v("从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：")]),a._v(" "),t("p",[t("img",{attrs:{src:s(312),alt:""}})]),a._v(" "),t("h3",{attrs:{id:"jmm重排序的策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jmm重排序的策略"}},[a._v("#")]),a._v(" JMM重排序的策略")]),a._v(" "),t("p",[a._v("JMM确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的"),t("strong",[a._v("内存可见性")]),a._v("保证。")]),a._v(" "),t("p",[a._v("读完这句话，会有疑惑吗？为什么明明禁止重排序是解决有序性的，怎么这个作者写了可见性？")]),a._v(" "),t("p",[a._v("实际上，"),t("strong",[a._v("JMM对重排序的策略是：在不改变程序执行结果的前提下，你爱怎么重排序就怎么重排序。即：JMM不保证程序执行的绝对有序性。")])]),a._v(" "),t("p",[a._v("因此，JMM只处理那些「会导致程序执行结果改变的有序性问题」，其他的不管。那保证了部分有序有什么用？那当然是为了可见性咯。很多场景下，代码之间存在依赖关系。这就像类加载器，如果没有bootstrap，那ext也很难发挥作用，因为ext类加载器的加载依赖于bootstrap。因此，存在依赖关系的代码段，不保证有序性根本就没办法保证可见性，为了解决可见性所做的一切努力都是白费。")]),a._v(" "),t("blockquote",[t("p",[a._v("那么JMM如何确定「什么样的重排序会导致程序执行结果改变」呢？实际上，这个问题作为开发者而言不需要关心，JMM贴心的提供了happens-before原则，会在后文详细介绍")])]),a._v(" "),t("h3",{attrs:{id:"有序性问题的根本-可见性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有序性问题的根本-可见性"}},[a._v("#")]),a._v(" 有序性问题的根本：可见性")]),a._v(" "),t("p",[a._v("有序性问题的根本还是可见性，即：如果保证了可见性，有序无序又有什么关系呢？")]),a._v(" "),t("p",[a._v("上面这段话有点长，可能不太好理解。我们来举个例子：")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" b "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("p",[a._v("看这两行代码，如果进行了重排序，导致行2先于行1执行，"),t("strong",[a._v("不会对程序的执行结果造成任何影响")]),a._v("。这就是为啥JMM的策略不是直接放弃重排序而保证绝对有序，此时："),t("strong",[a._v("程序无序执行根本不是问题")]),a._v("。")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[a._v("  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("print")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("p",[a._v("再看这两行代码，我们期望输出值“1”。如果进行了重排序，导致行2先于行1执行，但是行2仍然能够正确输出a为1，那么此时的有序性就不是问题。那如何保证行2在行1执行前能够看到a的值为1呢？"),t("strong",[a._v("那就是：保证行1先于行2执行，即保证程序执行的有序性，这是保证可见性的前提。")])]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("只要我们保证行1对行2的可见性，即行2能看到行1的修改，那有序无序无所谓；")])]),a._v(" "),t("li",[t("strong",[a._v("而要能够让行2看到行1的修改，我们需要让行1先于行2执行，即保证有序性。")])])]),a._v(" "),t("p",[a._v("因此：解决有序性问题，是为了解决有序性背后的可见性问题，这也是为什么JMM提供的happens-before原则，并不会强调有序性，而还是强调内存可见性。")]),a._v(" "),t("p",[a._v("现在你应该对有序性问题有了一个比较彻底的认识了，我们来看看JMM限制重排序的具体规则：")]),a._v(" "),t("h3",{attrs:{id:"jmm限制重排序的具体规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jmm限制重排序的具体规则"}},[a._v("#")]),a._v(" JMM限制重排序的具体规则")]),a._v(" "),t("p",[a._v("我们之前说过：限制部分重排序需要解决：「如何确定什么样的重排序会导致程序执行结果改变」这样一个问题。如果将这个问题抛给开发者，会是一件令人十分头疼的事情，因此JMM提供了happens-before规则。")]),a._v(" "),t("p",[a._v("JMM保障：只要你按照happens-before规则写代码，就能写出"),t("strong",[a._v("执行结果与你预期相符")]),a._v("的代码，不需要关心会发生什么重排序以及如何限制重排序等等问题。")]),a._v(" "),t("h4",{attrs:{id:"happens-before规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#happens-before规则"}},[a._v("#")]),a._v(" happens-before规则")]),a._v(" "),t("p",[a._v("happens-before规则是面向程序员的，这个规则屏蔽了对多个编译器和处理器的具体重排序规则，更强调结果，后续部分内容将happens-before简写为h-b。")]),a._v(" "),t("p",[a._v("happens-before关系的定义如下：")]),a._v(" "),t("ol",[t("li",[a._v("如果一个操作happens-before另一个操作，那么"),t("strong",[a._v("第一个操作的执行结果将对第二个操作可见")]),a._v("。")]),a._v(" "),t("li",[a._v("两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。")])]),a._v(" "),t("p",[a._v("可以看到，happens-before规则保证的是可见性，而不保证有序性。")]),a._v(" "),t("blockquote",[t("p",[a._v("尽管你也可以理解成happens-before规则保证了有序性，多了这样一个假设，不会对你的代码的执行结果有任何影响，但事实上happens-before就是没有保证绝对有序性，只通过保证部分有序性再保证可见性")])]),a._v(" "),t("p",[t("strong",[a._v("happens-before的具体规则如下：")])]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("一个线程中的每个操作")]),a._v("，先执行的操作 happen-before 后执行的操作")]),a._v(" "),t("li",[a._v("监视器锁的解锁"),t("code",[a._v("happens-before")]),a._v("加锁")]),a._v(" "),t("li",[a._v("对一个"),t("code",[a._v("volatile")]),a._v("域的写，"),t("code",[a._v("happens-before")]),a._v("于任意后续对这个"),t("code",[a._v("volatile")]),a._v("域的读")]),a._v(" "),t("li",[a._v("thread.start方法"),t("code",[a._v("happens-before")]),a._v("该线程的所有操作")]),a._v(" "),t("li",[a._v("在线程A中调用B.join()，"),t("code",[a._v("happens-before")]),a._v("线程A后续的所有操作")]),a._v(" "),t("li",[a._v("interrupt方法"),t("code",[a._v("happens-before")]),a._v(" Thread.isInterrupted 之前")]),a._v(" "),t("li",[t("code",[a._v("happens-before")]),a._v("具有传递性")])]),a._v(" "),t("p",[a._v("上述规则中，只有第一条是针对一个线程内的，其余规则都适用于多线程的场景。")]),a._v(" "),t("p",[a._v("happens-before既可以理解为JMM的一种规范，即上述所有规则的集合，也可以理解为两个操作之间的一种关系，即h-b规则的集合的某一条，A happens-before B就代表A的所有操作对B可见。")]),a._v(" "),t("h5",{attrs:{id:"as-if-serial-单线程语义的保证"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#as-if-serial-单线程语义的保证"}},[a._v("#")]),a._v(" as if serial：单线程语义的保证")]),a._v(" "),t("p",[t("strong",[a._v("as if serial只针对单线程")]),a._v("，具体是："),t("strong",[a._v("一个线程内的指令，虽然允许重排序，但是保证执行结果唯一，且与没有任何重排序的执行结果完全一致。")])]),a._v(" "),t("blockquote",[t("p",[a._v("as if serial本质就是happens-before中的一条特殊规则，由于仅仅as if serial是针对单线程的，因此作者们总时特地拿出来讲并有个响亮的名号叫as if serial")])]),a._v(" "),t("h3",{attrs:{id:"happens-before理解实战"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#happens-before理解实战"}},[a._v("#")]),a._v(" happens-before理解实战")]),a._v(" "),t("p",[a._v("下面举一些例子来帮助你彻底理解happens-before原则，如果答案和你预想的不一样，说明你对happens-before原则的掌握还不够透彻。")]),a._v(" "),t("blockquote",[t("p",[a._v("对一个"),t("code",[a._v("volatile")]),a._v("域的写，"),t("code",[a._v("happens-before")]),a._v("于任意后续对这个"),t("code",[a._v("volatile")]),a._v("域的读")]),a._v(" "),t("p",[a._v("另外，"),t("code",[a._v("volatile")]),a._v("关键字也保证了可见性。")])]),a._v(" "),t("p",[a._v("看这样一个场景，请问输出的a会是0还是1？")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 线程A")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("start")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 线程B")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    a "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("start")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br")])]),t("p",[a._v("答案是并不确定。你会说：不是规定了"),t("strong",[a._v("对volatile域的happens-before 对volatile域的读，所以线程B的所有操作对线程A可见嘛")]),a._v("？难道这原则有问题？别忘了CPU的调度，CPU先给读线程分配时间片，此时就读到了0。那这个happens-before规则到底规定了啥呢？一旦CPU先给写线程分配了时间片，执行完了"),t("code",[a._v("a = 1")]),a._v("这条写操作以后，任何的读操作都能读到 a 为1，而不会出现可见性问题。")]),a._v(" "),t("p",[a._v("再看一个例子，会有输出吗？")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[a._v("    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("boolean")]),a._v(" flag "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("false")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("   \n\t\t"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 线程1")]),a._v("\n\t\t"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("flag"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n                "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("start")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n \t\t"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 线程2")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            a "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n            flag "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("start")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br")])]),t("p",[a._v("也是一样的，并不一定会输出a。但如果我们保证线程2先于线程1执行，那就一定会有输出")]),a._v(" "),t("p",[a._v("到这里，相信你对happens-before原则了解的差不多了，那其实对JMM解决有序性的问题就了解的比较透彻了。我们再来看一些别的次要一些的问题。")]),a._v(" "),t("h3",{attrs:{id:"禁止重排序的方法-内存屏障"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#禁止重排序的方法-内存屏障"}},[a._v("#")]),a._v(" 禁止重排序的方法：内存屏障")]),a._v(" "),t("p",[a._v("JMM具体是如何限制重排序的？内存屏障：memory barriers，用于禁止某些指令重排序")]),a._v(" "),t("p",[a._v("JMM一共有如下四种内存屏障：")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("屏障类型")]),a._v(" "),t("th",[a._v("指令示例")]),a._v(" "),t("th",[a._v("说明")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("LoadLoad Barriers")]),a._v(" "),t("td",[a._v("Load1; LoadLoad; Load2")]),a._v(" "),t("td",[a._v("确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。")])]),a._v(" "),t("tr",[t("td",[a._v("StoreStore Barriers")]),a._v(" "),t("td",[a._v("Store1; StoreStore; Store2")]),a._v(" "),t("td",[a._v("确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。")])]),a._v(" "),t("tr",[t("td",[a._v("LoadStore Barriers")]),a._v(" "),t("td",[a._v("Load1; LoadStore; Store2")]),a._v(" "),t("td",[a._v("确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。")])]),a._v(" "),t("tr",[t("td",[a._v("StoreLoad Barriers")]),a._v(" "),t("td",[a._v("Store1; StoreLoad; Load2")]),a._v(" "),t("td",[a._v("确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。")])])])]),a._v(" "),t("blockquote",[t("p",[a._v("Load可以理解为从内存读，相对的Store就是向内存写")])]),a._v(" "),t("p",[a._v("我个人认为，普通的Java开发人员没有必要深入理解内存屏障，比如了解：为了实现volatile具体使用了哪些内存屏障？因为happens-before的存在就是为了帮助你屏蔽掉具体的内存屏障的。")]),a._v(" "),t("h3",{attrs:{id:"猜测执行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#猜测执行"}},[a._v("#")]),a._v(" 猜测执行")]),a._v(" "),t("p",[a._v("编译器和处理器会采用"),t("strong",[a._v("猜测执行（Speculation）")]),a._v("。比如：")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[a._v("    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("boolean")]),a._v(" flag "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("     \n\t "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("flag"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n   \t "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\t  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])]),t("p",[a._v("由于某种原因，比如上述代码，没有可能将flag修改为false，因此CPU猜测会执行输出"),t("code",[a._v("a*a")]),a._v("，于是：尽管if 与 {}之间存在依赖关系，但仍可以提前读取并计算a*a，然后把计算结果临时保存到一个名为**重排序缓冲（Reorder Buffer，ROB）**的硬件缓存中。像这样的代码，是特殊的，但对于程序员是透明的，并不影响我们的程序的执行结果。")]),a._v(" "),t("h2",{attrs:{id:"_3、解决原子性-cas与锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、解决原子性-cas与锁"}},[a._v("#")]),a._v(" 3、解决原子性：CAS与锁")]),a._v(" "),t("p",[a._v("Java解决原子性问题，没有之一的最核心的机制是：CAS。")]),a._v(" "),t("h3",{attrs:{id:"一、cas-compare-and-swap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、cas-compare-and-swap"}},[a._v("#")]),a._v(" 一、CAS ：Compare and Swap")]),a._v(" "),t("p",[a._v("CAS：Compare and Swap，比较并交换。用于"),t("strong",[a._v("在硬件层面上提供原子性操作")]),a._v("。在 Intel 处理器中，CAS通过指令"),t("code",[a._v("cmpxchg")]),a._v("实现。 比较是否和给定的数值一致，如果一致则修改，不一致则不修改。")]),a._v(" "),t("p",[a._v("CAS有如下三个变量")]),a._v(" "),t("ul",[t("li",[a._v("V：要更新的变量(var)")]),a._v(" "),t("li",[a._v("E：预期值(expected) 就是旧值")]),a._v(" "),t("li",[a._v("N：新值(new)")])]),a._v(" "),t("p",[a._v("CAS操作：判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。")]),a._v(" "),t("p",[a._v("当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。")]),a._v(" "),t("h4",{attrs:{id:"cas实现原理简述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cas实现原理简述"}},[a._v("#")]),a._v(" CAS实现原理简述")]),a._v(" "),t("p",[a._v("CAS凭啥能保证原子性呢？会不会出现两个线程同时做CAS并发现"),t("code",[a._v("Var = Eepected")]),a._v("，然后同时修改呢？")]),a._v(" "),t("p",[a._v("CAS是一条CPU的原子指令，是CPU层面保证的。Linux的X86下主要是通过"),t("code",[a._v("cmpxchgl")]),a._v("这个指令，但在多处理器情况下必须使用"),t("code",[a._v("lock")]),a._v("指令加锁来完成。不同的操作系统和处理器的实现各不相同。")]),a._v(" "),t("h4",{attrs:{id:"cas实现原子操作三大问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cas实现原子操作三大问题"}},[a._v("#")]),a._v(" CAS实现原子操作三大问题")]),a._v(" "),t("h5",{attrs:{id:"_1、aba问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、aba问题"}},[a._v("#")]),a._v(" 1、ABA问题")]),a._v(" "),t("p",[a._v("A->B->A，CAS检查不出变化。")]),a._v(" "),t("p",[a._v("ABA问题的本质是：一次CAS的旧值与另一次CAS的新值完全一样。")]),a._v(" "),t("p",[a._v("因此我们可以：加上"),t("strong",[a._v("版本号或者时间戳")]),a._v("。")]),a._v(" "),t("p",[a._v("JUC解决ABA问题：AtomicStampedReference，添加了时间戳")]),a._v(" "),t("h5",{attrs:{id:"_2、循环时间长开销大"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、循环时间长开销大"}},[a._v("#")]),a._v(" 2、循环时间长开销大")]),a._v(" "),t("p",[a._v("如果自旋CAS长时间不成功，会占用大量的CPU资源。")]),a._v(" "),t("p",[a._v("让JVM支持处理器提供的"),t("strong",[a._v("pause指令")])]),a._v(" "),t("h5",{attrs:{id:"_3、只能保证一个共享变量的原子操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、只能保证一个共享变量的原子操作"}},[a._v("#")]),a._v(" 3、只能保证一个共享变量的原子操作")]),a._v(" "),t("p",[a._v("如果要保证多个变量的操作的原子性，CAS就无能为力了。我们有两种解决方案：")]),a._v(" "),t("ul",[t("li",[a._v("锁机制，保证临界区的代码只有一个线程可以执行")]),a._v(" "),t("li",[a._v("使用JDK 1.5提供的"),t("code",[a._v("AtomicReference")]),a._v("类保证对象的原子性，把多个变量放到一个对象里面进行CAS操作；")])]),a._v(" "),t("h3",{attrs:{id:"二、锁机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、锁机制"}},[a._v("#")]),a._v(" 二、锁机制")]),a._v(" "),t("p",[a._v("除了偏向锁，JVM实现锁的方式都用了循环CAS，也就是几乎所有的Java的锁实现都依赖于CAS操作。后文分析synchronized与lock时会体现出如何用CAS来实现锁的。")]),a._v(" "),t("p",[a._v("Java主要提供了关键字synchronized和接口Lock用于实现锁机制。")]),a._v(" "),t("h3",{attrs:{id:"三大问题小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三大问题小结"}},[a._v("#")]),a._v(" 三大问题小结")]),a._v(" "),t("p",[a._v("到这里我们就分别解决了并发编程的三大问题，但还没有实现基本的功能："),t("strong",[a._v("显式同步，隐式通信")]),a._v("。Java提供了若干同步的方式，在本章节不希望具体到某一种同步方式，而是所有的同步方式。即对于开发者而言，我们更希望关注线程间具体如何同步，那么在正确同步的代码，JMM又提供了什么样的保证呢？")]),a._v(" "),t("h2",{attrs:{id:"顺序一致性-线程同步落地"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#顺序一致性-线程同步落地"}},[a._v("#")]),a._v(" 顺序一致性：线程同步落地")]),a._v(" "),t("p",[a._v("顺序一致性内存模型是一个理论参考模型，通常CPU，编程语言的内存模型的设计都会参考顺序一致性内存模型。")]),a._v(" "),t("p",[a._v("**JMM保证：如果程序是正确同步的，那么执行结果与该程序在顺序一致性内存模型中的执行结果相同。**看的一脸懵？什么是顺序一致性模型？下面我们来帮助你理解这句话的含义：")]),a._v(" "),t("h4",{attrs:{id:"顺序一致性内存模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#顺序一致性内存模型"}},[a._v("#")]),a._v(" 顺序一致性内存模型")]),a._v(" "),t("p",[a._v("顺序一致性内存模型具体是如下两条：")]),a._v(" "),t("ul",[t("li",[a._v("一个线程中的所有操作必须按照程序的顺序来执行")]),a._v(" "),t("li",[a._v("（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须"),t("strong",[a._v("原子执行且立刻对所有线程可见")]),a._v("。")])]),a._v(" "),t("p",[a._v("可以看到，顺序一致性模型保证了："),t("strong",[a._v("每个操作的原子性、可见性，以及单线程内所有操作的绝对有序性")]),a._v("。也就是说，只要程序正确同步，我们完全可以将多线程的执行理解成一个单一的操作执行顺序，所有操作原子，立即可见，且严格按照顺序执行。这是一个非常强力的保证。这使得开发者能够更加关注「同步的正确性」，而非总是为了「隐式通信」而担忧。")]),a._v(" "),t("h2",{attrs:{id:"jmm规范小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jmm规范小结"}},[a._v("#")]),a._v(" JMM规范小结")]),a._v(" "),t("p",[a._v("JMM是Java提出的实现并发编程的规范，提供两个基础功能：")]),a._v(" "),t("ul",[t("li",[a._v("线程通信")]),a._v(" "),t("li",[a._v("线程同步")])]),a._v(" "),t("p",[a._v("并采用了显式同步，隐式通信的模型实现上述功能。")]),a._v(" "),t("p",[a._v("同时为了克服硬件，操作系统等等带来的不确定性：")]),a._v(" "),t("ul",[t("li",[a._v("规定了线程本地内存与主存来解决变量的"),t("strong",[a._v("可见性")])]),a._v(" "),t("li",[a._v("提供happens-before规则，通过插入内存屏障从而限制重排序来解决程序执行的"),t("strong",[a._v("有序性")])]),a._v(" "),t("li",[a._v("通过CAS与锁机制(锁的实现也依赖于CAS)来解决程序执行的"),t("strong",[a._v("原子性")])])]),a._v(" "),t("p",[a._v("至此，整个JMM就讲解完毕了。")])])}),[],!1,null,null,null);t.default=n.exports}}]);