(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{304:function(t,a,s){t.exports=s.p+"assets/img/image-20240122110540197.6e7fe6e4.png"},305:function(t,a,s){t.exports=s.p+"assets/img/image-20230912211717368.5f4c0122.png"},372:function(t,a,s){"use strict";s.r(a);var r=s(14),n=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"synchronized关键字详解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronized关键字详解"}},[t._v("#")]),t._v(" synchronized关键字详解")]),t._v(" "),a("h2",{attrs:{id:"synchronized基本使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronized基本使用"}},[t._v("#")]),t._v(" synchronized基本使用")]),t._v(" "),a("p",[t._v("一般有三种方式：")]),t._v(" "),a("h4",{attrs:{id:"_1、修饰普通方法-锁this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、修饰普通方法-锁this"}},[t._v("#")]),t._v(" 1、修饰普通方法：锁this")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1. synchronized用在普通方法上，默认的锁就是this，当前实例")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("method")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("h4",{attrs:{id:"_2、修饰静态方法-锁this-class"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、修饰静态方法-锁this-class"}},[t._v("#")]),t._v(" 2、修饰静态方法：锁this.class")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2. synchronized用在静态方法上，默认的锁就是当前所在的Class类")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 所以无论是哪个线程访问它，需要的锁都只有一把")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("method")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("h4",{attrs:{id:"_3、同步代码块-自定义锁对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、同步代码块-自定义锁对象"}},[t._v("#")]),t._v(" 3、同步代码块：自定义锁对象")]),t._v(" "),a("p",[t._v("自定义锁对象可以是实例，也可以是Class对象")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SynchronizedObjectLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("blockquote",[a("p",[t._v("无论正常退出还是抛出异常，synchronized都保证能够释放锁。")])]),t._v(" "),a("h3",{attrs:{id:"锁与h-b规则的联系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁与h-b规则的联系"}},[t._v("#")]),t._v(" 锁与h-b规则的联系")]),t._v(" "),a("p",[t._v("我们知道，"),a("strong",[t._v("解锁操作 happens-before 加锁")]),t._v("，因此：")]),t._v(" "),a("p",[t._v("首先有个变量a，没有用volatile修饰")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("线程A先执行：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("writer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1")]),t._v("\n\t\ta"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \t\t\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \t\t\t\t\t\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("线程B后执行：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("reader")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 4")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \t\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 5")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \t\t\t\t\t\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 6 ")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("由h-b规则，3 h-b 4，再由as if serial和传递性原则，因此2 h-b 5，而h-b从开发人员的角度来说，你就可以理解为2在5之前执行，并且2的结果对5可见，因此5处读到的a，一定为1。")]),t._v(" "),a("h3",{attrs:{id:"synchronized的内存语义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronized的内存语义"}},[t._v("#")]),t._v(" synchronized的内存语义")]),t._v(" "),a("ul",[a("li",[t._v("当线程"),a("strong",[t._v("释放锁")]),t._v("时，JMM会把该线程对应的"),a("strong",[t._v("本地内存中的共享变量刷新到主内存")]),t._v("中。")]),t._v(" "),a("li",[t._v("当线程获取锁时，JMM会把该线程对应的本地内存置为无效")])]),t._v(" "),a("p",[t._v("可以看到：")]),t._v(" "),a("p",[t._v("锁释放与volatile写有相同的内存语义；")]),t._v(" "),a("p",[t._v("锁获取与volatile读有相同的内存语义。")]),t._v(" "),a("h2",{attrs:{id:"synchronized实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronized实现原理"}},[t._v("#")]),t._v(" synchronized实现原理")]),t._v(" "),a("p",[t._v("我个人非常推荐的一篇文字是："),a("a",{attrs:{href:"https://github.com/farmerjohngit/myblog/issues/12",target:"_blank",rel:"noopener noreferrer"}},[t._v("死磕Synchronized底层实现"),a("OutboundLink")],1),t._v("，是对着源码讲的，但也比较难啃。")]),t._v(" "),a("p",[t._v("下面我用尽量清晰简洁，绕过虚拟机源码的方式来讲一下：")]),t._v(" "),a("blockquote",[a("p",[t._v("会跳过一些源码细节的实现，不会影响整体流程和理解")])]),t._v(" "),a("p",[t._v("首先了解实现原理，第一步我会先看一下字节码指令：")]),t._v(" "),a("h2",{attrs:{id:"透过字节码看异常如何释放锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#透过字节码看异常如何释放锁"}},[t._v("#")]),t._v(" 透过字节码看异常如何释放锁")]),t._v(" "),a("p",[t._v("synchronized修饰的方法会被加上 "),a("code",[t._v("ACC_SYNCHRONIZED")]),t._v(" 的flag。")]),t._v(" "),a("p",[t._v("而同步代码块的字节码文件是这样的：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("monitorenter\t\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\nmonitorexit\t\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("goto")]),t._v(" xxx\nmonitorexit\nathrow\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Exception")]),t._v(" table"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\nfrom   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("to")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("target")]),t._v(" type\n "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v("     "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("14")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("17")]),t._v("    any\n "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("17")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("17")]),t._v("    any\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br")])]),a("p",[t._v("可以看到，"),a("code",[t._v("monitorenter")]),t._v("和"),a("code",[t._v("monitorexit")]),t._v("指令分别对应"),a("code",[t._v("synchronized")]),t._v("同步块的进入和退出。")]),t._v(" "),a("p",[t._v("有两个monitorexit，因为"),a("strong",[t._v("javac为同步代码块添加了一个隐式的try-finally，在finally中会调用"),a("code",[t._v("monitorexit")]),t._v("命令释放锁")]),t._v("。")]),t._v(" "),a("p",[t._v("尽管字节码通常都能帮助我们更好地理解语义，但关于synchronized的语义也就到此为止了，接下来就要深入虚拟机源码看看monitorenter（获取锁）和monitorexit（释放锁）到底都干了些什么，不过在此之前：")]),t._v(" "),a("p",[t._v("因为synchronized有四种锁状态，而锁状态的实现依赖于Java对象的mark word，这是实现synchronized的基础，我们先来看mark word如何表达锁状态的。")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("Java中的每一个对象都可以作为一个锁，包括Class对象")]),t._v("。")])]),t._v(" "),a("h2",{attrs:{id:"四种锁状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四种锁状态"}},[t._v("#")]),t._v(" 四种锁状态")]),t._v(" "),a("p",[t._v("Java对象头的mark word表达了这四种状态，如下：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("锁状态")]),t._v(" "),a("th",[t._v("29 bit 或 61 bit")]),t._v(" "),a("th",[t._v("1 bit 是否是偏向锁？")]),t._v(" "),a("th",[t._v("2 bit 锁标志位")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("无锁")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("0")]),t._v(" "),a("td",[t._v("01")])]),t._v(" "),a("tr",[a("td",[t._v("偏向锁")]),t._v(" "),a("td",[t._v("线程ID")]),t._v(" "),a("td",[t._v("1")]),t._v(" "),a("td",[t._v("01")])]),t._v(" "),a("tr",[a("td",[t._v("轻量级锁")]),t._v(" "),a("td",[t._v("指向栈中锁记录的指针")]),t._v(" "),a("td",[t._v("此时这一位不用于标识偏向锁")]),t._v(" "),a("td",[t._v("00")])]),t._v(" "),a("tr",[a("td",[t._v("重量级锁")]),t._v(" "),a("td",[t._v("指向互斥量（重量级锁）的指针")]),t._v(" "),a("td",[t._v("此时这一位不用于标识偏向锁")]),t._v(" "),a("td",[t._v("10")])]),t._v(" "),a("tr",[a("td",[t._v("GC标记")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("此时这一位不用于标识偏向锁")]),t._v(" "),a("td",[t._v("11")])])])]),t._v(" "),a("blockquote",[a("p",[t._v("注意轻/重锁的mark word内是持有一个指向锁记录的指针的。")])]),t._v(" "),a("p",[t._v("因此，一个对象其实有四种锁状态,级别由低到高:")]),t._v(" "),a("ol",[a("li",[t._v("无锁状态")]),t._v(" "),a("li",[t._v("偏向锁状态")]),t._v(" "),a("li",[t._v("轻量级锁状态")]),t._v(" "),a("li",[t._v("重量级锁状态")])]),t._v(" "),a("h2",{attrs:{id:"_1、无锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、无锁"}},[t._v("#")]),t._v(" 1、无锁")]),t._v(" "),a("p",[t._v("释放轻量级锁，没有线程在尝试获取锁，也没有线程持有锁（正在执行同步代码块），就是无锁。")]),t._v(" "),a("h2",{attrs:{id:"_2、偏向锁-jdk15被废弃"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、偏向锁-jdk15被废弃"}},[t._v("#")]),t._v(" 2、偏向锁（JDK15被废弃）")]),t._v(" "),a("blockquote",[a("p",[t._v("偏向锁在JDK1.6引入，在JDK15被废弃，了解即可。如果一定要用，需要手动打开：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UseBiasedLocking")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])])]),t._v(" "),a("p",[t._v("人们发现大多数情况下"),a("strong",[t._v("锁不仅不存在多线程竞争，而且总是由同一线程多次获得")]),t._v("，于是有了偏向锁。")]),t._v(" "),a("p",[t._v("偏向锁顾名思义，偏向于第一个访问锁的线程。偏向锁在"),a("strong",[t._v("资源无竞争")]),t._v("情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。")]),t._v(" "),a("p",[t._v("当开启偏向锁功能时，创建的新对象是可偏向状态，此时mark word中的thread id为0，也叫做匿名偏向。当该对象第一次被CAS成功时，成为「偏向锁」。")]),t._v(" "),a("p",[t._v("在该线程又一次尝试获取该对象锁时，发现thread id就是自己，就可以不做CAS直接认为已经拿到了锁并执行同步代码块中的代码。")]),t._v(" "),a("blockquote",[a("p",[t._v("注意上述的所有，都只出现了一个线程")])]),t._v(" "),a("p",[a("strong",[t._v("当第二个线程出现并尝试获取锁，无论如何都会升级成「轻量级锁」。")])]),t._v(" "),a("ul",[a("li",[t._v("如果第一个线程正在执行同步代码块，锁偏向的线程继续拥有锁，当前线程升级该锁为「轻量级锁」。")]),t._v(" "),a("li",[t._v("如果第一个线程不在执行同步代码块，先将对象头的"),a("code",[t._v("mark word")]),t._v("改为无锁状态，再升级为「轻量级锁」。")])]),t._v(" "),a("p",[a("strong",[t._v("也就是是要有两个线程尝试获取锁，不论是否出现资源竞争，升级为「轻量级锁」")]),t._v("。")]),t._v(" "),a("blockquote",[a("p",[t._v("当然这个说法不绝对，因为还有批量重偏向这一机制。但从了解的角度，到这就可以了")])]),t._v(" "),a("h2",{attrs:{id:"_3、轻量级锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、轻量级锁"}},[t._v("#")]),t._v(" 3、轻量级锁")]),t._v(" "),a("p",[t._v("升级到「轻量级锁」的条件是：存在多个线程尝试CAS获取同一把锁，尽管彼此之间互不影响。而「轻量级锁」继续膨胀为「重量级锁」的条件是：只要CAS失败，就升级，即发生了：一个线程正在执行同步代码块的同时，另一个线程尝试获取锁。")]),t._v(" "),a("h3",{attrs:{id:"轻量级锁会自旋吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁会自旋吗"}},[t._v("#")]),t._v(" 轻量级锁会自旋吗")]),t._v(" "),a("p",[t._v("自旋：不断尝试去获取锁，一般用循环来实现。")]),t._v(" "),a("p",[t._v("一个常见的说法是：轻量级锁会自旋10次，失败则升级为重量级锁。")]),t._v(" "),a("p",[t._v("但 Java 8 就已经不会自旋了。")]),t._v(" "),a("h4",{attrs:{id:"自旋的说法从何而来"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自旋的说法从何而来"}},[t._v("#")]),t._v(" 自旋的说法从何而来")]),t._v(" "),a("p",[t._v("《Java并发编程的艺术》(2015)原文是：")]),t._v(" "),a("blockquote",[a("p",[t._v("线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。")])]),t._v(" "),a("p",[t._v("《深入浅出Java多线程1.0.0》原文是：")]),t._v(" "),a("blockquote",[a("p",[t._v("然后线程尝试用CAS将锁的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。")])]),t._v(" "),a("p",[t._v("总之，以上两位作者认为会发生自旋。")]),t._v(" "),a("p",[t._v("《深入理解Java虚拟机》(2019)原文是：")]),t._v(" "),a("blockquote",[a("p",[t._v("如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态值变为“10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。")])]),t._v(" "),a("p",[t._v("周志明大大的意思是：出现两条以上的线程争用同一个锁的情况，就要升级为重量级锁")]),t._v(" "),a("p",[t._v("显然，这两种观点是有冲突的，核心问题在于：")]),t._v(" "),a("p",[a("strong",[t._v("轻量级锁状态下，发生资源竞争，到底是自旋，还是立刻锁膨胀？")])]),t._v(" "),a("h4",{attrs:{id:"看源码来考证说法的正确性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#看源码来考证说法的正确性"}},[t._v("#")]),t._v(" 看源码来考证说法的正确性")]),t._v(" "),a("p",[t._v("那么我们也只能自己去验证说法的正确性了。")]),t._v(" "),a("p",[t._v("相关的资料推荐：")]),t._v(" "),a("ul",[a("li",[t._v("文章："),a("a",{attrs:{href:"https://www.imooc.com/article/323412",target:"_blank",rel:"noopener noreferrer"}},[t._v("Synchronized轻量级锁会自旋？好像并不是这样的"),a("OutboundLink")],1)]),t._v(" "),a("li",[t._v("视频："),a("a",{attrs:{href:"https://space.bilibili.com/416747307/channel/collectiondetail?sid=1389015",target:"_blank",rel:"noopener noreferrer"}},[t._v("为锁正名"),a("OutboundLink")],1)])]),t._v(" "),a("h3",{attrs:{id:"轻量级锁实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁实现原理"}},[t._v("#")]),t._v(" 轻量级锁实现原理")]),t._v(" "),a("h4",{attrs:{id:"获取锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#获取锁"}},[t._v("#")]),t._v(" 获取锁")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("发现是无锁状态，线程会"),a("strong",[t._v("把锁的Mark Word复制到自己的Displaced Mark Word（栈帧中的一块空间）")]),t._v("，然后通过CAS尝试将锁的Mark Word修改为一根指针，指向自己的Displaced Mark Word（Displaced Mark Word与原mark word的内容一模一样）")])]),t._v(" "),a("li",[a("p",[t._v("发现处于轻量级锁状态")]),t._v(" "),a("ul",[a("li",[t._v("如果轻量级锁的markword指向自己的Displaced Mark Word，代表重入锁，那么获取锁成功（如果是重入，会将markword改为null，空指针，即0）")]),t._v(" "),a("li",[t._v("如果轻量级锁的markword不是指向自己，锁膨胀，升级为「重量级锁」")])])])]),t._v(" "),a("h4",{attrs:{id:"释放锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#释放锁"}},[t._v("#")]),t._v(" 释放锁")]),t._v(" "),a("p",[t._v("首先，遍历线程栈，拿到所有需要做解锁操作的锁对象：")]),t._v(" "),a("ol",[a("li",[t._v("如果是null，代表可重入的锁，直接解锁成功")]),t._v(" "),a("li",[t._v("如果不是重入的锁：\n"),a("ul",[a("li",[t._v("如果markword被修改，说明发生了竞争，已经成为「重量级锁」了，「尝试解锁重量级锁」")]),t._v(" "),a("li",[t._v("如果markword没被修改，尝试CAS还原对象的markword\n"),a("ul",[a("li",[t._v("还原成功，轻量级锁解锁成功")]),t._v(" "),a("li",[t._v("还原失败，仍然是「尝试解锁重量级锁」")])])])])])]),t._v(" "),a("blockquote",[a("p",[t._v("补充说明：线程A正在执行同步代码块时，此时有线程CAS失败，虽然升级为「重量级锁」，但仍然由线程A持有锁，「如何膨胀为重量级锁」后文马上分析")])]),t._v(" "),a("h2",{attrs:{id:"_4、重量级锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、重量级锁"}},[t._v("#")]),t._v(" 4、重量级锁")]),t._v(" "),a("p",[t._v("为了实现锁膨胀，避免并发膨胀锁，定义了四种膨胀锁状态：")]),t._v(" "),a("ul",[a("li",[t._v("膨胀完毕")]),t._v(" "),a("li",[t._v("膨胀中")]),t._v(" "),a("li",[t._v("无锁")]),t._v(" "),a("li",[t._v("轻量级锁")])]),t._v(" "),a("p",[t._v("下面依次对这些情况的膨胀进行分析：")]),t._v(" "),a("h4",{attrs:{id:"重量级锁的生成-锁膨胀"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重量级锁的生成-锁膨胀"}},[t._v("#")]),t._v(" 重量级锁的生成/锁膨胀")]),t._v(" "),a("ul",[a("li",[t._v("若膨胀完毕，直接返回monitor")]),t._v(" "),a("li",[t._v("若膨胀中，线程等待一会，直到别的线程膨胀完毕，然后拿到别人生成的monitor")])]),t._v(" "),a("p",[t._v("从轻量级锁开始膨胀：")]),t._v(" "),a("ol",[a("li",[t._v("创建monitor对象")]),t._v(" "),a("li",[t._v("CAS将锁状态修改为「膨胀中」\n"),a("ul",[a("li",[t._v("失败，说明别人在膨胀了，等待，然后返回别人生成的monitor")]),t._v(" "),a("li",[t._v("成功：\n"),a("ul",[a("li",[t._v("将markword保存至monitor")]),t._v(" "),a("li",[t._v("设置持有monitor的线程")]),t._v(" "),a("li",[t._v("将monitor地址设置为mark word")]),t._v(" "),a("li",[t._v("返回monitor对象")])])])])])]),t._v(" "),a("p",[t._v("从无锁开始膨胀，差不多：")]),t._v(" "),a("ol",[a("li",[t._v("创建monitor对象")]),t._v(" "),a("li",[t._v("将markword保存至monitor")]),t._v(" "),a("li",[t._v("CAS将锁状态修改为「膨胀中」\n"),a("ul",[a("li",[t._v("失败，说明别人在膨胀了，等待，然后返回别人生成的monitor")]),t._v(" "),a("li",[t._v("成功，返回monitor对象")])])])]),t._v(" "),a("h3",{attrs:{id:"重量级锁实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重量级锁实现原理"}},[t._v("#")]),t._v(" 重量级锁实现原理")]),t._v(" "),a("p",[t._v("生成了重量级锁，mark word会指向堆中实际生成的monitor对象，我们先来看看monitor对象的结构：")]),t._v(" "),a("p",[a("img",{attrs:{src:s(304),alt:"image-20240122110540197"}})]),t._v(" "),a("p",[t._v("简单解释一下：")]),t._v(" "),a("ul",[a("li",[t._v("Contention List(cxq)：所有请求锁的线程将被首先放置到该竞争队列，是先进后出的栈结构")]),t._v(" "),a("li",[t._v("Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List")]),t._v(" "),a("li",[t._v("Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set")]),t._v(" "),a("li",[t._v("OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck")]),t._v(" "),a("li",[t._v("Owner：获得锁的线程称为Owner")]),t._v(" "),a("li",[t._v("!Owner：释放锁的线程")])]),t._v(" "),a("h3",{attrs:{id:"获取锁-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#获取锁-2"}},[t._v("#")]),t._v(" 获取锁")]),t._v(" "),a("blockquote",[a("p",[t._v("对于重量级锁，尝试获取锁具体是指：尝试用CAS将monitor对象的Owner从nullptr改变为自己")])]),t._v(" "),a("p",[t._v("当一个线程尝试获得重量级锁时")]),t._v(" "),a("ul",[a("li",[t._v("首先尝试「自旋」，调用trySpin方法获取锁，如果第一次失败，再进行一次trySpin方法（最坏情况拿不到锁会调用两次trySpin），然后『用CAS的方式进入cxq』")]),t._v(" "),a("li",[t._v("进入cxq后，陷入「死循环」，死循环中，可能会从cxq转移到EntryList，可能阻塞，也可能调用trySpin方法自旋。后文再详细分析「死循环」")])]),t._v(" "),a("p",[t._v("可以看到「死循环」的实现也依赖trySpin自旋，因此我们先来看看「自旋」的实现逻辑：")]),t._v(" "),a("h4",{attrs:{id:"_1、自旋锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、自旋锁"}},[t._v("#")]),t._v(" 1、自旋锁")]),t._v(" "),a("p",[t._v("自旋：不断尝试去获取锁，一般用循环来实现。")]),t._v(" "),a("blockquote",[a("p",[t._v("如果是单核CPU，自旋是无意义的，所以只有多处理器才会开启自旋功能")])]),t._v(" "),a("p",[t._v("自旋的出现，是为了避免切换到内核态，因为线程的阻塞和唤醒依赖内核，我们希望能够一定程度上避免这种内核态与用户态的切换，因此有了「自旋锁」。那么自旋多少次更合适呢？")]),t._v(" "),a("ul",[a("li",[t._v("在锁很快被释放时，自旋既不会带来CPU资源的浪费，还能提高运行效率。此时自旋次数过少，可能会导致没能顺利拿到锁，即使结束自旋后不久锁就被释放了。")]),t._v(" "),a("li",[t._v("在锁很久才被释放时，自旋空转占用CPU资源却迟迟拿不到锁，造成过多的CPU资源浪费。此时自旋次数过多，反而会得不偿失。")])]),t._v(" "),a("p",[t._v("因此，JDK发明了自适应自旋，来适应各种情况的锁。")]),t._v(" "),a("h5",{attrs:{id:"自适应自旋"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自适应自旋"}},[t._v("#")]),t._v(" 自适应自旋")]),t._v(" "),a("p",[t._v("自适应自旋为了权衡自旋次数过多和过少带来的弊端，它的基本思想是：")]),t._v(" "),a("ul",[a("li",[t._v("自旋成功拿到锁了，说明你下次成功的概率也很大，下次自旋的次数会更多")]),t._v(" "),a("li",[t._v("自旋失败，说明你下次也大概率拿不到，下次自旋的次数会更少")])]),t._v(" "),a("p",[t._v("自适应自旋参数如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:s(305),alt:"image-20230912211717368"}})]),t._v(" "),a("h5",{attrs:{id:"自旋逻辑-tryspin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自旋逻辑-tryspin"}},[t._v("#")]),t._v(" 自旋逻辑：trySpin")]),t._v(" "),a("p",[t._v("首选预自旋11次（避免预自旋次数设置为0，源码后面对这个参数加了1），如果没拿到锁：")]),t._v(" "),a("p",[t._v("开始自旋5000次（假设是第一次开始自旋，上限就为5000）")]),t._v(" "),a("ul",[a("li",[t._v("成功，下次+100，下次可以最多自旋5100次")]),t._v(" "),a("li",[t._v("失败，下次- 200，下次可以最多自旋4800次，不会少于1000次")])]),t._v(" "),a("h4",{attrs:{id:"_2、死循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、死循环"}},[t._v("#")]),t._v(" 2、死循环")]),t._v(" "),a("p",[t._v("死循环主要是在「阻塞」和「自旋」之间切换")]),t._v(" "),a("ul",[a("li",[t._v("park阻塞，注意不会移动到WaitSet中")]),t._v(" "),a("li",[t._v("unpark唤醒，再次调用trySpin方法自旋获取锁，如果失败，陷入阻塞")])]),t._v(" "),a("p",[t._v("只有释放锁时，才会调用unpark唤醒，进入自旋状态，此时并不是一定能拿到锁的。")]),t._v(" "),a("h5",{attrs:{id:"唤醒的时机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#唤醒的时机"}},[t._v("#")]),t._v(" 唤醒的时机")]),t._v(" "),a("p",[t._v("释放锁时才会唤醒，且只会唤醒一个，唤醒逻辑取决于Policy参数。")]),t._v(" "),a("h5",{attrs:{id:"cxq和entrylist内线程的行为"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cxq和entrylist内线程的行为"}},[t._v("#")]),t._v(" cxq和EntryList内线程的行为")]),t._v(" "),a("p",[t._v("这两个区域内的线程几乎是全阻塞的，这两个区域内的线程，保证最多只有一个线程去竞争锁资源，这个被『释放锁时唤醒的唯一的线程』叫「假定继承人」，即Monitor结构中的「OnDeck」。")]),t._v(" "),a("p",[t._v("注意：只保证所有阻塞的线程，只有一个去竞争锁资源，仍然可能被外来的线程在进入cxq之前就抢到了锁，所以说synchronized是不公平的。")]),t._v(" "),a("blockquote",[a("p",[t._v("EntryList内的线程全部来自cxq，在释放锁与调用notify方法时，可能进入EntryList")])]),t._v(" "),a("h3",{attrs:{id:"释放锁-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#释放锁-2"}},[t._v("#")]),t._v(" 释放锁")]),t._v(" "),a("ol",[a("li",[t._v("通过CAS的方式将Monitor结构的Owner修改为nullptr")]),t._v(" "),a("li",[t._v("根据QMode参数的不同，执行不同的逻辑")])]),t._v(" "),a("p",[t._v("因为QMode默认值为0，我们来看一下"),a("strong",[t._v("默认的逻辑")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("如果EntryList和cxq均为空：什么也不做")]),t._v(" "),a("li",[t._v("如果EntryList非空：就取EntryList首元素唤醒")]),t._v(" "),a("li",[t._v("如果EntryList为空，cxq非空：将cxq的所有线程放到EntryList，再唤醒EntryList首元素；")])]),t._v(" "),a("p",[t._v("锁被持有时，EntryList和cxq的所有线程都阻塞，有且只有锁释放这唯一一个行为能够唤醒其中的一个线程。")]),t._v(" "),a("h4",{attrs:{id:"为什么要区分cxq和entrylist"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要区分cxq和entrylist"}},[t._v("#")]),t._v(" 为什么要区分cxq和EntryList")]),t._v(" "),a("p",[t._v("是为了解决CAS的ABA问题，也能分散请求，提高性能。")]),t._v(" "),a("p",[t._v("cxq和EntryList都是为了存储所有阻塞的线程，但是：")]),t._v(" "),a("ul",[a("li",[t._v("释放锁并唤醒时，只会唤醒EntryList的线程，这是删除操作")]),t._v(" "),a("li",[t._v("线程自旋次数过多需要被阻塞时，只会插入cxq队列，这是添加操作")])]),t._v(" "),a("p",[a("strong",[t._v("把这两种操作分离开来有什么好处呢？")])]),t._v(" "),a("h5",{attrs:{id:"_1、提高性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、提高性能"}},[t._v("#")]),t._v(" 1、提高性能")]),t._v(" "),a("p",[t._v("由于锁只有一把，因此做删除操作的线程只有一个，不存在线程安全问题，不需要做CAS，如果和添加操作混在一起，就不得不考虑线程安全问题了。这样只需要在cxq内考虑CAS即可。")]),t._v(" "),a("h5",{attrs:{id:"_2、解决aba问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、解决aba问题"}},[t._v("#")]),t._v(" 2、解决ABA问题")]),t._v(" "),a("p",[t._v("因为多个线程同时add，不会有某个线程出现在cxq里两次，因此只add不会有ABA问题。而一旦存在删除操作，那么ABA问题就是有可能的。")]),t._v(" "),a("h3",{attrs:{id:"可感知的锁控制权"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可感知的锁控制权"}},[t._v("#")]),t._v(" 可感知的锁控制权")]),t._v(" "),a("p",[t._v("现在知道了加解锁的原理，那其实我们已经有能力知道，释放锁时会唤醒哪个线程。（暂时不考虑wait/notify）")]),t._v(" "),a("p",[t._v("结论：先阻塞的线程，最晚获得锁。")]),t._v(" "),a("p",[t._v("有三个线程，t1,t2,t3。这三个线程都自旋失败，插入cxq，由于是个栈，越晚进入cxq的，反而越早进入EntryList，顺序为t3,t2,t1。而唤醒时是按照EntryList的顺序去唤醒的，因此「并不是所谓的随机唤醒」。当然，如果此时有别的线程t4自旋未进入cxq，是有可能拿到锁的，但我们保证：t3先于t2被唤醒，t2先于t1被唤醒")]),t._v(" "),a("h2",{attrs:{id:"锁状态的降级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁状态的降级"}},[t._v("#")]),t._v(" 锁状态的降级")]),t._v(" "),a("blockquote",[a("p",[t._v("关于锁升级，「四种锁状态」已经说的足够清楚了，在这里简单说一说锁降级")])]),t._v(" "),a("p",[t._v("关于降级，HotSpot是支持降级的，《Java并发编程的艺术》中的说法是无法降级，可能是因为当时还不支持，R大关于锁状态的降级也指出：不当的降级可能会影响性能。")]),t._v(" "),a("h2",{attrs:{id:"编译器对-synchronized-的优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编译器对-synchronized-的优化"}},[t._v("#")]),t._v(" 编译器对 synchronized 的优化")]),t._v(" "),a("h4",{attrs:{id:"_1、锁消除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、锁消除"}},[t._v("#")]),t._v(" 1、锁消除")]),t._v(" "),a("p",[t._v("如果编译器发现不会发生线程安全问题，就会无视了你的锁。")]),t._v(" "),a("h4",{attrs:{id:"_2、锁粗化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、锁粗化"}},[t._v("#")]),t._v(" 2、锁粗化")]),t._v(" "),a("p",[t._v("比如执行插入数据商品时，是对店铺加锁。那么批量执行的时候，只需要加一次锁。而不是每插入一次就加/释放一次锁。")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("  "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StringBuffer")]),t._v(" sb "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StringBuffer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     sb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("append")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     sb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("append")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     sb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("append")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 线程安全的buffer类，append会加锁，但显然这是可以锁粗化的，会优化成只获得/释放一次锁")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("h2",{attrs:{id:"synchronized-与包装类的坑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-与包装类的坑"}},[t._v("#")]),t._v(" synchronized 与包装类的坑")]),t._v(" "),a("p",[t._v("Integer并不适合当作锁对象。")]),t._v(" "),a("p",[t._v("因为Integer有缓存机制，-128~127有缓存。容易导致锁失效。")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" ticket "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("比如两个线程抢票，不能锁住 ticket。抢完票以后ticket--，一个线程A锁的是ticket = 10的对象，另一个线程B执行完ticket = 10的临界区代码，ticket--，再走临界区，他的锁变成了9，与A竞争的都不是一把锁，因此两者都会抢到锁。")]),t._v(" "),a("p",[t._v("因此：")]),t._v(" "),a("ul",[a("li",[t._v("锁住的对象尽量是静态的不变的，比如class类")]),t._v(" "),a("li",[t._v("不能是各种有缓存的包装类")]),t._v(" "),a("li",[t._v("在idea中没有声明final的对象加synchronized会提示不安全")])]),t._v(" "),a("h3",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),a("p",[t._v("到这里，应该对synchronized锁机制非常熟悉了，你应该清楚：")]),t._v(" "),a("ul",[a("li",[t._v("Monitor锁的底层结构图")]),t._v(" "),a("li",[t._v("自旋的原理和应用")]),t._v(" "),a("li",[t._v("重量级锁加解锁的逻辑等")])]),t._v(" "),a("p",[t._v("下篇文章，我们趁热打铁来学习一下wait/notify的底层原理，至今仍未露面的WaitSet终于要登场了，学完wait/notify整个synchronized也就 “证据链闭环” 了。")]),t._v(" "),a("blockquote",[a("p",[t._v("从趁热打铁的角度，趁你还对加解锁和Monitor结构足够熟悉，我非常推荐紧接着阅读「wait/notify 的底层原理」。")])]),t._v(" "),a("h3",{attrs:{id:"参考文献"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[t._v("#")]),t._v(" 参考文献")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/boling_cavalry/article/details/77793224",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java的wait()、notify()学习三部曲"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://space.bilibili.com/416747307/channel/collectiondetail?sid=1389015",target:"_blank",rel:"noopener noreferrer"}},[t._v("为锁正名"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/farmerjohngit/myblog/issues/12",target:"_blank",rel:"noopener noreferrer"}},[t._v("死磕Synchronized底层实现"),a("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=n.exports}}]);