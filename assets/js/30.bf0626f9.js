(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{330:function(a,t,e){a.exports=e.p+"assets/img/image-20240116220519763.0c468ef9.png"},331:function(a,t,e){a.exports=e.p+"assets/img/image-20240116220543113.d225f4a7.png"},400:function(a,t,e){"use strict";e.r(t);var v=e(14),r=Object(v.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"彻底搞懂-g1-的工作原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#彻底搞懂-g1-的工作原理"}},[a._v("#")]),a._v(" 彻底搞懂 G1 的工作原理")]),a._v(" "),t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),t("ul",[t("li",[a._v("YoungGC和MixedGC会STW吗")]),a._v(" "),t("li",[a._v("全局并发标记和YoungGC、MixedGC有什么关系吗")]),a._v(" "),t("li",[a._v("YoungGC会整堆扫描吗？如果不会，G1是如何做到的")])]),a._v(" "),t("p",[a._v("带着这些疑问，我们就正式开始说G1了。")]),a._v(" "),t("blockquote",[t("p",[a._v("如果有不懂的名词或关系，可以参考："),t("a",{attrs:{href:"https://juejin.cn/post/7276260308514193448",target:"_blank",rel:"noopener noreferrer"}},[a._v("GC方法论：关于JVM垃圾回收机制必须掌握的基础知识"),t("OutboundLink")],1),a._v("。")])]),a._v(" "),t("h2",{attrs:{id:"g1的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#g1的特点"}},[a._v("#")]),a._v(" G1的特点")]),a._v(" "),t("p",[a._v("G1： Garbage-First")]),a._v(" "),t("p",[a._v("最大的特点就是：停顿时间可控，这也是G1名字的由来")]),a._v(" "),t("p",[a._v("G1一共有两个过程是并发的。逻辑上分代，物理上分区。")]),a._v(" "),t("p",[a._v("G1在正常工作时，只有Young GC和Mixed GC交替，一般不会出现Full GC的，设计理念就是尽量避免Full GC。")]),a._v(" "),t("h2",{attrs:{id:"g1采取的垃圾收集算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#g1采取的垃圾收集算法"}},[a._v("#")]),a._v(" G1采取的垃圾收集算法")]),a._v(" "),t("p",[a._v("不管是新生代还是年老代，回收算法都是采用"),t("strong",[a._v("复制算法")]),a._v("。")]),a._v(" "),t("p",[a._v("但实际上，因为物理分区，所以区内是标记复制算法，"),t("strong",[a._v("整体上来看整个堆，是一种标记整理")])]),a._v(" "),t("h2",{attrs:{id:"g1的逻辑分代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#g1的逻辑分代"}},[a._v("#")]),a._v(" G1的逻辑分代")]),a._v(" "),t("h4",{attrs:{id:"新生代-老年代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新生代-老年代"}},[a._v("#")]),a._v(" 新生代，老年代")]),a._v(" "),t("p",[a._v("Eden，Survivor，Old的代的概念都被保留")]),a._v(" "),t("p",[a._v("默认新生代对堆内存的初始占比是5%，最多60%，且比例仍然是8:1:1")]),a._v(" "),t("h4",{attrs:{id:"humongous-存储大对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#humongous-存储大对象"}},[a._v("#")]),a._v(" Humongous：存储大对象")]),a._v(" "),t("p",[a._v("除了Eden，Survivor，Old区域，G1还额外多了一个Humongous区域，专门用于"),t("strong",[a._v("存放巨型对象")]),a._v("。")]),a._v(" "),t("p",[t("strong",[a._v("如果一个对象的大小超过Region容量的50%以上，就认为是大对象")]),a._v("。")]),a._v(" "),t("p",[a._v("如果一个H区装不下巨型对象，那么G1会寻找连续的H分区来存储，如果寻找不到连续的H区的话，就不得不启动 Full GC 了。")]),a._v(" "),t("blockquote",[t("p",[a._v("G1提出Humongous区域的意义：")]),a._v(" "),t("p",[a._v("CMS的做法是直接将大对象放入老年代 ，然而大对象未必就一定存活很久，直接放入老年代是不妥的。")])]),a._v(" "),t("h2",{attrs:{id:"g1的物理分区-region"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#g1的物理分区-region"}},[a._v("#")]),a._v(" G1的物理分区：Region")]),a._v(" "),t("p",[a._v("G1将Java堆划分为多个大小相等的独立的"),t("code",[a._v("Region")]),a._v("区域，默认2048个Region。每个Region都可以属于某个代。")]),a._v(" "),t("p",[t("img",{attrs:{src:e(330),alt:"image-20240116220519763"}})]),a._v(" "),t("h4",{attrs:{id:"card-堆内存的最小粒度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#card-堆内存的最小粒度"}},[a._v("#")]),a._v(" card：堆内存的最小粒度")]),a._v(" "),t("p",[a._v("每个Region内部，又会被分割为若干个卡片，一个卡片的大小为512B。")]),a._v(" "),t("h4",{attrs:{id:"region内部结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#region内部结构"}},[a._v("#")]),a._v(" Region内部结构")]),a._v(" "),t("p",[a._v("一个Region内部有如下五个指针：")]),a._v(" "),t("p",[t("img",{attrs:{src:e(331),alt:"image-20240116220543113"}})]),a._v(" "),t("p",[a._v("三个好理解的：")]),a._v(" "),t("ul",[t("li",[a._v("bottom：Region块的起始位置")]),a._v(" "),t("li",[a._v("end：Region块的结束位置，end - top就是一个Region块的大小")]),a._v(" "),t("li",[a._v("top："),t("code",[a._v("bottom ~ top")]),a._v("属于Region已经被使用的空间；"),t("code",[a._v("top ~ end")]),a._v("属于空闲空间 top是空闲内存与已使用内存的分界线")])]),a._v(" "),t("p",[a._v("TAMS：top-at-mark-start")]),a._v(" "),t("p",[a._v("又分为previous和next，就是前一次和后一次嘛，就是"),t("strong",[a._v("前后两次发生并发标记时的位置")]),a._v("。")]),a._v(" "),t("p",[a._v("那这俩指针有什么用呢？考虑这样一个问题：并发标记是不是可打断的？")]),a._v(" "),t("h4",{attrs:{id:"bitmap-维护对象的标记"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bitmap-维护对象的标记"}},[a._v("#")]),a._v(" BitMap：维护对象的标记")]),a._v(" "),t("p",[a._v("三色标记法，会将对象标记成三种颜色，如何维护这个颜色呢？")]),a._v(" "),t("p",[a._v("一种做法是，借用对象的mark word的mark bit。")]),a._v(" "),t("p",[a._v("但G1的选择是在外部为每个Region维护两个BitMap：")]),a._v(" "),t("p",[a._v("一个是"),t("code",[a._v("prevBitmap [bottom, prevTAMS)")]),a._v("，而另一个是 "),t("code",[a._v("nextBitmap [bottom, nextTAMS)")]),a._v("。这两个bitmap维护了内部两个指针之间对象的存活状况。")]),a._v(" "),t("h5",{attrs:{id:"为什么需要prev"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要prev"}},[a._v("#")]),a._v(" 为什么需要prev？")]),a._v(" "),t("p",[a._v("因为并发标记是可以被YoungGC打断的，所以还需要个prev区域维护旧的BitMap。")]),a._v(" "),t("h4",{attrs:{id:"tams指针与bitmap如何配合工作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tams指针与bitmap如何配合工作"}},[a._v("#")]),a._v(" TAMS指针与BitMap如何配合工作")]),a._v(" "),t("p",[a._v("并发标记开始时，next TAMS = top，在并发标记的过程中，所有新对象分配在next TAMS之后，这些对象不会被GC。")]),a._v(" "),t("p",[a._v("对于第n轮并发标记而言：")]),a._v(" "),t("ul",[t("li",[a._v("[bottom, prevTAMS): 这部分里的对象存活信息可以通过prevBitmap来得知")]),a._v(" "),t("li",[a._v("[prevTAMS, nextTAMS): 这部分里的对象在第n-1轮concurrent marking是隐式存活的")]),a._v(" "),t("li",[a._v("[nextTAMS, top): 这部分里的对象在第n轮concurrent marking是隐式存活的")])]),a._v(" "),t("blockquote",[t("p",[a._v("并发标记期间新的对象根本不会被GC，全部认为存活")])]),a._v(" "),t("h4",{attrs:{id:"写前屏障-实现satb🚩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写前屏障-实现satb🚩"}},[a._v("#")]),a._v(" 写前屏障：实现SATB🚩")]),a._v(" "),t("blockquote",[t("p",[a._v("SATB是必须理解的一个非常重要的概念，并发标记解决漏标问题的核心")]),a._v(" "),t("p",[a._v("不懂SATB，就不懂为什么全局并发标记的step2、3在干嘛，为什么这样实现")])]),a._v(" "),t("p",[a._v("G1收集器会通过写前屏障，在"),t("strong",[a._v("引用被更改前先记录一下原本的引用信息")]),a._v("。这样"),t("strong",[a._v("G1始终持有并发标记开始之前的对象图")]),a._v("。这不就是快照snapshot at the beginning吗。这样就解决了漏标问题。")]),a._v(" "),t("h5",{attrs:{id:"写前屏障具体行为"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写前屏障具体行为"}},[a._v("#")]),a._v(" 写前屏障具体行为")]),a._v(" "),t("blockquote",[t("p",[a._v("许多论文提到的mutator，可以简单理解为用户线程。")]),a._v(" "),t("p",[a._v("mutator的写前栅栏会在引用变更前，将值记录在SATB日缓冲区中。每个线程都会独占一个SATB缓冲区（SATBMarkQueue）。当SATBMarkQueue放满了，会放到全局的SATBMarkQueueSet。")]),a._v(" "),t("p",[a._v("在并发标记阶段，还会定期检查和处理SATBMarkQueueSet的记录，重新标记为灰色压入扫描栈。")]),a._v(" "),t("p",[a._v("并发标记阶段结束剩余的未处理的SATBMarkQueue，SATBMarkQueueSet，在最终标记处理")])]),a._v(" "),t("h3",{attrs:{id:"rset-g1对记忆集的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rset-g1对记忆集的实现"}},[a._v("#")]),a._v(" RSet：G1对记忆集的实现")]),a._v(" "),t("blockquote",[t("p",[a._v("Remembered Set是记忆集，是个抽象的概念。RSet是G1对Remembered Set的实现，不是一个东西。")])]),a._v(" "),t("p",[a._v("G1与HotSpot VM的其它GC一样有一个"),t("strong",[a._v("覆盖整个heap的card table")]),a._v("。")]),a._v(" "),t("p",[a._v("而G1在points-out的card table之上再加了一层结构来构成points-into RSet。")]),a._v(" "),t("p",[a._v("每个region（分区）都有一个Rset，记录"),t("strong",[a._v("其它属于老年代的 Region 的card对当前Region 的card 的引用情况")]),a._v("。也就是记录"),t("strong",[a._v("谁的指针指向我，或者谁引用了我的对象")]),a._v("。这和Card Table是刚好相反的。而这些新生代的card可以作为Young GC的GC roots。")]),a._v(" "),t("blockquote",[t("p",[a._v("即便当前Region属于老年代，也会维护RSet，减压MixedGC")])]),a._v(" "),t("h4",{attrs:{id:"rset的内部结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rset的内部结构"}},[a._v("#")]),a._v(" RSet的内部结构")]),a._v(" "),t("p",[t("code",[a._v("RSet")]),a._v("本质上就是一个哈希表结构（"),t("code",[a._v("HashTable")]),a._v("），"),t("code",[a._v("Key")]),a._v("为其他引用当前区内对象的"),t("code",[a._v("Region")]),a._v("起始地址，"),t("code",[a._v("Value")]),a._v("则是一个集合，里面的元素为其他"),t("code",[a._v("Region")]),a._v("中每个引用当前区内对象的地址。")]),a._v(" "),t("blockquote",[t("p",[a._v("实际上G1中的"),t("code",[a._v("RSet")]),a._v("对内存的开销也并不小，当JVM中分区较多且运行时间较长的情况下，这块的内存开销可能会"),t("strong",[a._v("占用到"),t("code",[a._v("20%")]),a._v("以上")]),a._v("。")]),a._v(" "),t("p",[a._v("引自："),t("a",{attrs:{href:"https://juejin.cn/post/7080030329922125854#heading-11",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://juejin.cn/post/7080030329922125854#heading-11"),t("OutboundLink")],1)])]),a._v(" "),t("h4",{attrs:{id:"写后屏障-维护rset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写后屏障-维护rset"}},[a._v("#")]),a._v(" 写后屏障：维护Rset")]),a._v(" "),t("p",[a._v("在对引用做修改的时候，去修改对应的RSet。这个过程与SATB十分相似。另外，G1还有card table需要维护。")]),a._v(" "),t("p",[a._v("mutator把引用记录到dirty card queue，DirtyCardQueueSet，通过ConcurrentG1RefineThread并发维护RSet")]),a._v(" "),t("p",[a._v("比如：")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" listnode  l "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" listnode p "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("listnode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v(" l "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br")])]),t("p",[a._v("每个线程有自己的log buffer，写屏障的记录先放进去自己的log buffer中，装满了之后，就会把log buffer放到全局long buffer "),t("code",[a._v("global set of filled buffer")]),a._v("中，而后再申请一个log buffer。")]),a._v(" "),t("blockquote",[t("p",[a._v("G1只有两件事情是并发的，一是屏障缓存区的并发处理，二是并发标记")])]),a._v(" "),t("h4",{attrs:{id:"cset-gc区域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cset-gc区域"}},[a._v("#")]),a._v(" CSet：GC区域")]),a._v(" "),t("blockquote",[t("p",[a._v("CSet虽然是个很简单易懂的概念，但却是很重要的概念")])]),a._v(" "),t("p",[a._v("Collect Set用于描述：一次GC的区域，是一个由若干region构成的集合")]),a._v(" "),t("p",[a._v("一次GC后，CSet的所有region资源会被释放，成为闲置的Region，所有存活的对象会被放到别的Region")]),a._v(" "),t("p",[a._v("扫描任何region的时候如果碰到指向不在CSet里的region的引用都可以忽略，即我们只关注从非CSet到Cset的引用，而忽略所有Cset到非CSet的引用。")]),a._v(" "),t("h4",{attrs:{id:"gc工作线程数量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc工作线程数量"}},[a._v("#")]),a._v(" GC工作线程数量")]),a._v(" "),t("p",[a._v("由"),t("code",[a._v("-XX:ParallelGCThreads")]),a._v("参数指定")]),a._v(" "),t("p",[a._v("默认值为：")]),a._v(" "),t("ul",[t("li",[a._v("当CPU核数小于等于8，则默认与CPU核数相等")]),a._v(" "),t("li",[a._v("当CPU核数大于8，经过计算得到，一般小于CPU核数")])]),a._v(" "),t("h2",{attrs:{id:"整体看g1的gc行为"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#整体看g1的gc行为"}},[a._v("#")]),a._v(" 整体看G1的GC行为")]),a._v(" "),t("p",[a._v("从最高层看，G1的collector一侧其实就是两个大部分：")]),a._v(" "),t("ul",[t("li",[a._v("全局并发标记（global concurrent marking）")]),a._v(" "),t("li",[a._v("拷贝存活对象（evacuation）")])]),a._v(" "),t("p",[t("strong",[a._v("全局并发标记和拷贝存活对象可以彼此独立运行")])]),a._v(" "),t("h2",{attrs:{id:"一、全局并发标记-global-concurrent-marking"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、全局并发标记-global-concurrent-marking"}},[a._v("#")]),a._v(" 一、全局并发标记：global concurrent marking")]),a._v(" "),t("p",[a._v("全局并发标记：global concurrent marking，是基于SATB形式的并发标记。")]),a._v(" "),t("blockquote",[t("p",[a._v("全局并发标记整个过程只有并发标记可能被Young GC打断。")]),a._v(" "),t("p",[a._v("在JDK12前，MixedGC也是不允许被打断的。后来MixedGC能被打断。")])]),a._v(" "),t("h4",{attrs:{id:"_1、初始标记-initial-marking"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、初始标记-initial-marking"}},[a._v("#")]),a._v(" 1、初始标记："),t("strong",[a._v("initial marking")])]),a._v(" "),t("p",[a._v("STW。")]),a._v(" "),t("p",[a._v("找到GC Roots，把roots引用的对象压入扫描栈（灰色）。")]),a._v(" "),t("p",[a._v("这个过程是等Young GC触发时借道的。")]),a._v(" "),t("h5",{attrs:{id:"根分区扫描-root-region-scanning"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#根分区扫描-root-region-scanning"}},[a._v("#")]),a._v(" 根分区扫描 Root Region Scanning")]),a._v(" "),t("p",[t("strong",[a._v("根分区")]),a._v("：Young GC期间，没有死亡的年轻代，晋升到的所有Survivor区域")]),a._v(" "),t("p",[a._v("由于初始标记是借道的，也就是此时Eden为空，年轻代存活的对象全部为存活对象，因此需要将这块区域的所有对象标记为GC Roots。")]),a._v(" "),t("h4",{attrs:{id:"_2、并发标记-concurrent-marking"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、并发标记-concurrent-marking"}},[a._v("#")]),a._v(" 2、"),t("strong",[a._v("并发标记")]),a._v("：concurrent marking")]),a._v(" "),t("p",[a._v("并发标记算法的实现就是三色标记法，所以就是递归扫描直至扫描栈为空")]),a._v(" "),t("blockquote",[t("p",[a._v("过程中还会扫描SATB write barrier所记录的引用，就是将黑色变成灰色的对象重新压入扫描栈")])]),a._v(" "),t("h5",{attrs:{id:"并发标记的线程数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发标记的线程数"}},[a._v("#")]),a._v(" 并发标记的线程数")]),a._v(" "),t("p",[t("code",[a._v("-XX:ConcGCThreads")]),a._v("：默认为GC线程数的1/4，即"),t("code",[a._v("-XX:ParallelGCThreads/4")]),a._v("，一次只扫描一个分区")]),a._v(" "),t("p",[t("code",[a._v("-XX:ParallelGCThreads")]),a._v("：见「GC工作线程数量」")]),a._v(" "),t("h4",{attrs:{id:"_3、最终-重新标记-remark-final-mark"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、最终-重新标记-remark-final-mark"}},[a._v("#")]),a._v(" 3、"),t("strong",[a._v("最终/重新标记")]),a._v("：remark/final mark")]),a._v(" "),t("p",[a._v("STW。")]),a._v(" "),t("p",[a._v("处理剩下的SATB write barrier记录的引用（详见『SATB的实现：写前屏障』）。也进行弱引用处理")]),a._v(" "),t("blockquote",[t("p",[a._v("CMS 的remark非常慢。CMS的remark需要重新扫描mod-union table里的dirty card外加整个根集合，而此时整个young gen（不管对象死活）都会被当作根集合的一部分")])]),a._v(" "),t("h4",{attrs:{id:"_4、清理-clean"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、清理-clean"}},[a._v("#")]),a._v(" 4、清理：clean")]),a._v(" "),t("p",[a._v("STW。")]),a._v(" "),t("p",[a._v("清点和重置标记状态。这个阶段不拷贝任何对象")]),a._v(" "),t("h2",{attrs:{id:"二、拷贝存活对象-evacuation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、拷贝存活对象-evacuation"}},[a._v("#")]),a._v(" 二、拷贝存活对象：Evacuation")]),a._v(" "),t("p",[a._v("Evacuation阶段是"),t("strong",[a._v("全暂停")]),a._v("的。")]),a._v(" "),t("h4",{attrs:{id:"_1、确定cset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、确定cset"}},[a._v("#")]),a._v(" 1、确定CSet")]),a._v(" "),t("p",[a._v("Evacuation阶段可以「自由选择任意多个region」"),t("strong",[a._v("来独立收集构成收集集合，而这依赖")]),a._v("「RSet」实现")]),a._v(" "),t("blockquote",[t("p",[a._v("被选择的这些Region就叫做CSet")]),a._v(" "),t("p",[a._v("RSet还记得么，是实现Partial GC的核心机制")])]),a._v(" "),t("h4",{attrs:{id:"_2、可能的标记行为"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、可能的标记行为"}},[a._v("#")]),a._v(" 2、可能的标记行为")]),a._v(" "),t("p",[a._v("前文说过evacuation与global concurrent marking是可以彼此独立工作的。")]),a._v(" "),t("p",[a._v("因此："),t("strong",[a._v("Evacuation也需要能够扫描标记存活对象")])]),a._v(" "),t("p",[a._v("实际上，标记过程不一定会有。")]),a._v(" "),t("ul",[t("li",[a._v("如果有global concurrent marking的结果，那就直接拿来用")]),a._v(" "),t("li",[a._v("如果没有，也无所谓，Evacuation自己也能扫描出来")])]),a._v(" "),t("h4",{attrs:{id:"_3、拷贝存活对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、拷贝存活对象"}},[a._v("#")]),a._v(" 3、拷贝存活对象")]),a._v(" "),t("p",[a._v("evacuation把一部分region里的活对象拷贝到空region里去，然后回收原本的region的空间。")]),a._v(" "),t("blockquote",[t("p",[a._v("具体的拷贝行为：")]),a._v(" "),t("p",[a._v("跟ParallelScavenge的young GC的算法类似，采用并行copying（或者叫scavenging）算法把CSet里每个region里的活对象拷贝到新的region里，整个过程完全暂停。是多线程并行拷贝。")]),a._v(" "),t("p",[a._v("能不能并发拷贝（concurrent compaction拷贝行为与用户线程同时进行）")]),a._v(" "),t("p",[a._v("不能，已知的实现concurrent compaction的GC算法都需要read barrier，而G1则坚持只用write barrier不用read barrie。")])]),a._v(" "),t("h2",{attrs:{id:"xxxgc与evacuation和marking的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#xxxgc与evacuation和marking的关系"}},[a._v("#")]),a._v(" xxxGC与Evacuation和marking的关系")]),a._v(" "),t("p",[a._v("这里指Young GC和Mixed GC。")]),a._v(" "),t("blockquote",[t("p",[a._v("R大原话是：")]),a._v(" "),t("p",[a._v("分代式G1模式下有两种选定CSet的子模式，分别对应young GC与mixed GC")])]),a._v(" "),t("p",[a._v("更确切的说，"),t("strong",[a._v("Young GC和Mixed GC都是Evacuation的一种，它们的区别仅仅是选定的CSet不同")]),a._v("。")]),a._v(" "),t("p",[a._v("它们的具体选定CSet的规则是：")]),a._v(" "),t("ul",[t("li",[a._v("Young GC：选定所有young gen里的region。通过控制young gen的region个数来控制young GC的开销。")]),a._v(" "),t("li",[a._v("Mixed GC：选定所有young gen里的region，外加根据global concurrent marking统计得出收集收益高的若干old gen region。在用户指定的开销目标范围内尽可能选择收益高的old gen region。")])]),a._v(" "),t("p",[a._v("你想想，"),t("strong",[a._v("选定CSet属于哪个部分")]),a._v("？属于Evacuation行为的第一步。这也就是为什么很多讲G1的作者常说：")]),a._v(" "),t("blockquote",[t("p",[a._v("G1的Mixed GC与Young GC的行为几乎完全一样")])]),a._v(" "),t("p",[a._v("看到这里，你应该知道为什么这么说了吧。还不知道就再看一遍。")]),a._v(" "),t("p",[a._v("Young GC和Mixed GC 都是STW的，对吗")]),a._v(" "),t("p",[a._v("对的。它们是Evacuation的一种，而Evacuation是STW的。")]),a._v(" "),t("blockquote",[t("p",[a._v("global concurrent marking对mixed gc中的old gen gc有帮助，与young gc没多大关系")])]),a._v(" "),t("p",[a._v("全局并发标记与Mixed GC是互斥的（不会同时进行）")]),a._v(" "),t("p",[a._v("Initial marking默认搭在young GC上执行；当全局并发标记正在工作时，G1不会选择做mixed GC，反之如果有mixed GC正在进行中G1也不会启动initial marking。")]),a._v(" "),t("blockquote",[t("p",[a._v("JDK12推出了可中断的Mixed GC")])]),a._v(" "),t("h2",{attrs:{id:"g1工作周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#g1工作周期"}},[a._v("#")]),a._v(" G1工作周期")]),a._v(" "),t("p",[a._v("这应该能帮助你更好的理解G1的行为模式")]),a._v(" "),t("p",[a._v("一个假想的混合的STW时间线：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("1  启动程序 \n2  -> young GC \n3  -> young GC \n4  -> young GC \n5  -> young GC + initial marking 初始标记\n6  (... concurrent marking ...) 并发标记\n7  -> young GC (... concurrent marking ...) \n8  (... concurrent marking ...) \n9  -> young GC (... concurrent marking ...) \n10 -> final marking  最终标记\n11 -> cleanup 清理\n12 -> mixed GC \n13 -> mixed GC \n14 -> mixed GC \n15 ... \n16 -> mixed GC \n17 -> young GC + initial marking \n18 (... concurrent marking ...) \n19 ...\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br"),t("span",{staticClass:"line-number"},[a._v("15")]),t("br"),t("span",{staticClass:"line-number"},[a._v("16")]),t("br"),t("span",{staticClass:"line-number"},[a._v("17")]),t("br"),t("span",{staticClass:"line-number"},[a._v("18")]),t("br"),t("span",{staticClass:"line-number"},[a._v("19")]),t("br")])]),t("h2",{attrs:{id:"g1的三种gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#g1的三种gc"}},[a._v("#")]),a._v(" G1的三种GC")]),a._v(" "),t("p",[a._v("G1的GC主要是YoungGC和MixedGC，G1追求尽量避免Full GC")]),a._v(" "),t("p",[a._v("G1的收集都是根据CSet进行操作的，YoungGC与MixedGC没有明显的不同，最大的区别在于两种收集的触发条件")]),a._v(" "),t("h3",{attrs:{id:"_1、young-minorgc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、young-minorgc"}},[a._v("#")]),a._v(" 1、Young/MinorGC")]),a._v(" "),t("h4",{attrs:{id:"触发时机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#触发时机"}},[a._v("#")]),a._v(" 触发时机")]),a._v(" "),t("p",[t("strong",[a._v("YoungGC并不是说现有的Eden区放满了就会马上触发")]),a._v("，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 "),t("code",[a._v("-XX:MaxGCPauseMills")]),a._v(" 设定的值（默认200ms），那么"),t("strong",[a._v("增加年轻代的region，继续给新对象存放")]),a._v("，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC。")]),a._v(" "),t("p",[a._v("即："),t("strong",[a._v("当Eden区放满时，预计一次Young GC时间接近200ms，才触发Young GC，否则分配一个新Region给Eden")])]),a._v(" "),t("p",[a._v("但是，如果YoungGC发现当前正在进行XXX，并不会触发。")]),a._v(" "),t("h4",{attrs:{id:"gc区域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc区域"}},[a._v("#")]),a._v(" GC区域")]),a._v(" "),t("p",[a._v("只对新生代的区域做GC")]),a._v(" "),t("h4",{attrs:{id:"younggc的行为"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#younggc的行为"}},[a._v("#")]),a._v(" YoungGC的行为")]),a._v(" "),t("p",[a._v("见Evacuation。")]),a._v(" "),t("p",[a._v("通过控制young gen的region个数来控制young GC的开销。")]),a._v(" "),t("h4",{attrs:{id:"young-gc和全局并发标记有没有关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#young-gc和全局并发标记有没有关系"}},[a._v("#")]),a._v(" Young GC和全局并发标记有没有关系")]),a._v(" "),t("p",[a._v("没有什么关系。")]),a._v(" "),t("p",[a._v("从Evacuation的角度看，全局并发标记的结果是可有可无的。")]),a._v(" "),t("p",[a._v("从GC的角度看，Young GC不依赖全局并发标记，而Mixed GC通常需要全局并发标记的结果。")]),a._v(" "),t("h3",{attrs:{id:"_2、mixedgc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、mixedgc"}},[a._v("#")]),a._v(" 2、MixedGC")]),a._v(" "),t("h4",{attrs:{id:"触发时机-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#触发时机-2"}},[a._v("#")]),a._v(" 触发时机")]),a._v(" "),t("p",[a._v("『老年代/整个堆的百分比』达到 IHOP ("),t("code",[a._v("-XX:InitiatingHeapOccupancyPercent")]),a._v(")阈值，并且发生Young GC")]),a._v(" "),t("blockquote",[t("p",[a._v("当达到 IHOP 阈值时，"),t("strong",[a._v("G1并不会立即发起并发标记周期，而是等待下一次年轻代收集，利用年轻代收集的STW时间段，完成初始标记")]),a._v("，这种方式称为借道。")])]),a._v(" "),t("p",[a._v("注意："),t("strong",[a._v("达到 IHOP阈值触发的是『全局并发标记』，全局并发标记结束后才会Mixed GC")])]),a._v(" "),t("p",[a._v("『全局并发标记』后，仍然不会立刻开始Mixed GC。")]),a._v(" "),t("blockquote",[t("p",[a._v("随后G1并不会马上开始一次混合收集，而是让应用线程先运行一段时间，等待触发一次年轻代收集。在这次STW中，G1将保准整理混合收集周期。接着再次让应用线程运行，当"),t("strong",[a._v("接下来的几次年轻代收集时，将会有老年代分区加入到CSet中，即触发混合收集")]),a._v("，这些连续多次的混合收集称为混合收集周期(Mixed Collection Cycle)。")]),a._v(" "),t("p",[a._v("引用自："),t("a",{attrs:{href:"https://pdai.tech/md/java/jvm/java-jvm-gc-g1.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://pdai.tech/md/java/jvm/java-jvm-gc-g1.html"),t("OutboundLink")],1)])]),a._v(" "),t("p",[a._v("所以Mixed GC仍然依托于Young GC，然后修改它的CSet。")]),a._v(" "),t("p",[a._v("因此Mixed GC的真正触发时机是：")]),a._v(" "),t("ul",[t("li",[a._v("经历过『全局并发标记』，有老年代的区域需要GC")]),a._v(" "),t("li",[a._v("第一次触发Young GC，做choose CSet的操作")]),a._v(" "),t("li",[a._v("并且仍有老年代的区域没来得及GC")]),a._v(" "),t("li",[a._v("并且触发后续的Young GC时，通过修改它的CSet使Young GC变成Mixed GC。")])]),a._v(" "),t("h4",{attrs:{id:"gc区域-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc区域-2"}},[a._v("#")]),a._v(" GC区域")]),a._v(" "),t("p",[a._v("整个新生代和部分老年代，取决于你期望G1暂停的时间，和GC一个Region的价值")]),a._v(" "),t("h4",{attrs:{id:"mixedgc的行为"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mixedgc的行为"}},[a._v("#")]),a._v(" MixedGC的行为")]),a._v(" "),t("p",[a._v("见Evacuation。")]),a._v(" "),t("p",[a._v("选定所有young gen里的region，外加根据global concurrent marking统计得出收集收益高的若干old gen region。")]),a._v(" "),t("p",[a._v("因为每次GC的暂停时间由"),t("code",[a._v("-XX:MaxGCPauseMills")]),a._v(" 控制，因此一次MixedGC未必能回收一次global concurrent marking所标记出的CSet。因此G1可能会产生连续多次的混合收集与应用线程交替执行。")]),a._v(" "),t("p",[a._v("这就解释了『G1工作周期』的12~16行出现的多次Mixed GC")]),a._v(" "),t("h4",{attrs:{id:"g1的担保机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#g1的担保机制"}},[a._v("#")]),a._v(" G1的担保机制")]),a._v(" "),t("p",[a._v("在GC时先将要回收的"),t("code",[a._v("Region")]),a._v("区中存活的对象拷贝至别的"),t("code",[a._v("Region")]),a._v("区内，拷贝过程中，如果发现没有足够多的空闲"),t("code",[a._v("Region")]),a._v("区承载拷贝对象，此时就会触发一次"),t("code",[a._v("Full GC")]),a._v("。")]),a._v(" "),t("h3",{attrs:{id:"_3、full-gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、full-gc"}},[a._v("#")]),a._v(" 3、Full GC")]),a._v(" "),t("p",[t("strong",[a._v("无法在堆空间中申请新的分区")]),a._v("时，G1便会触发担保机制，执行一次STW式的、单线程的 Full GC。Full GC的收集代价非常昂贵，应该避免Full GC的发生。")]),a._v(" "),t("blockquote",[t("p",[a._v("G1的设计理念是尽量避免Full GC的发生")])]),a._v(" "),t("h4",{attrs:{id:"触发时机-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#触发时机-3"}},[a._v("#")]),a._v(" 触发时机")]),a._v(" "),t("p",[a._v("触发full GC的场景：")]),a._v(" "),t("ul",[t("li",[a._v("从年轻代分区拷贝存活对象时，无法找到可用的空闲分区")]),a._v(" "),t("li",[a._v("从老年代分区转移存活对象时，无法找到可用的空闲分区")]),a._v(" "),t("li",[a._v("分配巨型对象时在老年代无法找到足够的连续分区")])]),a._v(" "),t("h4",{attrs:{id:"gc区域-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc区域-3"}},[a._v("#")]),a._v(" GC区域")]),a._v(" "),t("p",[a._v("当然是全部，包括元空间，大对象区域等。")]),a._v(" "),t("h4",{attrs:{id:"fullgc的行为"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fullgc的行为"}},[a._v("#")]),a._v(" FullGC的行为")]),a._v(" "),t("p",[a._v("JDK10之前，G1中的FullGC是采用"),t("strong",[a._v("serial old FullGC")]),a._v("。")]),a._v(" "),t("p",[a._v("JDK10及之后，采用了并发式的。")]),a._v(" "),t("h2",{attrs:{id:"g1重要配置参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#g1重要配置参数"}},[a._v("#")]),a._v(" G1重要配置参数")]),a._v(" "),t("p",[a._v("-XX:MaxGCPauseMillis：一般的期望的最大STW时间，默认值：200ms")]),a._v(" "),t("p",[a._v("-XX:GCPauseTimeInterval：严格的必须的最大STW时间，默认值：没有，即允许极端情况下G1 STW很久")]),a._v(" "),t("p",[a._v("-XX:ParallelGCThreads："),t("strong",[a._v("并行")]),a._v("工作最大线程数，默认值比较复杂，见『GC线程数量』")]),a._v(" "),t("p",[a._v("-XX:ConcGCThreads："),t("strong",[a._v("并发")]),a._v("工作最大线程数，默认值"),t("code",[a._v("-XX:ParallelGCThreads")]),a._v("除以4")]),a._v(" "),t("blockquote",[t("p",[a._v("Parallel并行线程数：STW时并行工作的线程数量")]),a._v(" "),t("p",[a._v("Conc并发线程数：并发标记（全局并发标记的第二步）时的工作线程数量")])]),a._v(" "),t("p",[a._v("-XX:G1HeapRegionSize：每个Region的大小")]),a._v(" "),t("p",[a._v("-XX:G1(Max)NewSizePercent：初始（最大）新生代占堆内存的占比")]),a._v(" "),t("p",[a._v("-XX:G1HeapWastePercent：回收Region的「值得回收部分的」阈值，CSet的某个Region的可回收的内存占整堆超过该值才可能被GC，默认值为5%")]),a._v(" "),t("h4",{attrs:{id:"参考文献"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[a._v("#")]),a._v(" 参考文献")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://www.pdai.tech/md/java/jvm/java-jvm-gc-g1.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("pdai.tech.GC - Java 垃圾回收器之G1详解"),t("OutboundLink")],1)]),a._v(" "),t("p",[t("a",{attrs:{href:"https://juejin.cn/column/7057537880624726053",target:"_blank",rel:"noopener noreferrer"}},[a._v("JVM成神路 - 竹子爱熊猫"),t("OutboundLink")],1)]),a._v(" "),t("p",[t("a",{attrs:{href:"https://hllvm-group.iteye.com/group/topic/44381#post-272188",target:"_blank",rel:"noopener noreferrer"}},[a._v("R大关于G1的答疑帖"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);