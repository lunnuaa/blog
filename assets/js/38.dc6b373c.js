(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{310:function(t,a,s){t.exports=s.p+"assets/img/image-20230907105246018.e5defbb6.png"},378:function(t,a,s){"use strict";s.r(a);var n=s(14),e=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"volatile-关键字详解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile-关键字详解"}},[t._v("#")]),t._v(" volatile 关键字详解")]),t._v(" "),a("p",[t._v("并发三要素是：可见性，有序性，原子性。")]),t._v(" "),a("p",[t._v("而实际上，Java 提供的关键字的功能往往是复合的。 volatile 的功能就是复合的，不仅仅保证了字段的可见性，也保证了"),a("strong",[t._v("单次")]),t._v("的读/写的原子性，也一定程度上限制了重排序而保证有序性。")]),t._v(" "),a("h2",{attrs:{id:"volatile-的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile-的作用"}},[t._v("#")]),t._v(" volatile 的作用")]),t._v(" "),a("p",[t._v("volatile的作用主要有如下几点：")]),t._v(" "),a("h3",{attrs:{id:"_1、可见性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、可见性"}},[t._v("#")]),t._v(" 1、可见性")]),t._v(" "),a("p",[t._v("保证变量的"),a("strong",[t._v("内存可见性")]),t._v("。即读到的数据都是最新的。")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("volatile 修饰对象和数组(引用)时，只是保证其引用地址的可见性")])])]),t._v(" "),a("h3",{attrs:{id:"_2、限制重排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、限制重排序"}},[t._v("#")]),t._v(" 2、限制重排序")]),t._v(" "),a("p",[t._v("严格限制编译器和处理器对volatile变量与volatile变量，volatile变量与普通变量的重排序。")]),t._v(" "),a("p",[t._v("我们知道"),a("strong",[t._v("volatile写 h-b volatile读")]),t._v("，因此很容易理解，实现这个h-b需要禁止重排序，而实现禁止重排序具体又通过内存屏障来实现。")]),t._v(" "),a("p",[t._v("但在JSR-133之后，另外限制了volatile变量与普通变量的重排序，具体原因见后文。")]),t._v(" "),a("h3",{attrs:{id:"_3、单次读写的原子性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、单次读写的原子性"}},[t._v("#")]),t._v(" 3、单次读写的原子性")]),t._v(" "),a("p",[t._v("需要强调一下，是单次的读与写。")]),t._v(" "),a("p",[t._v("因为 Java 规范并不保证对64位的 long，double 的读写的原子性，可能会拆成两次32位的操作，但用 volatile 修饰，即使是64位的数据类型，同样可以保证原子性。当然 i++ 这样的复合操作无法保证。")]),t._v(" "),a("blockquote",[a("p",[t._v("另一种理解是，对于volatile修饰的变量，在读和写操作时，都会加锁，而锁有happens before原则。")]),t._v(" "),a("p",[t._v("意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。")]),t._v(" "),a("p",[t._v("单单是读写操作，可以保证原子性，但是复合操作，i++，是读了再写，这就没有原子性了")])]),t._v(" "),a("h2",{attrs:{id:"volatile-的内存语义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile-的内存语义"}},[t._v("#")]),t._v(" volatile 的内存语义")]),t._v(" "),a("p",[t._v("内存语义指的是: 在多线程或处理器中用来控制存取共享内存位置,或者说是在更高层次上共享变量的处理逻辑。")]),t._v(" "),a("p",[t._v("此处我们不考虑JSR-133对volatile的内存语义加强，会在后文分析。")]),t._v(" "),a("ul",[a("li",[t._v("当一个线程对"),a("code",[t._v("volatile")]),t._v("修饰的变量进行"),a("strong",[t._v("写操作")]),t._v("时，JMM会立即把该线程对应的本地内存中的共享变量的值刷新到主内存；")]),t._v(" "),a("li",[t._v("当一个线程对"),a("code",[t._v("volatile")]),t._v("修饰的变量进行"),a("strong",[t._v("读操作")]),t._v("时，JMM会把立即该线程对应的本地内存置为无效，从主内存中读取共享变量的值。")])]),t._v(" "),a("h3",{attrs:{id:"volatile-限制重排序的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile-限制重排序的实现原理"}},[t._v("#")]),t._v(" volatile 限制重排序的实现原理")]),t._v(" "),a("ul",[a("li",[t._v("在每个volatile写操作前插入一个StoreStore屏障；")]),t._v(" "),a("li",[t._v("在每个volatile写操作后插入一个StoreLoad屏障；")]),t._v(" "),a("li",[t._v("在每个volatile读操作后插入一个LoadLoad屏障；")]),t._v(" "),a("li",[t._v("在每个volatile读操作后再插入一个LoadStore屏障。")])]),t._v(" "),a("p",[t._v("总之规则如下：")]),t._v(" "),a("ul",[a("li",[t._v("如果第一个操作是volatile读，那无论第二个操作是什么，都不能重排序；")]),t._v(" "),a("li",[t._v("如果第二个操作是volatile写，那无论第一个操作是什么，都不能重排序；")]),t._v(" "),a("li",[t._v("如果第一个操作是volatile写，第二个操作是volatile读，不能重排序。")])]),t._v(" "),a("p",[a("img",{attrs:{src:s(310),alt:"image-20230907105246018"}})]),t._v(" "),a("h2",{attrs:{id:"volatile-的典型应用场景-单例模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile-的典型应用场景-单例模式"}},[t._v("#")]),t._v(" volatile 的典型应用场景：单例模式")]),t._v(" "),a("p",[t._v("单例模式的对象，可以被volatile修饰从而避免重排序。")]),t._v(" "),a("p",[t._v("下面给出懒汉式单例模式的代码：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" singleton"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getInstance")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("singleton "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("singleton "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n                    singleton "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" singleton"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br")])]),a("p",[t._v("new对象的过程中，「初始化实例对象」 与 「将singleton指针指向该对象」可能被重排序。正因为这个重排序，另一个线程执行getInstance方法时，会返回一个未完成初始化的对象。而加volatile就能解决这个问题。volatile严格限制了对volatile域的写和对普通域的读写的重排序，因此volatile能保证这两个步骤不进行重排序。")]),t._v(" "),a("h2",{attrs:{id:"jsr-133-额外的重排序限制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsr-133-额外的重排序限制"}},[t._v("#")]),t._v(" JSR-133：额外的重排序限制")]),t._v(" "),a("p",[t._v("JSR-133 提出禁止 「volatile 的读写」与「普通变量的读写」重排序")]),t._v(" "),a("p",[t._v("这种额外的限制是为了提供一种"),a("strong",[t._v("比锁更轻量级的线程之间通信的机制")]),t._v("。通过增强 volatile 的内存语义，使得"),a("strong",[t._v("对volatile的写-读 和 锁(synchronized)的释放-获取 具有相同的内存语义")]),t._v("。")]),t._v(" "),a("p",[t._v("在功能上，锁比 volatile 更强大；在性能上，volatile 更有优势。原因是 volatile 仅仅保证对单个 volatile 变量的读/写具有原子性，而锁可以保证整个"),a("strong",[t._v("临界区代码")]),t._v("的执行具有原子性。")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("临界区")]),t._v("：指的是某一块代码区域，它同一时刻只能由一个线程执行。")])])])}),[],!1,null,null,null);a.default=e.exports}}]);