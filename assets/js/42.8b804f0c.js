(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{314:function(s,a,t){s.exports=t.p+"assets/img/8aa80065c26e4a0b9923ee32f0f67beatplv-k3u1fbpfcp-jj-mark0000q75.3fe50d58.png"},390:function(s,a,t){"use strict";t.r(a);var n=t(14),v=Object(n.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"深入理解类加载系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深入理解类加载系统"}},[s._v("#")]),s._v(" 深入理解类加载系统")]),s._v(" "),a("p",[s._v("类的加载，是生成class对象的过程。将"),a("code",[s._v("class")]),s._v("字节码信息加载进内存。类加载机制只负责"),a("code",[s._v("class")]),s._v("文件的加载，至于是否可以执行，则是由执行引擎决定。")]),s._v(" "),a("h2",{attrs:{id:"类加载流程-重要"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类加载流程-重要"}},[s._v("#")]),s._v(" 类加载流程（重要）")]),s._v(" "),a("p",[s._v("从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中"),a("strong",[s._v("验证，准备，解析三个部分统称为连接")]),s._v("。")]),s._v(" "),a("h4",{attrs:{id:"_1、加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、加载"}},[s._v("#")]),s._v(" 1、加载")]),s._v(" "),a("p",[s._v("类加载过程的第一步，主要完成下面 3 件事情：")]),s._v(" "),a("ol",[a("li",[s._v("通过全限定名获取定义此类的二进制字节流")]),s._v(" "),a("li",[s._v("将字节流所代表的静态存储结构转换为方法区的运行时数据结构")]),s._v(" "),a("li",[s._v("在内存中生成一个代表该类的 "),a("code",[s._v("Class")]),s._v(" 对象，作为方法区这些数据的访问入口")])]),s._v(" "),a("p",[s._v("类的加载依赖于类加载器，后文会详细分析。")]),s._v(" "),a("h4",{attrs:{id:"_2、验证"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、验证"}},[s._v("#")]),s._v(" 2、验证")]),s._v(" "),a("p",[s._v("检验二进制字节流是否符合JVM规范，比如魔数是否正确，版本号是否匹配等等。")]),s._v(" "),a("h4",{attrs:{id:"_3、准备"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、准备"}},[s._v("#")]),s._v(" 3、准备")]),s._v(" "),a("p",[a("strong",[s._v("准备阶段是正式为类变量分配内存并设置类变量初始值的阶段")]),s._v("，这些内存都将在方法区中分配。只分配static修饰的变量的内存空间，且值为默认值，比如"),a("code",[s._v("public static int value = 111")]),s._v("，此时value = 0，也就是赋予数据类型的默认值。")]),s._v(" "),a("blockquote",[a("p",[s._v("在 JDK 7 之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。")])]),s._v(" "),a("p",[s._v("特例："),a("code",[s._v("public static final int value = 111")])]),s._v(" "),a("p",[s._v("因为被final修饰，常量池内有111这个常量，通过属性表的ConstantValue（编译阶段生成），在准备阶段将"),a("code",[s._v("value")]),s._v(" 赋值为111。")]),s._v(" "),a("h4",{attrs:{id:"_4、解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、解析"}},[s._v("#")]),s._v(" 4、解析")]),s._v(" "),a("p",[s._v("解析阶段是虚拟机"),a("strong",[s._v("将常量池内的符号引用替换为直接引用")]),s._v("的过程。")]),s._v(" "),a("blockquote",[a("p",[a("strong",[s._v("符号引用")]),s._v("：就是一组符号来描述目标，可以是任何字面量。")]),s._v(" "),a("p",[a("strong",[s._v("直接引用")]),s._v("：就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。")])]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("符号引用")]),s._v("：符号引用本身可以是任何形式的字面量，它的实现取决于JVM，只要能定位到目标即可。 符号引用的目标"),a("strong",[s._v("不一定被加载到内存中")]),s._v("。")]),s._v(" "),a("li",[a("strong",[s._v("直接引用")]),s._v("：直接指向目标的引用。"),a("strong",[s._v("直接引用的目标一定在内存中存在")]),s._v("。")])]),s._v(" "),a("p",[a("strong",[s._v("解析的时机")])]),s._v(" "),a("p",[s._v("解析并不只出现在类加载过程，有些方法可能是真正被调用时才做解析操作。通常类加载时的解析包括了描述唯一版本的方法的符号引用，比如：final修饰的方法，版本唯一确定，就更适合在类加载阶段直接替换为直接引用。")]),s._v(" "),a("p",[s._v("《Java虚拟机规范》之中并未规定解析阶段发生的具体时间。只要求17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。比如：类加载时解析，或者符号引用将要被用才解析都是可以的。")]),s._v(" "),a("p",[s._v("对同一个符号引用进行多次解析请求是很常见的事情。除invokedynamic指令，其他解析请求的结果都可以被缓存。")]),s._v(" "),a("blockquote",[a("p",[s._v("invokedynamic：用于支持动态绑定")]),s._v(" "),a("p",[s._v("必须等到程序实际运行到这条指令时，解析动作才能进行。相对地，其余可触发解析的指令都是“静态”的")])]),s._v(" "),a("p",[s._v("解析阶段是唯一一个顺序不确定的，在某些情况下解析可以在"),a("strong",[s._v("初始化阶段之后")]),s._v("再开始，从而支持"),a("strong",[s._v("动态绑定")]),s._v("。当然这里的类加载的顺序只是步骤开始的顺序，即可能存在一边加载，一边验证的情况，一个步骤的过程中激活了下一个步骤。")]),s._v(" "),a("h4",{attrs:{id:"_5、初始化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、初始化"}},[s._v("#")]),s._v(" 5、初始化")]),s._v(" "),a("p",[s._v("初始化阶段就是执行：类构造器 "),a("code",[s._v("<clinit> ()")]),s._v("方法的过程，它是Javac编译器的自动生成物")]),s._v(" "),a("p",[s._v("主要是对"),a("code",[s._v("static")]),s._v("修饰的字段进行赋值：")]),s._v(" "),a("ul",[a("li",[s._v("声明类变量是指定初始值")]),s._v(" "),a("li",[s._v("使用静态代码块为类变量指定初始值")])]),s._v(" "),a("p",[s._v("当然如果父类没有被初始化，会先初始化其父类。")]),s._v(" "),a("blockquote",[a("p",[s._v("注意只针对static修饰的类变量。")])]),s._v(" "),a("h4",{attrs:{id:"_6、使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6、使用"}},[s._v("#")]),s._v(" 6、使用")]),s._v(" "),a("p",[s._v("有了class对象，就可以在堆上为这个类分配实例对象，或者调用它的静态方法了。")]),s._v(" "),a("h4",{attrs:{id:"_7、卸载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7、卸载"}},[s._v("#")]),s._v(" 7、卸载")]),s._v(" "),a("p",[s._v("卸载类即该类的 Class 对象被 GC。")]),s._v(" "),a("p",[s._v("卸载类需要满足 3 个要求:")]),s._v(" "),a("ol",[a("li",[s._v("该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。")]),s._v(" "),a("li",[s._v("该类没有在其他任何地方被引用")]),s._v(" "),a("li",[s._v("该类的类加载器的实例已被 GC")])]),s._v(" "),a("p",[s._v("没有实例对象，没有被引用，且类加载器还要被GC，因此类的class对象被GC是一件不太发生的事件。")]),s._v(" "),a("p",[a("strong",[s._v("只有自定义类加载器加载的类才有可能被卸载，JVM三个自带的类加载器加载的Class永远不会被卸载")]),s._v("。")]),s._v(" "),a("h2",{attrs:{id:"类加载器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[s._v("#")]),s._v(" 类加载器")]),s._v(" "),a("p",[s._v("类加载器只用于实现类的加载动作，但却用来标识类的唯一性。")]),s._v(" "),a("p",[a("strong",[s._v("对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在 JVM 中的唯一性")]),s._v("。如果两个类的加载器不同，即使两个类来源于同一个字节码文件，那这两个类就必定不相等。")]),s._v(" "),a("h3",{attrs:{id:"_1、bootstrap-classloader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、bootstrap-classloader"}},[s._v("#")]),s._v(" 1、Bootstrap ClassLoader")]),s._v(" "),a("p",[s._v("引导类加载器，也被叫做启动类加载器或根类加载器。C++实现。")]),s._v(" "),a("p",[a("strong",[s._v("引导类加载器只为JVM提供加载服务，开发者不能直接使用它来加载自己的类")]),s._v("。")]),s._v(" "),a("p",[s._v("负责加载：<JAVA_HOME>/lib目录下并且被虚拟机识别的类库")]),s._v(" "),a("blockquote",[a("p",[s._v("包括：java.util，java.io，java.lang下的类")])]),s._v(" "),a("h3",{attrs:{id:"_2、ext-classloader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、ext-classloader"}},[s._v("#")]),s._v(" 2、Ext ClassLoader")]),s._v(" "),a("p",[s._v("源码在："),a("code",[s._v("sun.misc.Launcher$ExtClassLoader")])]),s._v(" "),a("p",[s._v("加载"),a("code",[s._v("<JAVA_HOME>\\lib\\ext")]),s._v("目录下")]),s._v(" "),a("blockquote",[a("p",[s._v("包括：以javax开头的类，swing系列、内置的js引擎、xml解析器等")])]),s._v(" "),a("h3",{attrs:{id:"_3、app-classloader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、app-classloader"}},[s._v("#")]),s._v(" 3、App ClassLoader")]),s._v(" "),a("p",[s._v("源码在："),a("code",[s._v("sun.misc.Launcher$AppClassLoader")])]),s._v(" "),a("p",[s._v("加载系统类路径"),a("code",[s._v("java -classpath")]),s._v("或"),a("code",[s._v("-D java.class.path")]),s._v("指定路径下的类库")]),s._v(" "),a("blockquote",[a("p",[s._v("我们自己编写的代码以及使用的第三方的jar包都是由它来加载的。")])]),s._v(" "),a("h3",{attrs:{id:"类加载器的加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类加载器的加载"}},[s._v("#")]),s._v(" 类加载器的加载")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("Bootstrap")]),s._v("会负责加载"),a("strong",[s._v("Extension")]),s._v("，并将Extension的父加载器设置为Bootstrap自己。")]),s._v(" "),a("li",[a("strong",[s._v("Bootstrap")]),s._v("随后加载"),a("strong",[s._v("AppClassLoader")]),s._v("，并将AppClassLoader的父加载器设置为Extension。")]),s._v(" "),a("li",[a("strong",[s._v("AppClassLoader")]),s._v("负责加载"),a("strong",[s._v("自定义类加载器")]),s._v("，并将自定义ClassLoader的父加载器设置为AppClassLoader。")])]),s._v(" "),a("p",[s._v("注意：在获取"),a("code",[s._v("ExtClassLoader")]),s._v("的父类加载器时，获取到的结果为null，因为Bootstrap由C++实现。")]),s._v(" "),a("p",[s._v("Class类是按需加载的，使用到才触发加载。")]),s._v(" "),a("h4",{attrs:{id:"命名空间-存储加载的类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命名空间-存储加载的类"}},[s._v("#")]),s._v(" 命名空间：存储加载的类")]),s._v(" "),a("p",[s._v("每个类加载器都拥有一个自己的命名空间，用于"),a("strong",[s._v("存储被自身加载过的所有类的全限定名")]),s._v("。子类加载器可以检查父类加载器中加载的类，通过拿类的全限定名在父类的命名空间内搜索匹配。"),a("strong",[s._v("但父类不可以看子类加载了哪些类")]),s._v("。")]),s._v(" "),a("h4",{attrs:{id:"jvm如何判断两个类是否相同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm如何判断两个类是否相同"}},[s._v("#")]),s._v(" JVM如何判断两个类是否相同")]),s._v(" "),a("p",[s._v("通过"),a("code",[s._v("ClassLoaderId + PackageName + ClassName")]),s._v("进行判断。")]),s._v(" "),a("p",[s._v("这个非常重要，即类加载器的作用不仅仅有加载类，还用于区分类，为我们自定义类加载器的应用场景埋下伏笔。")]),s._v(" "),a("h2",{attrs:{id:"双亲委派机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派机制"}},[s._v("#")]),s._v(" 双亲委派机制")]),s._v(" "),a("p",[a("strong",[s._v("为什么需要双亲委派机制？")])]),s._v(" "),a("p",[s._v("解决类加载器的隔离性问题，保证了 Java 程序的稳定运行")]),s._v(" "),a("p",[s._v("可以"),a("strong",[s._v("避免类的重复加载")]),s._v("（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类）")]),s._v(" "),a("p",[a("strong",[s._v("保证了 Java 的核心 API 不被篡改")]),s._v("。")]),s._v(" "),a("p",[s._v("流程如下图：")]),s._v(" "),a("p",[a("img",{attrs:{src:t(314),alt:"image-20230124112932736.png"}})]),s._v(" "),a("p",[a("strong",[s._v("总结：")])]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("自下而上，检查当前类加载器的命名空间内是否有这个类，即是否类已经被加载过")]),s._v("。")]),s._v(" "),a("li",[a("strong",[s._v("自上而下，尝试加载类；自己加载不了这个类，就交给子类来加载")]),s._v("。")])]),s._v(" "),a("p",[s._v("如果加载失败，抛出"),a("code",[s._v("ClassNotFoundException")]),s._v("异常")]),s._v(" "),a("blockquote",[a("p",[s._v("注意：类加载器的父子关系是优先级，而不是指java继承中的父子关系。")])]),s._v(" "),a("h4",{attrs:{id:"双亲委派的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派的实现原理"}},[s._v("#")]),s._v(" 双亲委派的实现原理")]),s._v(" "),a("p",[s._v("除了Bootstrap其他的所有类加载器都继承自"),a("code",[s._v("ClassLoader")])]),s._v(" "),a("p",[a("code",[s._v("ClassLoader.loadClass")]),s._v("方法，这个方法揭示了"),a("strong",[s._v("双亲委派机制")]),s._v("：")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("protected")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Class")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("loadClass")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("boolean")]),s._v(" resolve"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("throws")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ClassNotFoundException")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("synchronized")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("getClassLoadingLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 从自己的命名空间中查找该Class对象")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Class")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" c "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("findLoadedClass")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("c "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n            "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 自己的命名空间中没找到Class")]),s._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("try")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n                "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("parent "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("!=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n                    "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 父加载器 加载")]),s._v("\n                    c "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" parent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("loadClass")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n                "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("else")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n                    "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// Ext Bootstrap")]),s._v("\n                    c "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("findBootstrapClassOrNull")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n                "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("catch")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ClassNotFoundException")]),s._v(" e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("c "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n                "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// findClass方法在ClassLoader中的处理是直接抛出ClassNotFoundException异常")]),s._v("\n                "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 是可扩展的一个方法 自定义处理")]),s._v("\n                c "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("findClass")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 是否需要解析")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("resolve"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n            "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("resolveClass")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br")])]),a("p",[s._v("而ExtClassLoader没有重写"),a("code",[s._v("loadClass()")]),s._v("方法，AppClassLoader加载器调用父类的"),a("code",[s._v("loadClass()")]),s._v("方法，所以都没有打破双亲委派模型。")]),s._v(" "),a("h4",{attrs:{id:"双亲委派的局限性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派的局限性"}},[s._v("#")]),s._v(" 双亲委派的局限性")]),s._v(" "),a("p",[s._v("虽然避免了类的重复加载，但是当我们对类进行了修改，JVM是无法感知的，因为再次用到这个Class时，发现类加载器的命名空间内有了，就不会再次去尝试加载。此时我们必须重启整个项目。热部署就是解决这个问题的，而它的原理就是通过利用不同的类加载器，去加载更改后的"),a("code",[s._v("class")]),s._v("文件，从而在内存中创建出两个不同的"),a("code",[s._v("Class")]),s._v("对象。从而达到类文件更改后可以生效的目的。")]),s._v(" "),a("h3",{attrs:{id:"参考文档"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文档"}},[s._v("#")]),s._v(" 参考文档")]),s._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6931972267609948167",target:"_blank",rel:"noopener noreferrer"}},[s._v("Java类加载器 — classloader 的原理及应用"),a("OutboundLink")],1)]),s._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/7057538607828959263",target:"_blank",rel:"noopener noreferrer"}},[s._v("JVM成神路之剖析Java类加载子系统、双亲委派机制及线程上下文类加载器"),a("OutboundLink")],1)]),s._v(" "),a("p",[s._v("周志明 《深入理解Java虚拟机 第三版》")])])}),[],!1,null,null,null);a.default=v.exports}}]);