(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{411:function(a,s,e){"use strict";e.r(s);var t=e(14),r=Object(t.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"redis-持久化-rdb-aof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-持久化-rdb-aof"}},[a._v("#")]),a._v(" Redis 持久化：RDB & AOF")]),a._v(" "),s("p",[a._v("Redis 是基于内存的数据库，存在数据丢失的风险。")]),a._v(" "),s("p",[a._v("因此，Redis 提供了三种持久化机制：RDB、AOF 以及 混合持久化。")]),a._v(" "),s("h2",{attrs:{id:"一、rdb-全量快照"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、rdb-全量快照"}},[a._v("#")]),a._v(" 一、RDB：全量快照")]),a._v(" "),s("p",[a._v("RDB，Redis DataBase，快照。RDB是一个二进制文件。")]),a._v(" "),s("h4",{attrs:{id:"禁用rdb-默认开启"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#禁用rdb-默认开启"}},[a._v("#")]),a._v(" 禁用RDB（默认开启）")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v('# 如果是save "" 则表示禁用RDB')]),a._v("\nsave "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('""')]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("h3",{attrs:{id:"rdb触发时机"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rdb触发时机"}},[a._v("#")]),a._v(" RDB触发时机")]),a._v(" "),s("h4",{attrs:{id:"_1、自动触发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、自动触发"}},[a._v("#")]),a._v(" 1、自动触发")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 代表60秒内，如果至少有10000个key被修改，则执行bgsave命令")]),a._v("\nsave "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("60")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10000")]),a._v(" \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 可以设置多个 比如同时存在 save 5 100 满足任意一个条件都会触发")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("p",[a._v("另外，主从同步时也会触发。")]),a._v(" "),s("p",[a._v("当从节点全量复制时，主节点会执行 "),s("code",[a._v("bgsave")]),a._v(" 命令，将 RDB 文件发送给从节点。")]),a._v(" "),s("p",[a._v("Redis正常停机(关机)时也会执行一次RDB。但是突然宕机是来不及执行RDB的。")]),a._v(" "),s("h4",{attrs:{id:"_2、主动触发-save"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、主动触发-save"}},[a._v("#")]),a._v(" 2、主动触发：save")]),a._v(" "),s("p",[a._v("两个命令："),s("code",[a._v("save")]),a._v(" 和 "),s("code",[a._v("bgsave")]),a._v("。save会阻塞Redis，bgsave几乎不会。")]),a._v(" "),s("h3",{attrs:{id:"bgsave实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bgsave实现原理"}},[a._v("#")]),a._v(" bgsave实现原理")]),a._v(" "),s("p",[a._v("开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。")]),a._v(" "),s("h4",{attrs:{id:"几乎不阻塞"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#几乎不阻塞"}},[a._v("#")]),a._v(" 几乎不阻塞")]),a._v(" "),s("p",[a._v("在 fork() 子进程时仍然有短暂的阻塞，不是完全不阻塞。")]),a._v(" "),s("h3",{attrs:{id:"bgsave过程中的写操作-写时复制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bgsave过程中的写操作-写时复制"}},[a._v("#")]),a._v(" bgsave过程中的写操作：写时复制")]),a._v(" "),s("p",[a._v("Redis采用copy-on-write技术：")]),a._v(" "),s("p",[a._v("当主进程执行写操作时，则会拷贝一份数据，执行写操作。这样就不会影响bgsave子进程的快照。")]),a._v(" "),s("h3",{attrs:{id:"写时复制的弊端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#写时复制的弊端"}},[a._v("#")]),a._v(" 写时复制的弊端")]),a._v(" "),s("p",[a._v("写时复制在极端情况下，会占用两倍于Redis内存的物理内存，对于物理内存是一个挑战。")]),a._v(" "),s("p",[a._v("其次，写时复制是会消耗性能的，尤其是开启了「内存大页」的情况。")]),a._v(" "),s("p",[a._v("「内存大页」是指Linux分配一个2MB的内存页，这使得在只修改很少的数据时却不得不复制2MB的大页，因此需要关闭「内存大页机制」")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("echo never >  /sys/kernel/mm/transparent_hugepage/enabled\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("h3",{attrs:{id:"rdb的缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rdb的缺点"}},[a._v("#")]),a._v(" RDB的缺点")]),a._v(" "),s("ol",[s("li",[a._v("RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险(及两者中间宕机了，那么中间的数据都没有了。")]),a._v(" "),s("li",[a._v("fork子进程、压缩、写出RDB文件都比较耗时。如果数据集很大，fork带来的阻塞可能会长达一秒。")])]),a._v(" "),s("h2",{attrs:{id:"二、aof-增量操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、aof-增量操作"}},[a._v("#")]),a._v(" 二、AOF：增量操作")]),a._v(" "),s("p",[a._v("AOF, Append Only File，文件追加")]),a._v(" "),s("p",[a._v("AOF会把 Redis 每个键值对操作都记录到文件（appendonly.aof）中。")]),a._v(" "),s("h4",{attrs:{id:"开启aof-默认关闭"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开启aof-默认关闭"}},[a._v("#")]),a._v(" 开启AOF（默认关闭）")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("appendonly "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("yes")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 是否开启AOF功能，默认是no")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("h3",{attrs:{id:"aof触发时机"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof触发时机"}},[a._v("#")]),a._v(" AOF触发时机")]),a._v(" "),s("p",[a._v("Redis 是先执行命令，把数据写入内存，然后才记录日志")]),a._v(" "),s("h4",{attrs:{id:"_1、自动触发-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、自动触发-2"}},[a._v("#")]),a._v(" 1、自动触发")]),a._v(" "),s("p",[a._v("这里涉及到一个AOF内存缓冲区，在 "),s("code",[a._v("appendfsync everysec")]),a._v(" 策略下是先写入缓冲区，再一次性写入AOF文件")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 写命令执行完先放入AOF缓冲区(内存操作)，然后表示每隔1秒将缓冲区数据写到AOF文件(磁盘IO)，是默认方案 ")]),a._v("\nappendfsync everysec\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 还有no 和 always策略")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# no交给OS来管理 , Linux默认 30s 写入一次数据至磁盘")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# always 每次都直接写入文件")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("h4",{attrs:{id:"_2、主动触发-bgrewriteaof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、主动触发-bgrewriteaof"}},[a._v("#")]),a._v(" 2、主动触发：bgrewriteaof")]),a._v(" "),s("p",[a._v("执行bgrewriteaof命令")]),a._v(" "),s("h3",{attrs:{id:"写入aof文件是谁负责"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#写入aof文件是谁负责"}},[a._v("#")]),a._v(" 写入AOF文件是谁负责")]),a._v(" "),s("p",[a._v("策略不同，负责人不同")]),a._v(" "),s("ul",[s("li",[a._v("如果是"),s("code",[a._v("appendfsync always")]),a._v("，是Redis主进程")]),a._v(" "),s("li",[a._v("如果是"),s("code",[a._v("appendfsync everysec")]),a._v("，是一个异步任务")]),a._v(" "),s("li",[a._v("如果是"),s("code",[a._v("appendfsync no")]),a._v("，是交给操作系统管")])]),a._v(" "),s("blockquote",[s("p",[a._v("everysec 和 always 会发起 fsync 系统调用")]),a._v(" "),s("p",[a._v("no会发起 write 系统调用")])]),a._v(" "),s("p",[a._v("另外，bgrewriteaof主动触发，是fork一个子进程进行。")]),a._v(" "),s("h3",{attrs:{id:"aof文件膨胀问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof文件膨胀问题"}},[a._v("#")]),a._v(" AOF文件膨胀问题")]),a._v(" "),s("p",[a._v("AOF是对操作的追加写，只会变大不会变小，因此会膨胀，带来如下问题：")]),a._v(" "),s("ul",[s("li",[a._v("Redis重启要遍历整个AOF文件，无效操作会降低启动速度")]),a._v(" "),s("li",[a._v("文件无限膨胀，影响写入速度，并且会超过OS对单个文件的大小限制")])]),a._v(" "),s("p",[a._v("要解决这个问题，我们需要重写AOF文件使得它变小。")]),a._v(" "),s("h2",{attrs:{id:"aof文件重写-解决aof文件膨胀问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof文件重写-解决aof文件膨胀问题"}},[a._v("#")]),a._v(" AOF文件重写：解决AOF文件膨胀问题")]),a._v(" "),s("h3",{attrs:{id:"aof文件重写的本质"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof文件重写的本质"}},[a._v("#")]),a._v(" AOF文件重写的本质")]),a._v(" "),s("p",[a._v("本质就是读取整个Redis数据库，读到一个键值对，然后以set k v的形式作为命令写入AOF文件")]),a._v(" "),s("blockquote",[s("p",[a._v("是不是和RDB很像，但是比RDB占据的空间更大")])]),a._v(" "),s("h4",{attrs:{id:"子进程重写"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#子进程重写"}},[a._v("#")]),a._v(" 子进程重写")]),a._v(" "),s("p",[a._v("AOF文件很大，重写操作很重，不能占用主进程导致阻塞，因此bgrewriteaof 时，主线程 fork 出后台的 bgrewriteaof 子进程来进行重写。")]),a._v(" "),s("h3",{attrs:{id:"aof文件重写触发时机"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof文件重写触发时机"}},[a._v("#")]),a._v(" AOF文件重写触发时机")]),a._v(" "),s("h4",{attrs:{id:"_1、自动重写"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、自动重写"}},[a._v("#")]),a._v(" 1、自动重写")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# AOF文件比上次文件 增长超过多少百分比则触发重写，默认为 100")]),a._v("\nauto-aof-rewrite-percentage "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("100")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# AOF文件体积最小多大以上才触发重写，默认为 64mb")]),a._v("\nauto-aof-rewrite-min-size 64mb\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("ul",[s("li",[a._v("AOF文件大小翻倍，重写")]),a._v(" "),s("li",[a._v("AOF文件大小至少"),s("code",[a._v("auto-aof-rewrite-min-size")]),a._v("才会触发重写")]),a._v(" "),s("li",[a._v("以上两个条件需要同时满足才会自动重写")])]),a._v(" "),s("p",[a._v("因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义，因此需要重写AOF文件，但会占用大量CPU和内存资源")]),a._v(" "),s("h4",{attrs:{id:"_2、手动重写-bgrewriteaof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、手动重写-bgrewriteaof"}},[a._v("#")]),a._v(" 2、手动重写：bgrewriteaof")]),a._v(" "),s("p",[a._v("bgrewriteaof不仅会持久化AOF，也会重写AOF。")]),a._v(" "),s("h3",{attrs:{id:"重写过程中的写操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重写过程中的写操作"}},[a._v("#")]),a._v(" 重写过程中的写操作")]),a._v(" "),s("p",[a._v("重写过程中，有两个日志，一个旧的大AOF日志，一个新的正在重写的AOF日志。")]),a._v(" "),s("p",[a._v("此时，写操作会"),s("strong",[a._v("同时写入两个日志的AOF缓冲区")]),a._v("。")]),a._v(" "),s("h3",{attrs:{id:"aof重写的风险-阻塞fsync"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof重写的风险-阻塞fsync"}},[a._v("#")]),a._v(" AOF重写的风险：阻塞fsync")]),a._v(" "),s("p",[a._v("AOF 重写会对磁盘进行大量 IO 操作，同时，fsync 又需要等到数据写到磁盘后才能返回，所以，当 AOF 重写的压力比较大时，就会导致 fsync 被阻塞。")]),a._v(" "),s("p",[a._v("fsync 阻塞还会进一步导致主线程阻塞。")]),a._v(" "),s("p",[a._v("当主线程让子线程 fsync 时，发现上一次 fsync 还没有执行完，主线程也会阻塞。")]),a._v(" "),s("h4",{attrs:{id:"解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[a._v("#")]),a._v(" 解决方案")]),a._v(" "),s("p",[a._v("对于always/everysec的刷盘机制，只有一种方案：直接不fsync")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 表示在 AOF 重写时，不进行 fsync 操作 默认 no")]),a._v("\nno-appendfsync-on-rewrite "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("yes")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("p",[a._v("此时，Redis把写命令写到内存后，不调用后台线程进行 fsync 操作，直接返回。")]),a._v(" "),s("p",[a._v("缺点是：此时实例发生宕机，就会导致数据丢失。")]),a._v(" "),s("h3",{attrs:{id:"aof文件异常处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof文件异常处理"}},[a._v("#")]),a._v(" AOF文件异常处理")]),a._v(" "),s("h4",{attrs:{id:"手动修复"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#手动修复"}},[a._v("#")]),a._v(" 手动修复")]),a._v(" "),s("p",[a._v("使用 AOF 修复工具，检测出现的问题，在命令行中输入 "),s("code",[a._v("redis-check-aof")]),a._v(" 命令，它会跳转到出现问题的命令行，这个时候可以尝试手动修复此文件；")]),a._v(" "),s("h4",{attrs:{id:"自动修复"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自动修复"}},[a._v("#")]),a._v(" 自动修复")]),a._v(" "),s("p",[a._v("如果无法手动修复，我们可以使用 "),s("code",[a._v("redis-check-aof --fix")]),a._v(" 自动修复 AOF 异常文件，不过执行此命令，可能会导致"),s("strong",[a._v("异常部分至文件末尾的数据全部被丢弃")]),a._v("。")]),a._v(" "),s("h3",{attrs:{id:"aof的缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof的缺点"}},[a._v("#")]),a._v(" AOF的缺点")]),a._v(" "),s("p",[a._v("AOF 文件通常更大，负载比较高的情况下，RDB 比 AOF 性能更好；")]),a._v(" "),s("blockquote",[s("p",[a._v("注意：同时开启RDB 和 AOF，Redis 启动时只会加载 AOF 文件")])]),a._v(" "),s("h2",{attrs:{id:"三、混合持久化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、混合持久化"}},[a._v("#")]),a._v(" 三、混合持久化")]),a._v(" "),s("h4",{attrs:{id:"混合下的aof文件重写"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#混合下的aof文件重写"}},[a._v("#")]),a._v(" 混合下的AOF文件重写")]),a._v(" "),s("p",[a._v("在开启混合持久化的情况下，AOF 重写时会把 Redis 的持久化数据，以 RDB 的格式写入到 AOF 文件的开头，（bgsave过程中的操作以及）之后操作的数据再以 AOF 的格式，追加在文件的末尾。")]),a._v(" "),s("h4",{attrs:{id:"开启混合持久化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开启混合持久化"}},[a._v("#")]),a._v(" 开启混合持久化")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("aof-use-rdb-preamble "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("yes")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 还需要开启 AOF 和 RDB")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("h4",{attrs:{id:"混合持久化的redis启动流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#混合持久化的redis启动流程"}},[a._v("#")]),a._v(" 混合持久化的Redis启动流程")]),a._v(" "),s("p",[a._v("一般情况下，会先加载AOF文件中的RDB部分，再加载AOF部分")]),a._v(" "),s("h3",{attrs:{id:"混合持久化的优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#混合持久化的优点"}},[a._v("#")]),a._v(" 混合持久化的优点")]),a._v(" "),s("p",[a._v("兼具AOF 与 RDB的优点")]),a._v(" "),s("h4",{attrs:{id:"混合-vs-aof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#混合-vs-aof"}},[a._v("#")]),a._v(" 混合 vs AOF")]),a._v(" "),s("p",[a._v("因为涉及RDB，比AOF数据恢复速度更快")]),a._v(" "),s("p",[a._v("文件大小比纯AOF文件更小")]),a._v(" "),s("h4",{attrs:{id:"混合-vs-rdb"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#混合-vs-rdb"}},[a._v("#")]),a._v(" 混合 vs RDB")]),a._v(" "),s("p",[a._v("丢失数据的风险比RDB更低；")]),a._v(" "),s("h2",{attrs:{id:"redis持久化实战"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis持久化实战"}},[a._v("#")]),a._v(" Redis持久化实战")]),a._v(" "),s("p",[a._v("一般需要持久化的情况，就用混合持久化即可。")]),a._v(" "),s("p",[a._v("主从架构下，从节点不需要持久化。")]),a._v(" "),s("p",[a._v("《Redis 核心技术与实战》给出的建议是：")]),a._v(" "),s("ul",[s("li",[a._v("数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；")]),a._v(" "),s("li",[a._v("如果允许分钟级别的数据丢失，可以只使用 RDB；")]),a._v(" "),s("li",[a._v("如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。")])]),a._v(" "),s("h3",{attrs:{id:"参考文档"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考文档"}},[a._v("#")]),a._v(" 参考文档")]),a._v(" "),s("p",[a._v("《Redis 核心技术与实战》")]),a._v(" "),s("p",[a._v("《Redis 核心原理与实战》")])])}),[],!1,null,null,null);s.default=r.exports}}]);