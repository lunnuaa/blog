(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{424:function(s,a,e){"use strict";e.r(a);var t=e(14),r=Object(t.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"redis-常见问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-常见问题"}},[s._v("#")]),s._v(" Redis 常见问题")]),s._v(" "),a("h2",{attrs:{id:"_1、redis-缓存穿透-访问不存在的数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、redis-缓存穿透-访问不存在的数据"}},[s._v("#")]),s._v(" 1、Redis 缓存穿透：访问不存在的数据")]),s._v(" "),a("p",[s._v("概念：redis和数据库都没有你要的数据，但你一直访问，最终造成数据库服务器瘫痪")]),s._v(" "),a("p",[s._v("重点："),a("strong",[s._v("缓存不存在")])]),s._v(" "),a("h4",{attrs:{id:"布隆过滤器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#布隆过滤器"}},[s._v("#")]),s._v(" 布隆过滤器")]),s._v(" "),a("p",[s._v("布隆过滤器，Bloom Filter，用于检索一个元素是否在一个集合中，可以理解为一个0/1位数组，初始时全为0")]),s._v(" "),a("p",[s._v("存储数据的时时候，使用K个不同的哈希函数将这个变量映射为bit列表的的K个点，把它们置为1")]),s._v(" "),a("p",[s._v("判断缓存key是否存在，同样K个哈希函数，映射到bit列表上的K个点，判断是不是1：")]),s._v(" "),a("p",[s._v("1）如果全不是1，那么key不存在；")]),s._v(" "),a("p",[s._v("2）如果都是1，也只是表示key可能存在")]),s._v(" "),a("blockquote",[a("p",[s._v("布隆过滤器还有其它的应用，比如实现垃圾邮件过滤等")])]),s._v(" "),a("h4",{attrs:{id:"缓存空值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存空值"}},[s._v("#")]),s._v(" 缓存空值")]),s._v(" "),a("p",[s._v("数据库给redis一个null缓存 TTL可以设置的较短")]),s._v(" "),a("h2",{attrs:{id:"_2、缓存雪崩-大量缓存key同时消失"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、缓存雪崩-大量缓存key同时消失"}},[s._v("#")]),s._v(" 2、缓存雪崩：大量缓存key同时消失")]),s._v(" "),a("p",[s._v("缓存雪崩：大量redis的key同时过期，导致数据库压力太大")]),s._v(" "),a("h4",{attrs:{id:"随机化过期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#随机化过期"}},[s._v("#")]),s._v(" 随机化过期")]),s._v(" "),a("p",[s._v("TTL赋值加一个小的随机数 比如 30MIN + 0~5 rand")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 缓存原本的失效时间")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" exTime "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("60")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 随机数生成类")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Random")]),s._v(" random "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Random")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 缓存设置")]),s._v("\njedis"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("setex")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("cacheKey"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" exTime"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v("random"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("nextInt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h4",{attrs:{id:"多级缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多级缓存"}},[s._v("#")]),s._v(" 多级缓存")]),s._v(" "),a("p",[s._v("除了 Redis 本身的缓存，再设置一层缓存，当 Redis 失效之后，先去查询二级缓存。")]),s._v(" "),a("h2",{attrs:{id:"_3、缓存击穿-热点key消失"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、缓存击穿-热点key消失"}},[s._v("#")]),s._v(" 3、缓存击穿：热点key消失")]),s._v(" "),a("p",[s._v("缓存击穿：热点Key消失了，导致数据库压力过大")]),s._v(" "),a("h4",{attrs:{id:"互斥锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#互斥锁"}},[s._v("#")]),s._v(" 互斥锁")]),s._v(" "),a("p",[s._v("查询缓存未命中，会加锁，等到写入缓存后才释放锁")]),s._v(" "),a("p",[s._v("缺点：其他线程等待时间较长，死锁风险")]),s._v(" "),a("h4",{attrs:{id:"逻辑过期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#逻辑过期"}},[s._v("#")]),s._v(" 逻辑过期")]),s._v(" "),a("p",[s._v("不设置TTL，而是加expire字段 - 逻辑时间")]),s._v(" "),a("p",[s._v("发现时间过期了 相当于 缓存未命中 进行以下操作：")]),s._v(" "),a("ol",[a("li",[s._v("尝试获取互斥锁")]),s._v(" "),a("li",[a("ul",[a("li",[s._v("若获取成功，开启新的线程，查数据库更新缓存，释放锁")]),s._v(" "),a("li",[s._v("若获取失败，直接进入步骤3")])])]),s._v(" "),a("li",[s._v("直接从缓存中返回过期数据（无论第二步结果如何，都不会等待锁的释放，而是直接返回）")])]),s._v(" "),a("p",[s._v("优点：线程无需等待用户体验好")]),s._v(" "),a("p",[s._v("缺点：会有数据不一致性 消耗额外内存")]),s._v(" "),a("h2",{attrs:{id:"_4、内存碎片"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、内存碎片"}},[s._v("#")]),s._v(" 4、内存碎片")]),s._v(" "),a("p",[s._v("Redis 使用 jemalloc 作为内存分配库，而非malloc。在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。但缺点是，在 Redis 的使用过程中，会产生许多内存碎片。")]),s._v(" "),a("h4",{attrs:{id:"查看内存使用情况-memory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查看内存使用情况-memory"}},[s._v("#")]),s._v(" 查看内存使用情况：memory")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("INFO memory\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 实际申请使用的空间")]),s._v("\nused_memory:1073741736\nused_memory_human:1024.00M\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 操作系统实际分配给 Redis 的物理内存空间")]),s._v("\nused_memory_rss:1997159792\nused_memory_rss_human:1.86G\n…\nmem_fragmentation_ratio:1.86\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[a("code",[s._v("mem_fragmentation_ratio")]),s._v(" 反映了目前内存碎片的情况，这个值是：")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("mem_fragmentation_ratio "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" used_memory_rss/ used_memory\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("当"),a("code",[s._v("mem_fragmentation_ratio")]),s._v(" 超过1.5，认为内存碎片已经很多了，需要清理")]),s._v(" "),a("blockquote",[a("p",[s._v("如果小于1，说明已经有部分swap到磁盘了，内存不够。")])]),s._v(" "),a("h3",{attrs:{id:"redis自动清理内存碎片"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis自动清理内存碎片"}},[s._v("#")]),s._v(" Redis自动清理内存碎片")]),s._v(" "),a("p",[s._v("Redis提供了一种内存碎片"),a("strong",[s._v("自动清理的")]),s._v("方法，所谓清理就是使得所有实际使用的内存尽可能连续，紧凑。")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("config "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" activedefrag "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h4",{attrs:{id:"自动清理的时机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自动清理的时机"}},[s._v("#")]),s._v(" 自动清理的时机")]),s._v(" "),a("p",[s._v("有两个参数")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 内存碎片的字节数达到 100MB 时，开始清理")]),s._v("\nactive-defrag-ignore-bytes 100mb\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 内存碎片空间占操作系统分配给 Redis 的总空间比例达到 10% 时，开始清理")]),s._v("\nactive-defrag-threshold-lower "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("h4",{attrs:{id:"阻塞主线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阻塞主线程"}},[s._v("#")]),s._v(" 阻塞主线程")]),s._v(" "),a("p",[s._v("清理内存碎片的动作，相当于在对Redis进行写操作，此时Redis主线程是会被阻塞的。因此Redis")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 自动清理占用 CPU 时间的比例最少 25% 这是为了保证真的能够清理 不至于时间太短什么也没做就切换了")]),s._v("\nactive-defrag-cycle-min "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("25")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 占用 CPU 时间的比例最大值 可以避免Redis长时间阻塞")]),s._v("\nactive-defrag-cycle-max "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("75")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("通过调小 "),a("code",[s._v("active-defrag-cycle-max")]),s._v(" 的值，可以在进行清理时提高Redis的性能。")]),s._v(" "),a("h3",{attrs:{id:"redis内存碎片问题小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis内存碎片问题小结"}},[s._v("#")]),s._v(" Redis内存碎片问题小结")]),s._v(" "),a("p",[s._v("如果物理内存资源比较紧张，为了避免内存碎片过多，可以考虑开启自动清理内存碎片功能。")]),s._v(" "),a("blockquote",[a("p",[s._v("当然另一种简单粗暴的方法是在访问量低的时机重启Redis")])]),s._v(" "),a("p",[s._v("需要关注四个参数，用于控制触发时机和占用CPU资源。")]),s._v(" "),a("h2",{attrs:{id:"_5、bigkeys-本质是value过大"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、bigkeys-本质是value过大"}},[s._v("#")]),s._v(" 5、bigkeys：本质是value过大")]),s._v(" "),a("p",[s._v("K-V。V是重点。比如点赞，帖子的点赞用户Id的list/set，会很大。百万人点赞。")]),s._v(" "),a("h3",{attrs:{id:"大key问题带来的影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#大key问题带来的影响"}},[s._v("#")]),s._v(" 大Key问题带来的影响")]),s._v(" "),a("p",[s._v("对大key的查询等操作，会严重影响性能，且因为单线程，会阻塞后续操作。")]),s._v(" "),a("h4",{attrs:{id:"大key对aof的影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#大key对aof的影响"}},[s._v("#")]),s._v(" 大Key对AOF的影响")]),s._v(" "),a("p",[s._v("虽然大Key问题的本质是value过大，但也会影响到AOF。")]),s._v(" "),a("ol",[a("li",[s._v("AOF重写时，是类似RDB的将所有键值对记录为set k v，涉及到value")]),s._v(" "),a("li",[s._v("AOF重写时，对大Key的修改采取写时复制策略，会复制整个大key，向OS申请大片内存空间会面临阻塞，OS需要加锁等操作，性能低。核心问题是这一点。")])]),s._v(" "),a("p",[s._v("因此，value过大也会影响到AOF。")]),s._v(" "),a("h3",{attrs:{id:"如何发现大key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何发现大key"}},[s._v("#")]),s._v(" 如何发现大key")]),s._v(" "),a("h4",{attrs:{id:"_1、bigkeys命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、bigkeys命令"}},[s._v("#")]),s._v(" 1、bigkeys命令")]),s._v(" "),a("p",[s._v("执行bigkeys命令，可以找到大key（建议在 slave 节点执行）")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("./redis-cli  "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("--bigkeys")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 统计每种数据类型中元素个数最多的bigkey")]),s._v("\nBiggest   list found "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'product1'")]),s._v(" has "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8")]),s._v(" items\nBiggest   "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("hash")]),s._v(" found "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'dtemp'")]),s._v(" has "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v(" fields\nBiggest string found "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'page2'")]),s._v(" has "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("28")]),s._v(" bytes\nBiggest stream found "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'mqstream'")]),s._v(" has "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("4")]),s._v(" entries\nBiggest    "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" found "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'userid'")]),s._v(" has "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v(" members\nBiggest   zset found "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'device:temperature'")]),s._v(" has "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("6")]),s._v(" members\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("bigkeys不推荐使用，bigkeys命令的缺点如下：")]),s._v(" "),a("h5",{attrs:{id:"阻塞主线程的风险"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阻塞主线程的风险"}},[s._v("#")]),s._v(" 阻塞主线程的风险")]),s._v(" "),a("p",[s._v("bigkeys 命令也需要扫描整个 Redis 数据库，因此会造成主线程阻塞，线上环境可以用在从库。")]),s._v(" "),a("p",[s._v("另外，可以通过 -i 参数指定扫描间隔")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 每扫描 100 次暂停 0.1 秒")]),s._v("\n./redis-cli  "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("--bigkeys")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-i")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.1")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("h5",{attrs:{id:"bigkeys不全"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bigkeys不全"}},[s._v("#")]),s._v(" bigkeys不全")]),s._v(" "),a("p",[s._v("bigkeys 根据数据类型，返回最大的bigkey，并且统计的是"),a("strong",[s._v("集合元素个数的多少，而不是实际占用的内存量")]),s._v("。")]),s._v(" "),a("p",[s._v("所以 bigkeys 的结论”仅供参考“，并不可靠。")]),s._v(" "),a("h4",{attrs:{id:"_2、手动scan"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、手动scan"}},[s._v("#")]),s._v(" 2、手动scan")]),s._v(" "),a("p",[s._v("scan是一种安全的遍历数据库的方式。")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("scan "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("cursor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" MATCH "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("pattern"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("COUNT count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# count:限定服务器单次遍历的字典槽位数量（约等于）")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("再结合 MEMORY USAGE 命令，查询一个键值对占用的内存空间")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("MEMORY USAGE "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("从而找到实际占用内存较大的key")]),s._v(" "),a("h3",{attrs:{id:"解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[s._v("#")]),s._v(" 解决方案")]),s._v(" "),a("h4",{attrs:{id:"对于能删的key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对于能删的key"}},[s._v("#")]),s._v(" 对于能删的key")]),s._v(" "),a("p",[s._v("Redis 4.0 提供了 unlink 命令，可以异步非阻塞删除 key")]),s._v(" "),a("h4",{attrs:{id:"对于不能删的key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对于不能删的key"}},[s._v("#")]),s._v(" 对于不能删的key")]),s._v(" "),a("p",[s._v("可以对字符串压缩，拆分，对list/set分片，把一个大 key 转化成多个小 key")]),s._v(" "),a("h2",{attrs:{id:"_6、-hotkey-热点key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6、-hotkey-热点key"}},[s._v("#")]),s._v(" 6、 HotKey：热点key")]),s._v(" "),a("p",[s._v("某个key是极度热点key，频繁访问会导致redis负担过大。")]),s._v(" "),a("h3",{attrs:{id:"如何发现-hotkey"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何发现-hotkey"}},[s._v("#")]),s._v(" 如何发现 HotKey")]),s._v(" "),a("h4",{attrs:{id:"_1、hotkeys-命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、hotkeys-命令"}},[s._v("#")]),s._v(" 1、HotKeys 命令")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# hotkeys 命令需要内存淘汰策略为 xxx-lfu")]),s._v("\nredis-cli –hotkeys\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("h4",{attrs:{id:"_2、预估"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、预估"}},[s._v("#")]),s._v(" 2、预估")]),s._v(" "),a("p",[s._v("根据业务预估热key。")]),s._v(" "),a("h4",{attrs:{id:"_3、数据分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、数据分析"}},[s._v("#")]),s._v(" 3、数据分析")]),s._v(" "),a("p",[s._v("可以利用hadoop大数据分析hotkey有哪些。")]),s._v(" "),a("h4",{attrs:{id:"_4、客户端收集"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、客户端收集"}},[s._v("#")]),s._v(" 4、客户端收集")]),s._v(" "),a("p",[s._v("《有赞透明多级缓存解决方案（TMC）》中说到，有赞改写了jedis原生的jar包，加入了Hermes-SDK包，做热点发现和本地缓存，对于Jedis-Client的每次key值访问请求，Hermes-SDK 都会通过其通信模块将key访问事件异步上报给Hermes服务端集群，以便其根据上报数据进行“热点探测”。")]),s._v(" "),a("h3",{attrs:{id:"解决方案-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-2"}},[s._v("#")]),s._v(" 解决方案")]),s._v(" "),a("h4",{attrs:{id:"请求分散"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请求分散"}},[s._v("#")]),s._v(" 请求分散")]),s._v(" "),a("p",[s._v("可以把HotKey分散存储在多个redis实例上，可以给他们加不同的后缀，访问的时候随机选择后缀，从而达到数据访问请求分散。")]),s._v(" "),a("h4",{attrs:{id:"本地缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本地缓存"}},[s._v("#")]),s._v(" 本地缓存")]),s._v(" "),a("p",[s._v("对 HotKey 做本地缓存，避免频繁访问 Redis，但又需要额外考虑缓存不一致的问题。")]),s._v(" "),a("h3",{attrs:{id:"参考文档"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文档"}},[s._v("#")]),s._v(" 参考文档")]),s._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/ywlmsm1224811/article/details/102736986",target:"_blank",rel:"noopener noreferrer"}},[s._v("高并发百万级热点key处理方案"),a("OutboundLink")],1)]),s._v(" "),a("p",[s._v("《Redis 核心技术与实战》")])])}),[],!1,null,null,null);a.default=r.exports}}]);