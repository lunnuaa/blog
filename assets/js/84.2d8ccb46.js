(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{420:function(a,s,e){"use strict";e.r(s);var t=e(14),r=Object(t.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"主从架构-redis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主从架构-redis"}},[a._v("#")]),a._v(" 主从架构 Redis")]),a._v(" "),s("p",[a._v("主从架构下，从节点通过复制主节点的数据")]),a._v(" "),s("h2",{attrs:{id:"主从架构的意义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主从架构的意义"}},[a._v("#")]),a._v(" 主从架构的意义")]),a._v(" "),s("h4",{attrs:{id:"_1、读写分离-提升性能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、读写分离-提升性能"}},[a._v("#")]),a._v(" 1、读写分离：提升性能")]),a._v(" "),s("p",[a._v("主从架构下，仍然只有主节点能够处理「写请求」，从节点一般只能处理「读请求」。")]),a._v(" "),s("h4",{attrs:{id:"_2、数据备份-更安全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、数据备份-更安全"}},[a._v("#")]),a._v(" 2、数据备份：更安全")]),a._v(" "),s("p",[a._v("从节点拥有与主节点相同的数据，从而实现数据备份，数据不易丢失")]),a._v(" "),s("h4",{attrs:{id:"_3、高可用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、高可用"}},[a._v("#")]),a._v(" 3、高可用")]),a._v(" "),s("p",[a._v("一台节点即使宕机，其它节点仍然可以对外提供服务")]),a._v(" "),s("h3",{attrs:{id:"从节点可以处理写命令吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从节点可以处理写命令吗"}},[a._v("#")]),a._v(" 从节点可以处理写命令吗")]),a._v(" "),s("p",[a._v("默认是不行的。但也是可以的。")]),a._v(" "),s("p",[a._v("开启从节点处理写命令功能，如下：")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("config "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("set")]),a._v(" replica-read-only no\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("但是，存在很多问题：")]),a._v(" "),s("ul",[s("li",[a._v("写的数据不会同步给所有其它Redis服务器")]),a._v(" "),s("li",[a._v("一旦发生主节点的全量同步，从节点的写操作的数据会丢失")])]),a._v(" "),s("p",[a._v("所以主从架构一般就是实现读写分离。")]),a._v(" "),s("h2",{attrs:{id:"主从架构快速开始"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主从架构快速开始"}},[a._v("#")]),a._v(" 主从架构快速开始")]),a._v(" "),s("h4",{attrs:{id:"将redis设置为从节点-replicaof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#将redis设置为从节点-replicaof"}},[a._v("#")]),a._v(" 将Redis设置为从节点：replicaof")]),a._v(" "),s("div",{staticClass:"language-shell line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 执行replicaof命令")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 将当前Redis节点设置为 [IP] [端口] 的Redis的从服务器")]),a._v("\nreplicaof "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("IP"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("端口"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\nreplicaof "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("127.0")]),a._v(".0.1 "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("6380")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("p",[a._v("主节点存在密码的话，需要在配置文件中进行设置")]),a._v(" "),s("div",{staticClass:"language-shell line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[a._v("masterauth "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("password"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# config set masterauth [password]")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("p",[a._v("此时，从节点会获取主节点的全部数据")]),a._v(" "),s("h4",{attrs:{id:"查看当前节点-role"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#查看当前节点-role"}},[a._v("#")]),a._v(" 查看当前节点：role")]),a._v(" "),s("div",{staticClass:"language-shell line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[a._v("role\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v('# "master" / "slave"')]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("ul",[s("li",[a._v("主节点会返回master，然后列出所有从节点的 IP、端口和连接时间；")]),a._v(" "),s("li",[a._v("从节点会返回slave，然后列出主节点的 IP、端口和连接时间。")])]),a._v(" "),s("h4",{attrs:{id:"成为主节点-replicaof-no-one"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#成为主节点-replicaof-no-one"}},[a._v("#")]),a._v(" 成为主节点：replicaof no one")]),a._v(" "),s("div",{staticClass:"language-shell line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[a._v("replicaof no one\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("虽然该Redis成为主节点，但数据仍将会被保留")]),a._v(" "),s("h2",{attrs:{id:"主从同步实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主从同步实现原理"}},[a._v("#")]),a._v(" 主从同步实现原理")]),a._v(" "),s("p",[a._v("容易想到的是，主从同步也是分为全量和增量的，这与RDB和AOF十分类似。")]),a._v(" "),s("ul",[s("li",[a._v("第一次连上，是全量更便捷")]),a._v(" "),s("li",[a._v("正常运行过程中，全量太慢，当然是增量更好")])]),a._v(" "),s("p",[a._v("为了增量同步，主从双方都是需要维护一些东西的。")]),a._v(" "),s("h3",{attrs:{id:"是否处于同一主从架构-replid"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#是否处于同一主从架构-replid"}},[a._v("#")]),a._v(" 是否处于同一主从架构：replid")]),a._v(" "),s("p",[a._v("replid，Replication Id，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid。")]),a._v(" "),s("h3",{attrs:{id:"初次连接-rdb"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#初次连接-rdb"}},[a._v("#")]),a._v(" 初次连接：RDB")]),a._v(" "),s("p",[a._v("初次连接需要全量复制，简单的做法是直接将RDB文件传过去。但缺点是可能数据已经过时了，因此Redis选择重新生成一个最新的RDB文件并发给从节点。")]),a._v(" "),s("p",[a._v("但具体怎么做取决于："),s("code",[a._v("repl-diskless-sync")]),a._v(" 参数（默认为no）")]),a._v(" "),s("ul",[s("li",[a._v("yes，不会在本地创建 RDB 文件，直接socket发出去")]),a._v(" "),s("li",[a._v("no，执行bgsave得到一个RDB文件，再发给从节点")])]),a._v(" "),s("p",[a._v("那在正常工作的情况下，一般在后续都会使用下面介绍的replication buffer")]),a._v(" "),s("h3",{attrs:{id:"正常工作-replication-buffer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正常工作-replication-buffer"}},[a._v("#")]),a._v(" 正常工作：replication buffer")]),a._v(" "),s("p",[a._v("主库的命令会写入一个叫"),s("code",[a._v("replication buffer")]),a._v("的缓冲区。主库将"),s("code",[a._v("replication buffer")]),a._v("的命令发送给从库，从而实现主从同步。")]),a._v(" "),s("p",[a._v("大小取决于 "),s("code",[a._v("client_buffer")]),a._v("，每个从库对应一个 "),s("code",[a._v("replication buffer")]),a._v("。")]),a._v(" "),s("h4",{attrs:{id:"replication-buffer缓冲区溢出"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#replication-buffer缓冲区溢出"}},[a._v("#")]),a._v(" replication buffer缓冲区溢出")]),a._v(" "),s("p",[a._v("可以通过如下配置修改replication buffer。")]),a._v(" "),s("div",{staticClass:"language-shell line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[a._v("config "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("set")]),a._v(" client-output-buffer-limit slave "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("512mb"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("128mb"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("60")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# [512mb]:缓冲区大小的上限,超过512mb,缓存区溢出")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# [128mb] 和 [60]:连续 60 秒内的写入量超过 128MB , 缓冲区溢出")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("h2",{attrs:{id:"从库离线后如何同步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从库离线后如何同步"}},[a._v("#")]),a._v(" 从库离线后如何同步")]),a._v(" "),s("h3",{attrs:{id:"_1、全量同步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、全量同步"}},[a._v("#")]),a._v(" 1、全量同步")]),a._v(" "),s("p",[a._v("一种可以想到的方案是，与初次连接相同，RDB即可。")]),a._v(" "),s("p",[a._v("但是，在有些情况只是网络波动，从库仅仅下线非常短暂的时间就执行一次全量同步，非常耗时，因此：")]),a._v(" "),s("p",[a._v("Redis 2.8 推出了一种「增量同步」的方案。")]),a._v(" "),s("h3",{attrs:{id:"_2、增量同步-repl-backlog"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、增量同步-repl-backlog"}},[a._v("#")]),a._v(" 2、增量同步：repl-backlog")]),a._v(" "),s("p",[a._v("当从库断连后，主库会把断连期间收到的写操作命令，写入 "),s("code",[a._v("replication buffer")]),a._v("，同时也会把这些操作命令也写入 "),s("code",[a._v("repl_backlog_buffer")]),a._v(" 这个缓冲区。")]),a._v(" "),s("blockquote",[s("p",[a._v("所有从库共享一个 "),s("code",[a._v("repl_backlog_buffer")])])]),a._v(" "),s("h4",{attrs:{id:"为什么不复用aof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么不复用aof"}},[a._v("#")]),a._v(" 为什么不复用AOF")]),a._v(" "),s("p",[a._v("明明都是维护的命令，为什么不能直接用AOF？")]),a._v(" "),s("p",[a._v("一方面是解耦。")]),a._v(" "),s("p",[a._v("AOF是为了解决持久化的方案，和主从同步属于两个模块。")]),a._v(" "),s("p",[a._v("第二个是AOF的重写机制。")]),a._v(" "),s("p",[a._v("发生AOF文件重写后，重写过程中都还好，重写完成后对offset的处理起来比较麻烦，也存在风险")]),a._v(" "),s("h4",{attrs:{id:"维护同步量-repl-backlog"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#维护同步量-repl-backlog"}},[a._v("#")]),a._v(" 维护同步量：repl-backlog")]),a._v(" "),s("p",[s("code",[a._v("repl_backlog")]),a._v("本质可以理解为一个环形数组，写完后会再次从数组下标0开始读写。")]),a._v(" "),s("p",[a._v("repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset")]),a._v(" "),s("blockquote",[s("p",[a._v("offset代表从节点目前同步了多少数据。")])]),a._v(" "),s("p",[s("code",[a._v("repl-backlog-size")]),a._v(" 默认是 1MB")]),a._v(" "),s("h4",{attrs:{id:"如何确定repl-backlog-size-的大小"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何确定repl-backlog-size-的大小"}},[a._v("#")]),a._v(" 如何确定"),s("code",[a._v("repl-backlog-size")]),a._v(" 的大小")]),a._v(" "),s("p",[a._v("还是根据业务定制")]),a._v(" "),s("blockquote",[s("p",[a._v("《Redis 核心技术与实战》中给出了一个计算公式：缓冲空间的计算公式是：缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 *  操作大小。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即 repl_backlog_size =  缓冲空间大小 * 2，这也就是 repl_backlog_size 的最终值。")]),a._v(" "),s("p",[a._v("举个例子，如果主库每秒写入 2000 个操作，每个操作的大小为 2KB，网络每秒能传输 1000 个操作，那么，有 1000  个操作需要缓冲起来，这就至少需要 2MB 的缓冲空间。否则，新写的命令就会覆盖掉旧操作了。为了应对可能的突发压力，我们最终把  repl_backlog_size 设为 4MB。")])]),a._v(" "),s("h4",{attrs:{id:"从节点已经同步的数据-offset"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从节点已经同步的数据-offset"}},[a._v("#")]),a._v(" 从节点已经同步的数据：offset")]),a._v(" "),s("p",[a._v("offset代表从节点目前同步了多少数据。")]),a._v(" "),s("p",[a._v("如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。")]),a._v(" "),s("h3",{attrs:{id:"完整流程叙述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#完整流程叙述"}},[a._v("#")]),a._v(" 完整流程叙述")]),a._v(" "),s("ol",[s("li",[a._v("slave如果是第一次向master发送请求，那slave发送的就是增量同步请求，但是此时的replid和offset是哪里来的呢？此时的replid和offset就是slave自身的，因为slave成为slave节点之前，自身就是一个master，即使它没有slave节点，所以replid和offset是它自身的。")]),a._v(" "),s("li",[a._v("此时master收到slave的请求后，会先判断replid是否一致，如果是第一次，master会拒绝slave的增量请求，然后返回master的replid和offset给slave，让slave记住。同时master会使用bgsave开启新线程，同步向这个第一次来的slave进行RDB全量同步。")]),a._v(" "),s("li",[a._v("由于RDB全量同步非常耗时，那么在这期间master进行了改变，期间的命令全都会被master记录在repl_baklog中，并修改自己的offset，然后等待RDB全量同步完成后，通过比较replid和offset，来进行增量同步(类似于AOF)，然后发送repl_backlog的命令给slave让其执行。")]),a._v(" "),s("li",[a._v("那么要是在发送repl_backlog期间，master又改变了，结果是依旧会被记录到repl_backlog中，然后比较replid和offset，再次然后发送repl_backlog的命令给slave让其执行。这是一个类似于监听的任务，反正只要不是第一次以后，都是借助replid和offset、repl_backlog来实现的增量同步。")])]),a._v(" "),s("h3",{attrs:{id:"其它细节"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其它细节"}},[a._v("#")]),a._v(" 其它细节")]),a._v(" "),s("h4",{attrs:{id:"从库不进行过期key扫描"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从库不进行过期key扫描"}},[a._v("#")]),a._v(" 从库不进行过期key扫描")]),a._v(" "),s("p",[a._v("主从模式下，只有主库会进行过期扫描，发现到期时，会加一条del命令删除key，写入AOF文件并最终同步到从苦衷，因此从库不需要进行过期扫描。")]),a._v(" "),s("h4",{attrs:{id:"环形repl-backlog-套圈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#环形repl-backlog-套圈"}},[a._v("#")]),a._v(" 环形repl-backlog“套圈”")]),a._v(" "),s("p",[a._v("当从节点由于种种原因，比如执行keys阻塞了非常久，或者repl-backlog设置的太小来不及处理，导致了主节点的repl-backlog堆积，一些命令还没来得及被从节点同步就已经被覆写了，这就是repl-backlog“套圈问题”。")]),a._v(" "),s("p",[a._v("此时只能进行类似初次连接的全量同步")]),a._v(" "),s("h2",{attrs:{id:"主从架构存在的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主从架构存在的问题"}},[a._v("#")]),a._v(" 主从架构存在的问题")]),a._v(" "),s("h3",{attrs:{id:"从节点数据的时延"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从节点数据的时延"}},[a._v("#")]),a._v(" 从节点数据的时延")]),a._v(" "),s("p",[a._v("同步过程中，主从节点会存在短暂的数据不一致。")]),a._v(" "),s("h3",{attrs:{id:"无法自动容灾恢复"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#无法自动容灾恢复"}},[a._v("#")]),a._v(" 无法自动容灾恢复")]),a._v(" "),s("p",[a._v("主从架构下，一旦主节点宕机，需要重新手动设置主从节点")]),a._v(" "),s("p",[a._v("哨兵就解决了这个问题。")]),a._v(" "),s("h2",{attrs:{id:"主-从-从-模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主-从-从-模式"}},[a._v("#")]),a._v(" 主-从-从 模式")]),a._v(" "),s("p",[a._v("当从库较多，所有从库的同步都依赖主库，主库压力过大。")]),a._v(" "),s("p",[a._v("可以从库下又有从库：")]),a._v(" "),s("div",{staticClass:"language-shell line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[a._v("replicaof  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("从库的IP"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("从库的port"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])])])}),[],!1,null,null,null);s.default=r.exports}}]);