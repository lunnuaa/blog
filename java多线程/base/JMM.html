<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java并发基石——JMM | lun&#39;s blogs</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/blog/favicon.ico">
    <meta name="description" content="blog">
    
    <link rel="preload" href="/blog/assets/css/0.styles.56f5eb6c.css" as="style"><link rel="preload" href="/blog/assets/js/app.7b9df32b.js" as="script"><link rel="preload" href="/blog/assets/js/2.be714ec7.js" as="script"><link rel="preload" href="/blog/assets/js/1.26c7c9cc.js" as="script"><link rel="preload" href="/blog/assets/js/27.56a57551.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.0d71bf2e.js"><link rel="prefetch" href="/blog/assets/js/11.cc81c248.js"><link rel="prefetch" href="/blog/assets/js/12.5e69cd14.js"><link rel="prefetch" href="/blog/assets/js/13.f0bc7bf2.js"><link rel="prefetch" href="/blog/assets/js/14.0188e855.js"><link rel="prefetch" href="/blog/assets/js/15.48a1e71e.js"><link rel="prefetch" href="/blog/assets/js/16.0f4182c9.js"><link rel="prefetch" href="/blog/assets/js/17.ec7b8f9d.js"><link rel="prefetch" href="/blog/assets/js/18.776522e2.js"><link rel="prefetch" href="/blog/assets/js/19.26561e06.js"><link rel="prefetch" href="/blog/assets/js/20.3e42feda.js"><link rel="prefetch" href="/blog/assets/js/21.fd4e7a00.js"><link rel="prefetch" href="/blog/assets/js/22.b59f6079.js"><link rel="prefetch" href="/blog/assets/js/23.e6b2d3ec.js"><link rel="prefetch" href="/blog/assets/js/24.736cfa99.js"><link rel="prefetch" href="/blog/assets/js/25.91176041.js"><link rel="prefetch" href="/blog/assets/js/26.146e299c.js"><link rel="prefetch" href="/blog/assets/js/28.13a846a1.js"><link rel="prefetch" href="/blog/assets/js/29.f71b59d6.js"><link rel="prefetch" href="/blog/assets/js/3.f34ea2f7.js"><link rel="prefetch" href="/blog/assets/js/30.bf0626f9.js"><link rel="prefetch" href="/blog/assets/js/31.47592684.js"><link rel="prefetch" href="/blog/assets/js/32.63f20fc3.js"><link rel="prefetch" href="/blog/assets/js/33.4852d9ec.js"><link rel="prefetch" href="/blog/assets/js/34.4f467138.js"><link rel="prefetch" href="/blog/assets/js/35.17d26444.js"><link rel="prefetch" href="/blog/assets/js/36.d0059312.js"><link rel="prefetch" href="/blog/assets/js/37.fc856e5d.js"><link rel="prefetch" href="/blog/assets/js/38.dc6b373c.js"><link rel="prefetch" href="/blog/assets/js/39.f04e5b6a.js"><link rel="prefetch" href="/blog/assets/js/4.885368ff.js"><link rel="prefetch" href="/blog/assets/js/40.b378efa5.js"><link rel="prefetch" href="/blog/assets/js/41.3c800d8a.js"><link rel="prefetch" href="/blog/assets/js/42.8b804f0c.js"><link rel="prefetch" href="/blog/assets/js/43.832aa078.js"><link rel="prefetch" href="/blog/assets/js/44.d1121c11.js"><link rel="prefetch" href="/blog/assets/js/45.b3e8ede1.js"><link rel="prefetch" href="/blog/assets/js/46.01e4202b.js"><link rel="prefetch" href="/blog/assets/js/47.489850e9.js"><link rel="prefetch" href="/blog/assets/js/48.3bd88d5f.js"><link rel="prefetch" href="/blog/assets/js/49.08c6f759.js"><link rel="prefetch" href="/blog/assets/js/5.d1dbc0b1.js"><link rel="prefetch" href="/blog/assets/js/50.c900e52a.js"><link rel="prefetch" href="/blog/assets/js/51.a59d8fbf.js"><link rel="prefetch" href="/blog/assets/js/52.0c715d23.js"><link rel="prefetch" href="/blog/assets/js/53.07715a2f.js"><link rel="prefetch" href="/blog/assets/js/54.e0d8cc69.js"><link rel="prefetch" href="/blog/assets/js/55.1efa3b0b.js"><link rel="prefetch" href="/blog/assets/js/56.ace3e6e3.js"><link rel="prefetch" href="/blog/assets/js/57.221667c1.js"><link rel="prefetch" href="/blog/assets/js/58.a786e5bd.js"><link rel="prefetch" href="/blog/assets/js/59.8a6dde26.js"><link rel="prefetch" href="/blog/assets/js/6.7ee6eed6.js"><link rel="prefetch" href="/blog/assets/js/60.0192f277.js"><link rel="prefetch" href="/blog/assets/js/61.75813485.js"><link rel="prefetch" href="/blog/assets/js/62.d8de1a01.js"><link rel="prefetch" href="/blog/assets/js/63.a08485a4.js"><link rel="prefetch" href="/blog/assets/js/64.7d19f572.js"><link rel="prefetch" href="/blog/assets/js/65.3f290d9a.js"><link rel="prefetch" href="/blog/assets/js/66.73f49082.js"><link rel="prefetch" href="/blog/assets/js/67.cb22e678.js"><link rel="prefetch" href="/blog/assets/js/68.22dc7228.js"><link rel="prefetch" href="/blog/assets/js/69.1f450482.js"><link rel="prefetch" href="/blog/assets/js/7.153b9c62.js"><link rel="prefetch" href="/blog/assets/js/70.03205c0b.js"><link rel="prefetch" href="/blog/assets/js/71.5b98edf5.js"><link rel="prefetch" href="/blog/assets/js/72.8be00756.js"><link rel="prefetch" href="/blog/assets/js/73.5e60394c.js"><link rel="prefetch" href="/blog/assets/js/74.a1100b64.js"><link rel="prefetch" href="/blog/assets/js/75.b47153bc.js"><link rel="prefetch" href="/blog/assets/js/76.b881f0b9.js"><link rel="prefetch" href="/blog/assets/js/77.eef60dd8.js"><link rel="prefetch" href="/blog/assets/js/78.b52fa32f.js"><link rel="prefetch" href="/blog/assets/js/79.9adc486f.js"><link rel="prefetch" href="/blog/assets/js/80.10b21516.js"><link rel="prefetch" href="/blog/assets/js/81.12c11cbc.js"><link rel="prefetch" href="/blog/assets/js/82.df4ae15b.js"><link rel="prefetch" href="/blog/assets/js/83.078b9ed6.js"><link rel="prefetch" href="/blog/assets/js/84.2d8ccb46.js"><link rel="prefetch" href="/blog/assets/js/85.4d5e44f4.js"><link rel="prefetch" href="/blog/assets/js/86.c32dda95.js"><link rel="prefetch" href="/blog/assets/js/87.c28d1f54.js"><link rel="prefetch" href="/blog/assets/js/88.c06457bb.js"><link rel="prefetch" href="/blog/assets/js/89.1febc082.js"><link rel="prefetch" href="/blog/assets/js/90.37985dbe.js"><link rel="prefetch" href="/blog/assets/js/91.9c3ebd93.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.02634ae8.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.56f5eb6c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="lun's blogs" class="logo"> <span class="site-name can-hide">lun's blogs</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/base/Exception.html" class="nav-link">
  异常
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Generics.html" class="nav-link">
  泛型
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Enum.html" class="nav-link">
  枚举
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Serialize.html" class="nav-link">
  Java序列化机制详解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Proxy.html" class="nav-link">
  动态代理
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Annotation.html" class="nav-link">
  深入理解Java注解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream1.html" class="nav-link">
  Stream源码分析(上)
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream2.html" class="nav-link">
  Stream源码分析(下)
</a></li></ul></div></div><div class="nav-item"><a href="/blog/java多线程/" class="nav-link">
  Java多线程
</a></div><div class="nav-item"><a href="/blog/jvm/" class="nav-link">
  JVM
</a></div><div class="nav-item"><a href="/blog/redis/" class="nav-link">
  Redis
</a></div><div class="nav-item"><a href="/blog/blogs/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="https://juejin.cn/user/2159878519134157" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/base/Exception.html" class="nav-link">
  异常
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Generics.html" class="nav-link">
  泛型
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Enum.html" class="nav-link">
  枚举
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Serialize.html" class="nav-link">
  Java序列化机制详解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Proxy.html" class="nav-link">
  动态代理
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Annotation.html" class="nav-link">
  深入理解Java注解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream1.html" class="nav-link">
  Stream源码分析(上)
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream2.html" class="nav-link">
  Stream源码分析(下)
</a></li></ul></div></div><div class="nav-item"><a href="/blog/java多线程/" class="nav-link">
  Java多线程
</a></div><div class="nav-item"><a href="/blog/jvm/" class="nav-link">
  JVM
</a></div><div class="nav-item"><a href="/blog/redis/" class="nav-link">
  Redis
</a></div><div class="nav-item"><a href="/blog/blogs/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="https://juejin.cn/user/2159878519134157" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" aria-current="page" class="sidebar-link">一、前言</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>二、Java并发基础知识</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java多线程/base/Base.html" class="sidebar-link">多线程基础知识</a></li><li><a href="/blog/java多线程/base/JMM.html" class="active sidebar-link">Java并发基石——JMM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#_1、解决可见性-内存的抽象划分" class="sidebar-link">1、解决可见性：内存的抽象划分</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#线程本地内存的本质" class="sidebar-link">线程本地内存的本质</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#java内存模型与内存结构的关系" class="sidebar-link">Java内存模型与内存结构的关系</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#本地内存-与-堆" class="sidebar-link">本地内存 与 堆</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#线程本地内存-和-主存-具体如何交互" class="sidebar-link">线程本地内存 和 主存 具体如何交互</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#线程本地内存小结" class="sidebar-link">线程本地内存小结</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#_2、解决有序性-禁止重排序" class="sidebar-link">2、解决有序性：禁止重排序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#什么是重排序" class="sidebar-link">什么是重排序</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#jmm重排序的策略" class="sidebar-link">JMM重排序的策略</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#有序性问题的根本-可见性" class="sidebar-link">有序性问题的根本：可见性</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#jmm限制重排序的具体规则" class="sidebar-link">JMM限制重排序的具体规则</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#happens-before规则" class="sidebar-link" style="padding-left:3rem;">happens-before规则</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#as-if-serial-单线程语义的保证" class="sidebar-link" style="padding-left:4rem;">as if serial：单线程语义的保证</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#happens-before理解实战" class="sidebar-link">happens-before理解实战</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#禁止重排序的方法-内存屏障" class="sidebar-link">禁止重排序的方法：内存屏障</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#猜测执行" class="sidebar-link">猜测执行</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#_3、解决原子性-cas与锁" class="sidebar-link">3、解决原子性：CAS与锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#一、cas-compare-and-swap" class="sidebar-link">一、CAS ：Compare and Swap</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#cas实现原理简述" class="sidebar-link" style="padding-left:3rem;">CAS实现原理简述</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#cas实现原子操作三大问题" class="sidebar-link" style="padding-left:3rem;">CAS实现原子操作三大问题</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#_1、aba问题" class="sidebar-link" style="padding-left:4rem;">1、ABA问题</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#_2、循环时间长开销大" class="sidebar-link" style="padding-left:4rem;">2、循环时间长开销大</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#_3、只能保证一个共享变量的原子操作" class="sidebar-link" style="padding-left:4rem;">3、只能保证一个共享变量的原子操作</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#二、锁机制" class="sidebar-link">二、锁机制</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#三大问题小结" class="sidebar-link">三大问题小结</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#顺序一致性-线程同步落地" class="sidebar-link">顺序一致性：线程同步落地</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#顺序一致性内存模型" class="sidebar-link" style="padding-left:3rem;">顺序一致性内存模型</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/base/JMM.html#jmm规范小结" class="sidebar-link">JMM规范小结</a></li></ul></li><li><a href="/blog/java多线程/base/Thread.html" class="sidebar-link">认识 Java 世界的线程</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>三、锁与同步器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>四、JUC</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>五、线程池</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>六、补充</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java并发基石-jmm"><a href="#java并发基石-jmm" class="header-anchor">#</a> Java并发基石——JMM</h1> <p>JMM，Java Memory Model，中文叫 Java内存模型（请注意区分Java内存结构），JMM描述的是一组规范。</p> <p>JMM解决了上篇文章提到的三个并发编程的问题，我们依次来看具体是如何解决的。</p> <h2 id="_1、解决可见性-内存的抽象划分"><a href="#_1、解决可见性-内存的抽象划分" class="header-anchor">#</a> 1、解决可见性：内存的抽象划分</h2> <p>为了解决可见性，JMM提出了两个抽象(并非物理上)的概念：「线程本地内存」和「主存」。每个线程创建时，JVM都会为其分配「线程本地内存」，而用「主存」代表线程共享的所有资源。</p> <p>JMM规定：<strong>线程对共享变量的所有操作都必须在自己的「线程本地内存」中进行，不能直接从「主存」中读取。「线程本地内存」是线程私有的，别的线程无法访问。</strong></p> <p><strong>注意：这不代表「线程本地内存」内的变量别的线程无法拥有。两个「线程本地内存」可以获得来自「主存」的一模一样的变量的副本</strong>。见下图：</p> <img src="data:image/png;base64,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" style="zoom:80%;"> <p>JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证。</p> <blockquote><p>光看图你可能会觉得很简单，但请记住「线程本地内存」的概念是抽象的。并且：</p> <ul><li>「线程本地内存」物理上是什么？</li> <li>JMM具体如何控制「线程本地内存」和「主存」的交互？</li></ul> <p>非常多的问题等着我们去解答。</p></blockquote> <h3 id="线程本地内存的本质"><a href="#线程本地内存的本质" class="header-anchor">#</a> 线程本地内存的本质</h3> <p>「线程本地内存」是JMM提出的一个<strong>抽象的概念，并不真实存在</strong>。</p> <p>在物理层面上，「线程本地内存」涵盖了**缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。**因为硬件这么多，实现各不相同，依赖于硬件是不可靠的，因此需要这一个抽象的概念来表示：<strong>所有由于某种原因导致线程操作的数据不会立即写回到内存，或是通知其它CPU核心，从而造成一致性问题的潜在因素的集合</strong>。</p> <blockquote><p>你可能会说，解决CPU缓存一致性有MESI协议呀，但实际上，上层语言不能完全依赖于硬件提供的某些功能，假如某CPU不支持该协议呢？ 像解决CPU缓存一致性的协议还有：MSI、MOSI、和 Dragon Protocol等等。那Java并发编程在这个硬件上就毫无意义。因此需要JMM来定义这样的规范，从而<strong>屏蔽硬件的不可靠性</strong>。</p></blockquote> <h3 id="java内存模型与内存结构的关系"><a href="#java内存模型与内存结构的关系" class="header-anchor">#</a> Java内存模型与内存结构的关系</h3> <p>如果你学过 JVM，知道「Java内存结构」，是否会将「线程本地内存、主存」的概念和「Java内存结构」的概念拿来比较从而导致有疑问？在此做一个简单的解释。</p> <p>「线程本地内存」是抽象的概念，Java内存结构中线程私有的「栈，程序计数器，本地方法栈」是物理的概念。「栈，程序计数器，本地方法栈」可以被划分到「线程本地内存」，甚至可以不属于「线程本地内存」，尽管只有该线程有访问它们的权限，更不能完全代表「线程本地内存」。</p> <h3 id="本地内存-与-堆"><a href="#本地内存-与-堆" class="header-anchor">#</a> 本地内存 与 堆</h3> <p>你可能会问：<strong>Java线程持有堆对象的引用，那会直接操作堆吗</strong>？</p> <p>堆是 Java 内存结构的一部分，属于共享区域，如果线程直接操作堆，就与JMM冲突了。</p> <p>虽然Java采用直接指针的方式访问对象，但实际上<strong>并不会直接操作堆对象</strong>，毕竟堆也属于内存，也就是JMM的主存区域，Java线程的做法是：<strong>将堆对象拷贝到线程自己的本地内存来进行操作</strong>（如果对象很大只会拷贝一部分）。本地内存确实是线程私有的，但请不要和「JVM运行时数据结构的那些线程私有的栈等」划上等号，本地内存是抽象的。</p> <h3 id="线程本地内存-和-主存-具体如何交互"><a href="#线程本地内存-和-主存-具体如何交互" class="header-anchor">#</a> 线程本地内存 和 主存 具体如何交互</h3> <p>如果你读懂了JMM的内存抽象划分，再加上 Java的并发编程工作模型是「共享内存并发模型」，那你会发现：<strong>线程之间的通信只能通过「主存」来实现</strong>。既然如此，让你来设计一个线程通信的工作模型，你会怎么做呢？</p> <p>比如：线程A希望与线程B通信，它们的本地内存都持有变量 i 的副本，在线程A修改了i后，A必须立刻将变量 i 的值写回到主内存中，并且当线程B要操作变量 i 之前，必须重新从主存中读取变量 i 的值。</p> <p>是不是和你想的一样呢？实际上，Java也确实有一个关键字，volatile，实现了上述功能。实际上，Java关键字的语义往往是复合的，不是只能解决可见性。但本章节主要分析JMM的思想与理论基础，因此留到后文再详细介绍。</p> <h3 id="线程本地内存小结"><a href="#线程本地内存小结" class="header-anchor">#</a> 线程本地内存小结</h3> <p>一个线程无论操作什么数据，包括修改堆对象的某个字段，都是在自己的本地内存上操作的，且不能直接操作主存。并且线程的本地内存是线程私有的，其它线程访问不到。本地内存是抽象的概念。</p> <p>这样规范的原因是：硬件提供缓存一致不可靠，那我们只能认为线程对数据的所有操作都是脏的（线程私有的栈等除外，因为这些内容根本不会写入主存），因为从本地内存写回到主存的时机我们不知道。</p> <h2 id="_2、解决有序性-禁止重排序"><a href="#_2、解决有序性-禁止重排序" class="header-anchor">#</a> 2、解决有序性：禁止重排序</h2> <h3 id="什么是重排序"><a href="#什么是重排序" class="header-anchor">#</a> 什么是重排序</h3> <p>上篇文章已经详细介绍过，这里简单提一下。</p> <p>重排序的概念是：计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。</p> <p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p> <p><img src="data:image/png;base64,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" alt=""></p> <h3 id="jmm重排序的策略"><a href="#jmm重排序的策略" class="header-anchor">#</a> JMM重排序的策略</h3> <p>JMM确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的<strong>内存可见性</strong>保证。</p> <p>读完这句话，会有疑惑吗？为什么明明禁止重排序是解决有序性的，怎么这个作者写了可见性？</p> <p>实际上，<strong>JMM对重排序的策略是：在不改变程序执行结果的前提下，你爱怎么重排序就怎么重排序。即：JMM不保证程序执行的绝对有序性。</strong></p> <p>因此，JMM只处理那些「会导致程序执行结果改变的有序性问题」，其他的不管。那保证了部分有序有什么用？那当然是为了可见性咯。很多场景下，代码之间存在依赖关系。这就像类加载器，如果没有bootstrap，那ext也很难发挥作用，因为ext类加载器的加载依赖于bootstrap。因此，存在依赖关系的代码段，不保证有序性根本就没办法保证可见性，为了解决可见性所做的一切努力都是白费。</p> <blockquote><p>那么JMM如何确定「什么样的重排序会导致程序执行结果改变」呢？实际上，这个问题作为开发者而言不需要关心，JMM贴心的提供了happens-before原则，会在后文详细介绍</p></blockquote> <h3 id="有序性问题的根本-可见性"><a href="#有序性问题的根本-可见性" class="header-anchor">#</a> 有序性问题的根本：可见性</h3> <p>有序性问题的根本还是可见性，即：如果保证了可见性，有序无序又有什么关系呢？</p> <p>上面这段话有点长，可能不太好理解。我们来举个例子：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>看这两行代码，如果进行了重排序，导致行2先于行1执行，<strong>不会对程序的执行结果造成任何影响</strong>。这就是为啥JMM的策略不是直接放弃重排序而保证绝对有序，此时：<strong>程序无序执行根本不是问题</strong>。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>再看这两行代码，我们期望输出值“1”。如果进行了重排序，导致行2先于行1执行，但是行2仍然能够正确输出a为1，那么此时的有序性就不是问题。那如何保证行2在行1执行前能够看到a的值为1呢？<strong>那就是：保证行1先于行2执行，即保证程序执行的有序性，这是保证可见性的前提。</strong></p> <ul><li><strong>只要我们保证行1对行2的可见性，即行2能看到行1的修改，那有序无序无所谓；</strong></li> <li><strong>而要能够让行2看到行1的修改，我们需要让行1先于行2执行，即保证有序性。</strong></li></ul> <p>因此：解决有序性问题，是为了解决有序性背后的可见性问题，这也是为什么JMM提供的happens-before原则，并不会强调有序性，而还是强调内存可见性。</p> <p>现在你应该对有序性问题有了一个比较彻底的认识了，我们来看看JMM限制重排序的具体规则：</p> <h3 id="jmm限制重排序的具体规则"><a href="#jmm限制重排序的具体规则" class="header-anchor">#</a> JMM限制重排序的具体规则</h3> <p>我们之前说过：限制部分重排序需要解决：「如何确定什么样的重排序会导致程序执行结果改变」这样一个问题。如果将这个问题抛给开发者，会是一件令人十分头疼的事情，因此JMM提供了happens-before规则。</p> <p>JMM保障：只要你按照happens-before规则写代码，就能写出<strong>执行结果与你预期相符</strong>的代码，不需要关心会发生什么重排序以及如何限制重排序等等问题。</p> <h4 id="happens-before规则"><a href="#happens-before规则" class="header-anchor">#</a> happens-before规则</h4> <p>happens-before规则是面向程序员的，这个规则屏蔽了对多个编译器和处理器的具体重排序规则，更强调结果，后续部分内容将happens-before简写为h-b。</p> <p>happens-before关系的定义如下：</p> <ol><li>如果一个操作happens-before另一个操作，那么<strong>第一个操作的执行结果将对第二个操作可见</strong>。</li> <li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。</li></ol> <p>可以看到，happens-before规则保证的是可见性，而不保证有序性。</p> <blockquote><p>尽管你也可以理解成happens-before规则保证了有序性，多了这样一个假设，不会对你的代码的执行结果有任何影响，但事实上happens-before就是没有保证绝对有序性，只通过保证部分有序性再保证可见性</p></blockquote> <p><strong>happens-before的具体规则如下：</strong></p> <ul><li><strong>一个线程中的每个操作</strong>，先执行的操作 happen-before 后执行的操作</li> <li>监视器锁的解锁<code>happens-before</code>加锁</li> <li>对一个<code>volatile</code>域的写，<code>happens-before</code>于任意后续对这个<code>volatile</code>域的读</li> <li>thread.start方法<code>happens-before</code>该线程的所有操作</li> <li>在线程A中调用B.join()，<code>happens-before</code>线程A后续的所有操作</li> <li>interrupt方法<code>happens-before</code> Thread.isInterrupted 之前</li> <li><code>happens-before</code>具有传递性</li></ul> <p>上述规则中，只有第一条是针对一个线程内的，其余规则都适用于多线程的场景。</p> <p>happens-before既可以理解为JMM的一种规范，即上述所有规则的集合，也可以理解为两个操作之间的一种关系，即h-b规则的集合的某一条，A happens-before B就代表A的所有操作对B可见。</p> <h5 id="as-if-serial-单线程语义的保证"><a href="#as-if-serial-单线程语义的保证" class="header-anchor">#</a> as if serial：单线程语义的保证</h5> <p><strong>as if serial只针对单线程</strong>，具体是：<strong>一个线程内的指令，虽然允许重排序，但是保证执行结果唯一，且与没有任何重排序的执行结果完全一致。</strong></p> <blockquote><p>as if serial本质就是happens-before中的一条特殊规则，由于仅仅as if serial是针对单线程的，因此作者们总时特地拿出来讲并有个响亮的名号叫as if serial</p></blockquote> <h3 id="happens-before理解实战"><a href="#happens-before理解实战" class="header-anchor">#</a> happens-before理解实战</h3> <p>下面举一些例子来帮助你彻底理解happens-before原则，如果答案和你预想的不一样，说明你对happens-before原则的掌握还不够透彻。</p> <blockquote><p>对一个<code>volatile</code>域的写，<code>happens-before</code>于任意后续对这个<code>volatile</code>域的读</p> <p>另外，<code>volatile</code>关键字也保证了可见性。</p></blockquote> <p>看这样一个场景，请问输出的a会是0还是1？</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token comment">// 线程A</span>
<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 线程B</span>
<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>答案是并不确定。你会说：不是规定了<strong>对volatile域的happens-before 对volatile域的读，所以线程B的所有操作对线程A可见嘛</strong>？难道这原则有问题？别忘了CPU的调度，CPU先给读线程分配时间片，此时就读到了0。那这个happens-before规则到底规定了啥呢？一旦CPU先给写线程分配了时间片，执行完了<code>a = 1</code>这条写操作以后，任何的读操作都能读到 a 为1，而不会出现可见性问题。</p> <p>再看一个例子，会有输出吗？</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   
		<span class="token comment">// 线程1</span>
		<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 		<span class="token comment">// 线程2</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>也是一样的，并不一定会输出a。但如果我们保证线程2先于线程1执行，那就一定会有输出</p> <p>到这里，相信你对happens-before原则了解的差不多了，那其实对JMM解决有序性的问题就了解的比较透彻了。我们再来看一些别的次要一些的问题。</p> <h3 id="禁止重排序的方法-内存屏障"><a href="#禁止重排序的方法-内存屏障" class="header-anchor">#</a> 禁止重排序的方法：内存屏障</h3> <p>JMM具体是如何限制重排序的？内存屏障：memory barriers，用于禁止某些指令重排序</p> <p>JMM一共有如下四种内存屏障：</p> <table><thead><tr><th>屏障类型</th> <th>指令示例</th> <th>说明</th></tr></thead> <tbody><tr><td>LoadLoad Barriers</td> <td>Load1; LoadLoad; Load2</td> <td>确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。</td></tr> <tr><td>StoreStore Barriers</td> <td>Store1; StoreStore; Store2</td> <td>确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td></tr> <tr><td>LoadStore Barriers</td> <td>Load1; LoadStore; Store2</td> <td>确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td></tr> <tr><td>StoreLoad Barriers</td> <td>Store1; StoreLoad; Load2</td> <td>确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。</td></tr></tbody></table> <blockquote><p>Load可以理解为从内存读，相对的Store就是向内存写</p></blockquote> <p>我个人认为，普通的Java开发人员没有必要深入理解内存屏障，比如了解：为了实现volatile具体使用了哪些内存屏障？因为happens-before的存在就是为了帮助你屏蔽掉具体的内存屏障的。</p> <h3 id="猜测执行"><a href="#猜测执行" class="header-anchor">#</a> 猜测执行</h3> <p>编译器和处理器会采用<strong>猜测执行（Speculation）</strong>。比如：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>     
	 <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>
   	 <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">*</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>由于某种原因，比如上述代码，没有可能将flag修改为false，因此CPU猜测会执行输出<code>a*a</code>，于是：尽管if 与 {}之间存在依赖关系，但仍可以提前读取并计算a*a，然后把计算结果临时保存到一个名为**重排序缓冲（Reorder Buffer，ROB）**的硬件缓存中。像这样的代码，是特殊的，但对于程序员是透明的，并不影响我们的程序的执行结果。</p> <h2 id="_3、解决原子性-cas与锁"><a href="#_3、解决原子性-cas与锁" class="header-anchor">#</a> 3、解决原子性：CAS与锁</h2> <p>Java解决原子性问题，没有之一的最核心的机制是：CAS。</p> <h3 id="一、cas-compare-and-swap"><a href="#一、cas-compare-and-swap" class="header-anchor">#</a> 一、CAS ：Compare and Swap</h3> <p>CAS：Compare and Swap，比较并交换。用于<strong>在硬件层面上提供原子性操作</strong>。在 Intel 处理器中，CAS通过指令<code>cmpxchg</code>实现。 比较是否和给定的数值一致，如果一致则修改，不一致则不修改。</p> <p>CAS有如下三个变量</p> <ul><li>V：要更新的变量(var)</li> <li>E：预期值(expected) 就是旧值</li> <li>N：新值(new)</li></ul> <p>CAS操作：判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。</p> <p>当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p> <h4 id="cas实现原理简述"><a href="#cas实现原理简述" class="header-anchor">#</a> CAS实现原理简述</h4> <p>CAS凭啥能保证原子性呢？会不会出现两个线程同时做CAS并发现<code>Var = Eepected</code>，然后同时修改呢？</p> <p>CAS是一条CPU的原子指令，是CPU层面保证的。Linux的X86下主要是通过<code>cmpxchgl</code>这个指令，但在多处理器情况下必须使用<code>lock</code>指令加锁来完成。不同的操作系统和处理器的实现各不相同。</p> <h4 id="cas实现原子操作三大问题"><a href="#cas实现原子操作三大问题" class="header-anchor">#</a> CAS实现原子操作三大问题</h4> <h5 id="_1、aba问题"><a href="#_1、aba问题" class="header-anchor">#</a> 1、ABA问题</h5> <p>A-&gt;B-&gt;A，CAS检查不出变化。</p> <p>ABA问题的本质是：一次CAS的旧值与另一次CAS的新值完全一样。</p> <p>因此我们可以：加上<strong>版本号或者时间戳</strong>。</p> <p>JUC解决ABA问题：AtomicStampedReference，添加了时间戳</p> <h5 id="_2、循环时间长开销大"><a href="#_2、循环时间长开销大" class="header-anchor">#</a> 2、循环时间长开销大</h5> <p>如果自旋CAS长时间不成功，会占用大量的CPU资源。</p> <p>让JVM支持处理器提供的<strong>pause指令</strong></p> <h5 id="_3、只能保证一个共享变量的原子操作"><a href="#_3、只能保证一个共享变量的原子操作" class="header-anchor">#</a> 3、只能保证一个共享变量的原子操作</h5> <p>如果要保证多个变量的操作的原子性，CAS就无能为力了。我们有两种解决方案：</p> <ul><li>锁机制，保证临界区的代码只有一个线程可以执行</li> <li>使用JDK 1.5提供的<code>AtomicReference</code>类保证对象的原子性，把多个变量放到一个对象里面进行CAS操作；</li></ul> <h3 id="二、锁机制"><a href="#二、锁机制" class="header-anchor">#</a> 二、锁机制</h3> <p>除了偏向锁，JVM实现锁的方式都用了循环CAS，也就是几乎所有的Java的锁实现都依赖于CAS操作。后文分析synchronized与lock时会体现出如何用CAS来实现锁的。</p> <p>Java主要提供了关键字synchronized和接口Lock用于实现锁机制。</p> <h3 id="三大问题小结"><a href="#三大问题小结" class="header-anchor">#</a> 三大问题小结</h3> <p>到这里我们就分别解决了并发编程的三大问题，但还没有实现基本的功能：<strong>显式同步，隐式通信</strong>。Java提供了若干同步的方式，在本章节不希望具体到某一种同步方式，而是所有的同步方式。即对于开发者而言，我们更希望关注线程间具体如何同步，那么在正确同步的代码，JMM又提供了什么样的保证呢？</p> <h2 id="顺序一致性-线程同步落地"><a href="#顺序一致性-线程同步落地" class="header-anchor">#</a> 顺序一致性：线程同步落地</h2> <p>顺序一致性内存模型是一个理论参考模型，通常CPU，编程语言的内存模型的设计都会参考顺序一致性内存模型。</p> <p>**JMM保证：如果程序是正确同步的，那么执行结果与该程序在顺序一致性内存模型中的执行结果相同。**看的一脸懵？什么是顺序一致性模型？下面我们来帮助你理解这句话的含义：</p> <h4 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="header-anchor">#</a> 顺序一致性内存模型</h4> <p>顺序一致性内存模型具体是如下两条：</p> <ul><li>一个线程中的所有操作必须按照程序的顺序来执行</li> <li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须<strong>原子执行且立刻对所有线程可见</strong>。</li></ul> <p>可以看到，顺序一致性模型保证了：<strong>每个操作的原子性、可见性，以及单线程内所有操作的绝对有序性</strong>。也就是说，只要程序正确同步，我们完全可以将多线程的执行理解成一个单一的操作执行顺序，所有操作原子，立即可见，且严格按照顺序执行。这是一个非常强力的保证。这使得开发者能够更加关注「同步的正确性」，而非总是为了「隐式通信」而担忧。</p> <h2 id="jmm规范小结"><a href="#jmm规范小结" class="header-anchor">#</a> JMM规范小结</h2> <p>JMM是Java提出的实现并发编程的规范，提供两个基础功能：</p> <ul><li>线程通信</li> <li>线程同步</li></ul> <p>并采用了显式同步，隐式通信的模型实现上述功能。</p> <p>同时为了克服硬件，操作系统等等带来的不确定性：</p> <ul><li>规定了线程本地内存与主存来解决变量的<strong>可见性</strong></li> <li>提供happens-before规则，通过插入内存屏障从而限制重排序来解决程序执行的<strong>有序性</strong></li> <li>通过CAS与锁机制(锁的实现也依赖于CAS)来解决程序执行的<strong>原子性</strong></li></ul> <p>至此，整个JMM就讲解完毕了。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/java多线程/base/Base.html" class="prev">
        多线程基础知识
      </a></span> <span class="next"><a href="/blog/java多线程/base/Thread.html">
        认识 Java 世界的线程
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.7b9df32b.js" defer></script><script src="/blog/assets/js/2.be714ec7.js" defer></script><script src="/blog/assets/js/1.26c7c9cc.js" defer></script><script src="/blog/assets/js/27.56a57551.js" defer></script>
  </body>
</html>
