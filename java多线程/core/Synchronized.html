<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>synchronized关键字详解 | lun&#39;s blogs</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/blog/favicon.ico">
    <meta name="description" content="blog">
    
    <link rel="preload" href="/blog/assets/css/0.styles.56f5eb6c.css" as="style"><link rel="preload" href="/blog/assets/js/app.7b9df32b.js" as="script"><link rel="preload" href="/blog/assets/js/2.be714ec7.js" as="script"><link rel="preload" href="/blog/assets/js/1.26c7c9cc.js" as="script"><link rel="preload" href="/blog/assets/js/29.f71b59d6.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.0d71bf2e.js"><link rel="prefetch" href="/blog/assets/js/11.cc81c248.js"><link rel="prefetch" href="/blog/assets/js/12.5e69cd14.js"><link rel="prefetch" href="/blog/assets/js/13.f0bc7bf2.js"><link rel="prefetch" href="/blog/assets/js/14.0188e855.js"><link rel="prefetch" href="/blog/assets/js/15.48a1e71e.js"><link rel="prefetch" href="/blog/assets/js/16.0f4182c9.js"><link rel="prefetch" href="/blog/assets/js/17.ec7b8f9d.js"><link rel="prefetch" href="/blog/assets/js/18.776522e2.js"><link rel="prefetch" href="/blog/assets/js/19.26561e06.js"><link rel="prefetch" href="/blog/assets/js/20.3e42feda.js"><link rel="prefetch" href="/blog/assets/js/21.fd4e7a00.js"><link rel="prefetch" href="/blog/assets/js/22.b59f6079.js"><link rel="prefetch" href="/blog/assets/js/23.e6b2d3ec.js"><link rel="prefetch" href="/blog/assets/js/24.736cfa99.js"><link rel="prefetch" href="/blog/assets/js/25.91176041.js"><link rel="prefetch" href="/blog/assets/js/26.146e299c.js"><link rel="prefetch" href="/blog/assets/js/27.56a57551.js"><link rel="prefetch" href="/blog/assets/js/28.13a846a1.js"><link rel="prefetch" href="/blog/assets/js/3.f34ea2f7.js"><link rel="prefetch" href="/blog/assets/js/30.bf0626f9.js"><link rel="prefetch" href="/blog/assets/js/31.47592684.js"><link rel="prefetch" href="/blog/assets/js/32.63f20fc3.js"><link rel="prefetch" href="/blog/assets/js/33.4852d9ec.js"><link rel="prefetch" href="/blog/assets/js/34.4f467138.js"><link rel="prefetch" href="/blog/assets/js/35.17d26444.js"><link rel="prefetch" href="/blog/assets/js/36.d0059312.js"><link rel="prefetch" href="/blog/assets/js/37.fc856e5d.js"><link rel="prefetch" href="/blog/assets/js/38.dc6b373c.js"><link rel="prefetch" href="/blog/assets/js/39.f04e5b6a.js"><link rel="prefetch" href="/blog/assets/js/4.885368ff.js"><link rel="prefetch" href="/blog/assets/js/40.b378efa5.js"><link rel="prefetch" href="/blog/assets/js/41.3c800d8a.js"><link rel="prefetch" href="/blog/assets/js/42.8b804f0c.js"><link rel="prefetch" href="/blog/assets/js/43.832aa078.js"><link rel="prefetch" href="/blog/assets/js/44.d1121c11.js"><link rel="prefetch" href="/blog/assets/js/45.b3e8ede1.js"><link rel="prefetch" href="/blog/assets/js/46.01e4202b.js"><link rel="prefetch" href="/blog/assets/js/47.489850e9.js"><link rel="prefetch" href="/blog/assets/js/48.3bd88d5f.js"><link rel="prefetch" href="/blog/assets/js/49.08c6f759.js"><link rel="prefetch" href="/blog/assets/js/5.d1dbc0b1.js"><link rel="prefetch" href="/blog/assets/js/50.c900e52a.js"><link rel="prefetch" href="/blog/assets/js/51.a59d8fbf.js"><link rel="prefetch" href="/blog/assets/js/52.0c715d23.js"><link rel="prefetch" href="/blog/assets/js/53.07715a2f.js"><link rel="prefetch" href="/blog/assets/js/54.e0d8cc69.js"><link rel="prefetch" href="/blog/assets/js/55.1efa3b0b.js"><link rel="prefetch" href="/blog/assets/js/56.ace3e6e3.js"><link rel="prefetch" href="/blog/assets/js/57.221667c1.js"><link rel="prefetch" href="/blog/assets/js/58.a786e5bd.js"><link rel="prefetch" href="/blog/assets/js/59.8a6dde26.js"><link rel="prefetch" href="/blog/assets/js/6.7ee6eed6.js"><link rel="prefetch" href="/blog/assets/js/60.0192f277.js"><link rel="prefetch" href="/blog/assets/js/61.75813485.js"><link rel="prefetch" href="/blog/assets/js/62.d8de1a01.js"><link rel="prefetch" href="/blog/assets/js/63.a08485a4.js"><link rel="prefetch" href="/blog/assets/js/64.7d19f572.js"><link rel="prefetch" href="/blog/assets/js/65.3f290d9a.js"><link rel="prefetch" href="/blog/assets/js/66.73f49082.js"><link rel="prefetch" href="/blog/assets/js/67.cb22e678.js"><link rel="prefetch" href="/blog/assets/js/68.22dc7228.js"><link rel="prefetch" href="/blog/assets/js/69.1f450482.js"><link rel="prefetch" href="/blog/assets/js/7.153b9c62.js"><link rel="prefetch" href="/blog/assets/js/70.03205c0b.js"><link rel="prefetch" href="/blog/assets/js/71.5b98edf5.js"><link rel="prefetch" href="/blog/assets/js/72.8be00756.js"><link rel="prefetch" href="/blog/assets/js/73.5e60394c.js"><link rel="prefetch" href="/blog/assets/js/74.a1100b64.js"><link rel="prefetch" href="/blog/assets/js/75.b47153bc.js"><link rel="prefetch" href="/blog/assets/js/76.b881f0b9.js"><link rel="prefetch" href="/blog/assets/js/77.eef60dd8.js"><link rel="prefetch" href="/blog/assets/js/78.b52fa32f.js"><link rel="prefetch" href="/blog/assets/js/79.9adc486f.js"><link rel="prefetch" href="/blog/assets/js/80.10b21516.js"><link rel="prefetch" href="/blog/assets/js/81.12c11cbc.js"><link rel="prefetch" href="/blog/assets/js/82.df4ae15b.js"><link rel="prefetch" href="/blog/assets/js/83.078b9ed6.js"><link rel="prefetch" href="/blog/assets/js/84.2d8ccb46.js"><link rel="prefetch" href="/blog/assets/js/85.4d5e44f4.js"><link rel="prefetch" href="/blog/assets/js/86.c32dda95.js"><link rel="prefetch" href="/blog/assets/js/87.c28d1f54.js"><link rel="prefetch" href="/blog/assets/js/88.c06457bb.js"><link rel="prefetch" href="/blog/assets/js/89.1febc082.js"><link rel="prefetch" href="/blog/assets/js/90.37985dbe.js"><link rel="prefetch" href="/blog/assets/js/91.9c3ebd93.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.02634ae8.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.56f5eb6c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="lun's blogs" class="logo"> <span class="site-name can-hide">lun's blogs</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/base/Exception.html" class="nav-link">
  异常
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Generics.html" class="nav-link">
  泛型
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Enum.html" class="nav-link">
  枚举
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Serialize.html" class="nav-link">
  Java序列化机制详解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Proxy.html" class="nav-link">
  动态代理
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Annotation.html" class="nav-link">
  深入理解Java注解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream1.html" class="nav-link">
  Stream源码分析(上)
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream2.html" class="nav-link">
  Stream源码分析(下)
</a></li></ul></div></div><div class="nav-item"><a href="/blog/java多线程/" class="nav-link">
  Java多线程
</a></div><div class="nav-item"><a href="/blog/jvm/" class="nav-link">
  JVM
</a></div><div class="nav-item"><a href="/blog/redis/" class="nav-link">
  Redis
</a></div><div class="nav-item"><a href="/blog/blogs/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="https://juejin.cn/user/2159878519134157" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/base/Exception.html" class="nav-link">
  异常
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Generics.html" class="nav-link">
  泛型
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Enum.html" class="nav-link">
  枚举
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Serialize.html" class="nav-link">
  Java序列化机制详解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Proxy.html" class="nav-link">
  动态代理
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Annotation.html" class="nav-link">
  深入理解Java注解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream1.html" class="nav-link">
  Stream源码分析(上)
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream2.html" class="nav-link">
  Stream源码分析(下)
</a></li></ul></div></div><div class="nav-item"><a href="/blog/java多线程/" class="nav-link">
  Java多线程
</a></div><div class="nav-item"><a href="/blog/jvm/" class="nav-link">
  JVM
</a></div><div class="nav-item"><a href="/blog/redis/" class="nav-link">
  Redis
</a></div><div class="nav-item"><a href="/blog/blogs/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="https://juejin.cn/user/2159878519134157" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" aria-current="page" class="sidebar-link">一、前言</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>二、Java并发基础知识</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>三、锁与同步器</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java多线程/core/Volatile.html" class="sidebar-link">volatile 关键字详解</a></li><li><a href="/blog/java多线程/core/Synchronized.html" class="active sidebar-link">synchronized关键字详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#synchronized基本使用" class="sidebar-link">synchronized基本使用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#_1、修饰普通方法-锁this" class="sidebar-link" style="padding-left:3rem;">1、修饰普通方法：锁this</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#_2、修饰静态方法-锁this-class" class="sidebar-link" style="padding-left:3rem;">2、修饰静态方法：锁this.class</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#_3、同步代码块-自定义锁对象" class="sidebar-link" style="padding-left:3rem;">3、同步代码块：自定义锁对象</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#锁与h-b规则的联系" class="sidebar-link">锁与h-b规则的联系</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#synchronized的内存语义" class="sidebar-link">synchronized的内存语义</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#synchronized实现原理" class="sidebar-link">synchronized实现原理</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#透过字节码看异常如何释放锁" class="sidebar-link">透过字节码看异常如何释放锁</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#四种锁状态" class="sidebar-link">四种锁状态</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#_1、无锁" class="sidebar-link">1、无锁</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#_2、偏向锁-jdk15被废弃" class="sidebar-link">2、偏向锁（JDK15被废弃）</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#_3、轻量级锁" class="sidebar-link">3、轻量级锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#轻量级锁会自旋吗" class="sidebar-link">轻量级锁会自旋吗</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#自旋的说法从何而来" class="sidebar-link" style="padding-left:3rem;">自旋的说法从何而来</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#看源码来考证说法的正确性" class="sidebar-link" style="padding-left:3rem;">看源码来考证说法的正确性</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#轻量级锁实现原理" class="sidebar-link">轻量级锁实现原理</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#获取锁" class="sidebar-link" style="padding-left:3rem;">获取锁</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#释放锁" class="sidebar-link" style="padding-left:3rem;">释放锁</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#_4、重量级锁" class="sidebar-link">4、重量级锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#重量级锁的生成-锁膨胀" class="sidebar-link" style="padding-left:3rem;">重量级锁的生成/锁膨胀</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#重量级锁实现原理" class="sidebar-link">重量级锁实现原理</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#获取锁-2" class="sidebar-link">获取锁</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#_1、自旋锁" class="sidebar-link" style="padding-left:3rem;">1、自旋锁</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#自适应自旋" class="sidebar-link" style="padding-left:4rem;">自适应自旋</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#自旋逻辑-tryspin" class="sidebar-link" style="padding-left:4rem;">自旋逻辑：trySpin</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#_2、死循环" class="sidebar-link" style="padding-left:3rem;">2、死循环</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#唤醒的时机" class="sidebar-link" style="padding-left:4rem;">唤醒的时机</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#cxq和entrylist内线程的行为" class="sidebar-link" style="padding-left:4rem;">cxq和EntryList内线程的行为</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#释放锁-2" class="sidebar-link">释放锁</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#为什么要区分cxq和entrylist" class="sidebar-link" style="padding-left:3rem;">为什么要区分cxq和EntryList</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#_1、提高性能" class="sidebar-link" style="padding-left:4rem;">1、提高性能</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#_2、解决aba问题" class="sidebar-link" style="padding-left:4rem;">2、解决ABA问题</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#可感知的锁控制权" class="sidebar-link">可感知的锁控制权</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#锁状态的降级" class="sidebar-link">锁状态的降级</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#编译器对-synchronized-的优化" class="sidebar-link">编译器对 synchronized 的优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#_1、锁消除" class="sidebar-link" style="padding-left:3rem;">1、锁消除</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#_2、锁粗化" class="sidebar-link" style="padding-left:3rem;">2、锁粗化</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#synchronized-与包装类的坑" class="sidebar-link">synchronized 与包装类的坑</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#小结" class="sidebar-link">小结</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/core/Synchronized.html#参考文献" class="sidebar-link">参考文献</a></li></ul></li></ul></li><li><a href="/blog/java多线程/core/WaitNotify.html" class="sidebar-link">显示同步：wait/notify</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>四、JUC</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>五、线程池</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>六、补充</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="synchronized关键字详解"><a href="#synchronized关键字详解" class="header-anchor">#</a> synchronized关键字详解</h1> <h2 id="synchronized基本使用"><a href="#synchronized基本使用" class="header-anchor">#</a> synchronized基本使用</h2> <p>一般有三种方式：</p> <h4 id="_1、修饰普通方法-锁this"><a href="#_1、修饰普通方法-锁this" class="header-anchor">#</a> 1、修饰普通方法：锁this</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code>  <span class="token comment">// 1. synchronized用在普通方法上，默认的锁就是this，当前实例</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="_2、修饰静态方法-锁this-class"><a href="#_2、修饰静态方法-锁this-class" class="header-anchor">#</a> 2、修饰静态方法：锁this.class</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code>  <span class="token comment">// 2. synchronized用在静态方法上，默认的锁就是当前所在的Class类</span>
  <span class="token comment">// 所以无论是哪个线程访问它，需要的锁都只有一把</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="_3、同步代码块-自定义锁对象"><a href="#_3、同步代码块-自定义锁对象" class="header-anchor">#</a> 3、同步代码块：自定义锁对象</h4> <p>自定义锁对象可以是实例，也可以是Class对象</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">SynchronizedObjectLock</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>无论正常退出还是抛出异常，synchronized都保证能够释放锁。</p></blockquote> <h3 id="锁与h-b规则的联系"><a href="#锁与h-b规则的联系" class="header-anchor">#</a> 锁与h-b规则的联系</h3> <p>我们知道，<strong>解锁操作 happens-before 加锁</strong>，因此：</p> <p>首先有个变量a，没有用volatile修饰</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>线程A先执行：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 1</span>
		a<span class="token operator">++</span><span class="token punctuation">;</span> 						<span class="token comment">// 2</span>
<span class="token punctuation">}</span> 									<span class="token comment">// 3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>线程B后执行：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 4</span>
		<span class="token keyword">int</span> i <span class="token operator">=</span> a<span class="token punctuation">;</span> 					<span class="token comment">// 5</span>
<span class="token punctuation">}</span> 									<span class="token comment">// 6 </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>由h-b规则，3 h-b 4，再由as if serial和传递性原则，因此2 h-b 5，而h-b从开发人员的角度来说，你就可以理解为2在5之前执行，并且2的结果对5可见，因此5处读到的a，一定为1。</p> <h3 id="synchronized的内存语义"><a href="#synchronized的内存语义" class="header-anchor">#</a> synchronized的内存语义</h3> <ul><li>当线程<strong>释放锁</strong>时，JMM会把该线程对应的<strong>本地内存中的共享变量刷新到主内存</strong>中。</li> <li>当线程获取锁时，JMM会把该线程对应的本地内存置为无效</li></ul> <p>可以看到：</p> <p>锁释放与volatile写有相同的内存语义；</p> <p>锁获取与volatile读有相同的内存语义。</p> <h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="header-anchor">#</a> synchronized实现原理</h2> <p>我个人非常推荐的一篇文字是：<a href="https://github.com/farmerjohngit/myblog/issues/12" target="_blank" rel="noopener noreferrer">死磕Synchronized底层实现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，是对着源码讲的，但也比较难啃。</p> <p>下面我用尽量清晰简洁，绕过虚拟机源码的方式来讲一下：</p> <blockquote><p>会跳过一些源码细节的实现，不会影响整体流程和理解</p></blockquote> <p>首先了解实现原理，第一步我会先看一下字节码指令：</p> <h2 id="透过字节码看异常如何释放锁"><a href="#透过字节码看异常如何释放锁" class="header-anchor">#</a> 透过字节码看异常如何释放锁</h2> <p>synchronized修饰的方法会被加上 <code>ACC_SYNCHRONIZED</code> 的flag。</p> <p>而同步代码块的字节码文件是这样的：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>monitorenter	
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
monitorexit	
<span class="token keyword">goto</span> xxx
monitorexit
athrow
<span class="token keyword">return</span>
 <span class="token class-name">Exception</span> table<span class="token operator">:</span>
from   <span class="token keyword">to</span>  <span class="token namespace">target</span> type
 <span class="token number">4</span>     <span class="token number">14</span>    <span class="token number">17</span>    any
 <span class="token number">17</span>    <span class="token number">20</span>    <span class="token number">17</span>    any
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>可以看到，<code>monitorenter</code>和<code>monitorexit</code>指令分别对应<code>synchronized</code>同步块的进入和退出。</p> <p>有两个monitorexit，因为<strong>javac为同步代码块添加了一个隐式的try-finally，在finally中会调用<code>monitorexit</code>命令释放锁</strong>。</p> <p>尽管字节码通常都能帮助我们更好地理解语义，但关于synchronized的语义也就到此为止了，接下来就要深入虚拟机源码看看monitorenter（获取锁）和monitorexit（释放锁）到底都干了些什么，不过在此之前：</p> <p>因为synchronized有四种锁状态，而锁状态的实现依赖于Java对象的mark word，这是实现synchronized的基础，我们先来看mark word如何表达锁状态的。</p> <blockquote><p><strong>Java中的每一个对象都可以作为一个锁，包括Class对象</strong>。</p></blockquote> <h2 id="四种锁状态"><a href="#四种锁状态" class="header-anchor">#</a> 四种锁状态</h2> <p>Java对象头的mark word表达了这四种状态，如下：</p> <table><thead><tr><th>锁状态</th> <th>29 bit 或 61 bit</th> <th>1 bit 是否是偏向锁？</th> <th>2 bit 锁标志位</th></tr></thead> <tbody><tr><td>无锁</td> <td></td> <td>0</td> <td>01</td></tr> <tr><td>偏向锁</td> <td>线程ID</td> <td>1</td> <td>01</td></tr> <tr><td>轻量级锁</td> <td>指向栈中锁记录的指针</td> <td>此时这一位不用于标识偏向锁</td> <td>00</td></tr> <tr><td>重量级锁</td> <td>指向互斥量（重量级锁）的指针</td> <td>此时这一位不用于标识偏向锁</td> <td>10</td></tr> <tr><td>GC标记</td> <td></td> <td>此时这一位不用于标识偏向锁</td> <td>11</td></tr></tbody></table> <blockquote><p>注意轻/重锁的mark word内是持有一个指向锁记录的指针的。</p></blockquote> <p>因此，一个对象其实有四种锁状态,级别由低到高:</p> <ol><li>无锁状态</li> <li>偏向锁状态</li> <li>轻量级锁状态</li> <li>重量级锁状态</li></ol> <h2 id="_1、无锁"><a href="#_1、无锁" class="header-anchor">#</a> 1、无锁</h2> <p>释放轻量级锁，没有线程在尝试获取锁，也没有线程持有锁（正在执行同步代码块），就是无锁。</p> <h2 id="_2、偏向锁-jdk15被废弃"><a href="#_2、偏向锁-jdk15被废弃" class="header-anchor">#</a> 2、偏向锁（JDK15被废弃）</h2> <blockquote><p>偏向锁在JDK1.6引入，在JDK15被废弃，了解即可。如果一定要用，需要手动打开：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UseBiasedLocking</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></blockquote> <p>人们发现大多数情况下<strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，于是有了偏向锁。</p> <p>偏向锁顾名思义，偏向于第一个访问锁的线程。偏向锁在<strong>资源无竞争</strong>情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。</p> <p>当开启偏向锁功能时，创建的新对象是可偏向状态，此时mark word中的thread id为0，也叫做匿名偏向。当该对象第一次被CAS成功时，成为「偏向锁」。</p> <p>在该线程又一次尝试获取该对象锁时，发现thread id就是自己，就可以不做CAS直接认为已经拿到了锁并执行同步代码块中的代码。</p> <blockquote><p>注意上述的所有，都只出现了一个线程</p></blockquote> <p><strong>当第二个线程出现并尝试获取锁，无论如何都会升级成「轻量级锁」。</strong></p> <ul><li>如果第一个线程正在执行同步代码块，锁偏向的线程继续拥有锁，当前线程升级该锁为「轻量级锁」。</li> <li>如果第一个线程不在执行同步代码块，先将对象头的<code>mark word</code>改为无锁状态，再升级为「轻量级锁」。</li></ul> <p><strong>也就是是要有两个线程尝试获取锁，不论是否出现资源竞争，升级为「轻量级锁」</strong>。</p> <blockquote><p>当然这个说法不绝对，因为还有批量重偏向这一机制。但从了解的角度，到这就可以了</p></blockquote> <h2 id="_3、轻量级锁"><a href="#_3、轻量级锁" class="header-anchor">#</a> 3、轻量级锁</h2> <p>升级到「轻量级锁」的条件是：存在多个线程尝试CAS获取同一把锁，尽管彼此之间互不影响。而「轻量级锁」继续膨胀为「重量级锁」的条件是：只要CAS失败，就升级，即发生了：一个线程正在执行同步代码块的同时，另一个线程尝试获取锁。</p> <h3 id="轻量级锁会自旋吗"><a href="#轻量级锁会自旋吗" class="header-anchor">#</a> 轻量级锁会自旋吗</h3> <p>自旋：不断尝试去获取锁，一般用循环来实现。</p> <p>一个常见的说法是：轻量级锁会自旋10次，失败则升级为重量级锁。</p> <p>但 Java 8 就已经不会自旋了。</p> <h4 id="自旋的说法从何而来"><a href="#自旋的说法从何而来" class="header-anchor">#</a> 自旋的说法从何而来</h4> <p>《Java并发编程的艺术》(2015)原文是：</p> <blockquote><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p></blockquote> <p>《深入浅出Java多线程1.0.0》原文是：</p> <blockquote><p>然后线程尝试用CAS将锁的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。</p></blockquote> <p>总之，以上两位作者认为会发生自旋。</p> <p>《深入理解Java虚拟机》(2019)原文是：</p> <blockquote><p>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态值变为“10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。</p></blockquote> <p>周志明大大的意思是：出现两条以上的线程争用同一个锁的情况，就要升级为重量级锁</p> <p>显然，这两种观点是有冲突的，核心问题在于：</p> <p><strong>轻量级锁状态下，发生资源竞争，到底是自旋，还是立刻锁膨胀？</strong></p> <h4 id="看源码来考证说法的正确性"><a href="#看源码来考证说法的正确性" class="header-anchor">#</a> 看源码来考证说法的正确性</h4> <p>那么我们也只能自己去验证说法的正确性了。</p> <p>相关的资料推荐：</p> <ul><li>文章：<a href="https://www.imooc.com/article/323412" target="_blank" rel="noopener noreferrer">Synchronized轻量级锁会自旋？好像并不是这样的<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>视频：<a href="https://space.bilibili.com/416747307/channel/collectiondetail?sid=1389015" target="_blank" rel="noopener noreferrer">为锁正名<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="轻量级锁实现原理"><a href="#轻量级锁实现原理" class="header-anchor">#</a> 轻量级锁实现原理</h3> <h4 id="获取锁"><a href="#获取锁" class="header-anchor">#</a> 获取锁</h4> <ol><li><p>发现是无锁状态，线程会<strong>把锁的Mark Word复制到自己的Displaced Mark Word（栈帧中的一块空间）</strong>，然后通过CAS尝试将锁的Mark Word修改为一根指针，指向自己的Displaced Mark Word（Displaced Mark Word与原mark word的内容一模一样）</p></li> <li><p>发现处于轻量级锁状态</p> <ul><li>如果轻量级锁的markword指向自己的Displaced Mark Word，代表重入锁，那么获取锁成功（如果是重入，会将markword改为null，空指针，即0）</li> <li>如果轻量级锁的markword不是指向自己，锁膨胀，升级为「重量级锁」</li></ul></li></ol> <h4 id="释放锁"><a href="#释放锁" class="header-anchor">#</a> 释放锁</h4> <p>首先，遍历线程栈，拿到所有需要做解锁操作的锁对象：</p> <ol><li>如果是null，代表可重入的锁，直接解锁成功</li> <li>如果不是重入的锁：
<ul><li>如果markword被修改，说明发生了竞争，已经成为「重量级锁」了，「尝试解锁重量级锁」</li> <li>如果markword没被修改，尝试CAS还原对象的markword
<ul><li>还原成功，轻量级锁解锁成功</li> <li>还原失败，仍然是「尝试解锁重量级锁」</li></ul></li></ul></li></ol> <blockquote><p>补充说明：线程A正在执行同步代码块时，此时有线程CAS失败，虽然升级为「重量级锁」，但仍然由线程A持有锁，「如何膨胀为重量级锁」后文马上分析</p></blockquote> <h2 id="_4、重量级锁"><a href="#_4、重量级锁" class="header-anchor">#</a> 4、重量级锁</h2> <p>为了实现锁膨胀，避免并发膨胀锁，定义了四种膨胀锁状态：</p> <ul><li>膨胀完毕</li> <li>膨胀中</li> <li>无锁</li> <li>轻量级锁</li></ul> <p>下面依次对这些情况的膨胀进行分析：</p> <h4 id="重量级锁的生成-锁膨胀"><a href="#重量级锁的生成-锁膨胀" class="header-anchor">#</a> 重量级锁的生成/锁膨胀</h4> <ul><li>若膨胀完毕，直接返回monitor</li> <li>若膨胀中，线程等待一会，直到别的线程膨胀完毕，然后拿到别人生成的monitor</li></ul> <p>从轻量级锁开始膨胀：</p> <ol><li>创建monitor对象</li> <li>CAS将锁状态修改为「膨胀中」
<ul><li>失败，说明别人在膨胀了，等待，然后返回别人生成的monitor</li> <li>成功：
<ul><li>将markword保存至monitor</li> <li>设置持有monitor的线程</li> <li>将monitor地址设置为mark word</li> <li>返回monitor对象</li></ul></li></ul></li></ol> <p>从无锁开始膨胀，差不多：</p> <ol><li>创建monitor对象</li> <li>将markword保存至monitor</li> <li>CAS将锁状态修改为「膨胀中」
<ul><li>失败，说明别人在膨胀了，等待，然后返回别人生成的monitor</li> <li>成功，返回monitor对象</li></ul></li></ol> <h3 id="重量级锁实现原理"><a href="#重量级锁实现原理" class="header-anchor">#</a> 重量级锁实现原理</h3> <p>生成了重量级锁，mark word会指向堆中实际生成的monitor对象，我们先来看看monitor对象的结构：</p> <p><img src="/blog/assets/img/image-20240122110540197.6e7fe6e4.png" alt="image-20240122110540197"></p> <p>简单解释一下：</p> <ul><li>Contention List(cxq)：所有请求锁的线程将被首先放置到该竞争队列，是先进后出的栈结构</li> <li>Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List</li> <li>Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set</li> <li>OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck</li> <li>Owner：获得锁的线程称为Owner</li> <li>!Owner：释放锁的线程</li></ul> <h3 id="获取锁-2"><a href="#获取锁-2" class="header-anchor">#</a> 获取锁</h3> <blockquote><p>对于重量级锁，尝试获取锁具体是指：尝试用CAS将monitor对象的Owner从nullptr改变为自己</p></blockquote> <p>当一个线程尝试获得重量级锁时</p> <ul><li>首先尝试「自旋」，调用trySpin方法获取锁，如果第一次失败，再进行一次trySpin方法（最坏情况拿不到锁会调用两次trySpin），然后『用CAS的方式进入cxq』</li> <li>进入cxq后，陷入「死循环」，死循环中，可能会从cxq转移到EntryList，可能阻塞，也可能调用trySpin方法自旋。后文再详细分析「死循环」</li></ul> <p>可以看到「死循环」的实现也依赖trySpin自旋，因此我们先来看看「自旋」的实现逻辑：</p> <h4 id="_1、自旋锁"><a href="#_1、自旋锁" class="header-anchor">#</a> 1、自旋锁</h4> <p>自旋：不断尝试去获取锁，一般用循环来实现。</p> <blockquote><p>如果是单核CPU，自旋是无意义的，所以只有多处理器才会开启自旋功能</p></blockquote> <p>自旋的出现，是为了避免切换到内核态，因为线程的阻塞和唤醒依赖内核，我们希望能够一定程度上避免这种内核态与用户态的切换，因此有了「自旋锁」。那么自旋多少次更合适呢？</p> <ul><li>在锁很快被释放时，自旋既不会带来CPU资源的浪费，还能提高运行效率。此时自旋次数过少，可能会导致没能顺利拿到锁，即使结束自旋后不久锁就被释放了。</li> <li>在锁很久才被释放时，自旋空转占用CPU资源却迟迟拿不到锁，造成过多的CPU资源浪费。此时自旋次数过多，反而会得不偿失。</li></ul> <p>因此，JDK发明了自适应自旋，来适应各种情况的锁。</p> <h5 id="自适应自旋"><a href="#自适应自旋" class="header-anchor">#</a> 自适应自旋</h5> <p>自适应自旋为了权衡自旋次数过多和过少带来的弊端，它的基本思想是：</p> <ul><li>自旋成功拿到锁了，说明你下次成功的概率也很大，下次自旋的次数会更多</li> <li>自旋失败，说明你下次也大概率拿不到，下次自旋的次数会更少</li></ul> <p>自适应自旋参数如下：</p> <p><img src="/blog/assets/img/image-20230912211717368.5f4c0122.png" alt="image-20230912211717368"></p> <h5 id="自旋逻辑-tryspin"><a href="#自旋逻辑-tryspin" class="header-anchor">#</a> 自旋逻辑：trySpin</h5> <p>首选预自旋11次（避免预自旋次数设置为0，源码后面对这个参数加了1），如果没拿到锁：</p> <p>开始自旋5000次（假设是第一次开始自旋，上限就为5000）</p> <ul><li>成功，下次+100，下次可以最多自旋5100次</li> <li>失败，下次- 200，下次可以最多自旋4800次，不会少于1000次</li></ul> <h4 id="_2、死循环"><a href="#_2、死循环" class="header-anchor">#</a> 2、死循环</h4> <p>死循环主要是在「阻塞」和「自旋」之间切换</p> <ul><li>park阻塞，注意不会移动到WaitSet中</li> <li>unpark唤醒，再次调用trySpin方法自旋获取锁，如果失败，陷入阻塞</li></ul> <p>只有释放锁时，才会调用unpark唤醒，进入自旋状态，此时并不是一定能拿到锁的。</p> <h5 id="唤醒的时机"><a href="#唤醒的时机" class="header-anchor">#</a> 唤醒的时机</h5> <p>释放锁时才会唤醒，且只会唤醒一个，唤醒逻辑取决于Policy参数。</p> <h5 id="cxq和entrylist内线程的行为"><a href="#cxq和entrylist内线程的行为" class="header-anchor">#</a> cxq和EntryList内线程的行为</h5> <p>这两个区域内的线程几乎是全阻塞的，这两个区域内的线程，保证最多只有一个线程去竞争锁资源，这个被『释放锁时唤醒的唯一的线程』叫「假定继承人」，即Monitor结构中的「OnDeck」。</p> <p>注意：只保证所有阻塞的线程，只有一个去竞争锁资源，仍然可能被外来的线程在进入cxq之前就抢到了锁，所以说synchronized是不公平的。</p> <blockquote><p>EntryList内的线程全部来自cxq，在释放锁与调用notify方法时，可能进入EntryList</p></blockquote> <h3 id="释放锁-2"><a href="#释放锁-2" class="header-anchor">#</a> 释放锁</h3> <ol><li>通过CAS的方式将Monitor结构的Owner修改为nullptr</li> <li>根据QMode参数的不同，执行不同的逻辑</li></ol> <p>因为QMode默认值为0，我们来看一下<strong>默认的逻辑</strong>：</p> <ul><li>如果EntryList和cxq均为空：什么也不做</li> <li>如果EntryList非空：就取EntryList首元素唤醒</li> <li>如果EntryList为空，cxq非空：将cxq的所有线程放到EntryList，再唤醒EntryList首元素；</li></ul> <p>锁被持有时，EntryList和cxq的所有线程都阻塞，有且只有锁释放这唯一一个行为能够唤醒其中的一个线程。</p> <h4 id="为什么要区分cxq和entrylist"><a href="#为什么要区分cxq和entrylist" class="header-anchor">#</a> 为什么要区分cxq和EntryList</h4> <p>是为了解决CAS的ABA问题，也能分散请求，提高性能。</p> <p>cxq和EntryList都是为了存储所有阻塞的线程，但是：</p> <ul><li>释放锁并唤醒时，只会唤醒EntryList的线程，这是删除操作</li> <li>线程自旋次数过多需要被阻塞时，只会插入cxq队列，这是添加操作</li></ul> <p><strong>把这两种操作分离开来有什么好处呢？</strong></p> <h5 id="_1、提高性能"><a href="#_1、提高性能" class="header-anchor">#</a> 1、提高性能</h5> <p>由于锁只有一把，因此做删除操作的线程只有一个，不存在线程安全问题，不需要做CAS，如果和添加操作混在一起，就不得不考虑线程安全问题了。这样只需要在cxq内考虑CAS即可。</p> <h5 id="_2、解决aba问题"><a href="#_2、解决aba问题" class="header-anchor">#</a> 2、解决ABA问题</h5> <p>因为多个线程同时add，不会有某个线程出现在cxq里两次，因此只add不会有ABA问题。而一旦存在删除操作，那么ABA问题就是有可能的。</p> <h3 id="可感知的锁控制权"><a href="#可感知的锁控制权" class="header-anchor">#</a> 可感知的锁控制权</h3> <p>现在知道了加解锁的原理，那其实我们已经有能力知道，释放锁时会唤醒哪个线程。（暂时不考虑wait/notify）</p> <p>结论：先阻塞的线程，最晚获得锁。</p> <p>有三个线程，t1,t2,t3。这三个线程都自旋失败，插入cxq，由于是个栈，越晚进入cxq的，反而越早进入EntryList，顺序为t3,t2,t1。而唤醒时是按照EntryList的顺序去唤醒的，因此「并不是所谓的随机唤醒」。当然，如果此时有别的线程t4自旋未进入cxq，是有可能拿到锁的，但我们保证：t3先于t2被唤醒，t2先于t1被唤醒</p> <h2 id="锁状态的降级"><a href="#锁状态的降级" class="header-anchor">#</a> 锁状态的降级</h2> <blockquote><p>关于锁升级，「四种锁状态」已经说的足够清楚了，在这里简单说一说锁降级</p></blockquote> <p>关于降级，HotSpot是支持降级的，《Java并发编程的艺术》中的说法是无法降级，可能是因为当时还不支持，R大关于锁状态的降级也指出：不当的降级可能会影响性能。</p> <h2 id="编译器对-synchronized-的优化"><a href="#编译器对-synchronized-的优化" class="header-anchor">#</a> 编译器对 synchronized 的优化</h2> <h4 id="_1、锁消除"><a href="#_1、锁消除" class="header-anchor">#</a> 1、锁消除</h4> <p>如果编译器发现不会发生线程安全问题，就会无视了你的锁。</p> <h4 id="_2、锁粗化"><a href="#_2、锁粗化" class="header-anchor">#</a> 2、锁粗化</h4> <p>比如执行插入数据商品时，是对店铺加锁。那么批量执行的时候，只需要加一次锁。而不是每插入一次就加/释放一次锁。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>  <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
     sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
     sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 线程安全的buffer类，append会加锁，但显然这是可以锁粗化的，会优化成只获得/释放一次锁</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="synchronized-与包装类的坑"><a href="#synchronized-与包装类的坑" class="header-anchor">#</a> synchronized 与包装类的坑</h2> <p>Integer并不适合当作锁对象。</p> <p>因为Integer有缓存机制，-128~127有缓存。容易导致锁失效。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> ticket <span class="token operator">=</span> <span class="token number">10</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>比如两个线程抢票，不能锁住 ticket。抢完票以后ticket--，一个线程A锁的是ticket = 10的对象，另一个线程B执行完ticket = 10的临界区代码，ticket--，再走临界区，他的锁变成了9，与A竞争的都不是一把锁，因此两者都会抢到锁。</p> <p>因此：</p> <ul><li>锁住的对象尽量是静态的不变的，比如class类</li> <li>不能是各种有缓存的包装类</li> <li>在idea中没有声明final的对象加synchronized会提示不安全</li></ul> <h3 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h3> <p>到这里，应该对synchronized锁机制非常熟悉了，你应该清楚：</p> <ul><li>Monitor锁的底层结构图</li> <li>自旋的原理和应用</li> <li>重量级锁加解锁的逻辑等</li></ul> <p>下篇文章，我们趁热打铁来学习一下wait/notify的底层原理，至今仍未露面的WaitSet终于要登场了，学完wait/notify整个synchronized也就 “证据链闭环” 了。</p> <blockquote><p>从趁热打铁的角度，趁你还对加解锁和Monitor结构足够熟悉，我非常推荐紧接着阅读「wait/notify 的底层原理」。</p></blockquote> <h3 id="参考文献"><a href="#参考文献" class="header-anchor">#</a> 参考文献</h3> <p><a href="https://blog.csdn.net/boling_cavalry/article/details/77793224" target="_blank" rel="noopener noreferrer">Java的wait()、notify()学习三部曲<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://space.bilibili.com/416747307/channel/collectiondetail?sid=1389015" target="_blank" rel="noopener noreferrer">为锁正名<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://github.com/farmerjohngit/myblog/issues/12" target="_blank" rel="noopener noreferrer">死磕Synchronized底层实现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/java多线程/core/Volatile.html" class="prev">
        volatile 关键字详解
      </a></span> <span class="next"><a href="/blog/java多线程/core/WaitNotify.html">
        显示同步：wait/notify
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.7b9df32b.js" defer></script><script src="/blog/assets/js/2.be714ec7.js" defer></script><script src="/blog/assets/js/1.26c7c9cc.js" defer></script><script src="/blog/assets/js/29.f71b59d6.js" defer></script>
  </body>
</html>
