<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>透过 ReentrantLock 讲 AQS 的原理 | lun&#39;s blogs</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/blog/favicon.ico">
    <meta name="description" content="blog">
    
    <link rel="preload" href="/blog/assets/css/0.styles.56f5eb6c.css" as="style"><link rel="preload" href="/blog/assets/js/app.7b9df32b.js" as="script"><link rel="preload" href="/blog/assets/js/2.be714ec7.js" as="script"><link rel="preload" href="/blog/assets/js/1.26c7c9cc.js" as="script"><link rel="preload" href="/blog/assets/js/39.f04e5b6a.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.0d71bf2e.js"><link rel="prefetch" href="/blog/assets/js/11.cc81c248.js"><link rel="prefetch" href="/blog/assets/js/12.5e69cd14.js"><link rel="prefetch" href="/blog/assets/js/13.f0bc7bf2.js"><link rel="prefetch" href="/blog/assets/js/14.0188e855.js"><link rel="prefetch" href="/blog/assets/js/15.48a1e71e.js"><link rel="prefetch" href="/blog/assets/js/16.0f4182c9.js"><link rel="prefetch" href="/blog/assets/js/17.ec7b8f9d.js"><link rel="prefetch" href="/blog/assets/js/18.776522e2.js"><link rel="prefetch" href="/blog/assets/js/19.26561e06.js"><link rel="prefetch" href="/blog/assets/js/20.3e42feda.js"><link rel="prefetch" href="/blog/assets/js/21.fd4e7a00.js"><link rel="prefetch" href="/blog/assets/js/22.b59f6079.js"><link rel="prefetch" href="/blog/assets/js/23.e6b2d3ec.js"><link rel="prefetch" href="/blog/assets/js/24.736cfa99.js"><link rel="prefetch" href="/blog/assets/js/25.91176041.js"><link rel="prefetch" href="/blog/assets/js/26.146e299c.js"><link rel="prefetch" href="/blog/assets/js/27.56a57551.js"><link rel="prefetch" href="/blog/assets/js/28.13a846a1.js"><link rel="prefetch" href="/blog/assets/js/29.f71b59d6.js"><link rel="prefetch" href="/blog/assets/js/3.f34ea2f7.js"><link rel="prefetch" href="/blog/assets/js/30.bf0626f9.js"><link rel="prefetch" href="/blog/assets/js/31.47592684.js"><link rel="prefetch" href="/blog/assets/js/32.63f20fc3.js"><link rel="prefetch" href="/blog/assets/js/33.4852d9ec.js"><link rel="prefetch" href="/blog/assets/js/34.4f467138.js"><link rel="prefetch" href="/blog/assets/js/35.17d26444.js"><link rel="prefetch" href="/blog/assets/js/36.d0059312.js"><link rel="prefetch" href="/blog/assets/js/37.fc856e5d.js"><link rel="prefetch" href="/blog/assets/js/38.dc6b373c.js"><link rel="prefetch" href="/blog/assets/js/4.885368ff.js"><link rel="prefetch" href="/blog/assets/js/40.b378efa5.js"><link rel="prefetch" href="/blog/assets/js/41.3c800d8a.js"><link rel="prefetch" href="/blog/assets/js/42.8b804f0c.js"><link rel="prefetch" href="/blog/assets/js/43.832aa078.js"><link rel="prefetch" href="/blog/assets/js/44.d1121c11.js"><link rel="prefetch" href="/blog/assets/js/45.b3e8ede1.js"><link rel="prefetch" href="/blog/assets/js/46.01e4202b.js"><link rel="prefetch" href="/blog/assets/js/47.489850e9.js"><link rel="prefetch" href="/blog/assets/js/48.3bd88d5f.js"><link rel="prefetch" href="/blog/assets/js/49.08c6f759.js"><link rel="prefetch" href="/blog/assets/js/5.d1dbc0b1.js"><link rel="prefetch" href="/blog/assets/js/50.c900e52a.js"><link rel="prefetch" href="/blog/assets/js/51.a59d8fbf.js"><link rel="prefetch" href="/blog/assets/js/52.0c715d23.js"><link rel="prefetch" href="/blog/assets/js/53.07715a2f.js"><link rel="prefetch" href="/blog/assets/js/54.e0d8cc69.js"><link rel="prefetch" href="/blog/assets/js/55.1efa3b0b.js"><link rel="prefetch" href="/blog/assets/js/56.ace3e6e3.js"><link rel="prefetch" href="/blog/assets/js/57.221667c1.js"><link rel="prefetch" href="/blog/assets/js/58.a786e5bd.js"><link rel="prefetch" href="/blog/assets/js/59.8a6dde26.js"><link rel="prefetch" href="/blog/assets/js/6.7ee6eed6.js"><link rel="prefetch" href="/blog/assets/js/60.0192f277.js"><link rel="prefetch" href="/blog/assets/js/61.75813485.js"><link rel="prefetch" href="/blog/assets/js/62.d8de1a01.js"><link rel="prefetch" href="/blog/assets/js/63.a08485a4.js"><link rel="prefetch" href="/blog/assets/js/64.7d19f572.js"><link rel="prefetch" href="/blog/assets/js/65.3f290d9a.js"><link rel="prefetch" href="/blog/assets/js/66.73f49082.js"><link rel="prefetch" href="/blog/assets/js/67.cb22e678.js"><link rel="prefetch" href="/blog/assets/js/68.22dc7228.js"><link rel="prefetch" href="/blog/assets/js/69.1f450482.js"><link rel="prefetch" href="/blog/assets/js/7.153b9c62.js"><link rel="prefetch" href="/blog/assets/js/70.03205c0b.js"><link rel="prefetch" href="/blog/assets/js/71.5b98edf5.js"><link rel="prefetch" href="/blog/assets/js/72.8be00756.js"><link rel="prefetch" href="/blog/assets/js/73.5e60394c.js"><link rel="prefetch" href="/blog/assets/js/74.a1100b64.js"><link rel="prefetch" href="/blog/assets/js/75.b47153bc.js"><link rel="prefetch" href="/blog/assets/js/76.b881f0b9.js"><link rel="prefetch" href="/blog/assets/js/77.eef60dd8.js"><link rel="prefetch" href="/blog/assets/js/78.b52fa32f.js"><link rel="prefetch" href="/blog/assets/js/79.9adc486f.js"><link rel="prefetch" href="/blog/assets/js/80.10b21516.js"><link rel="prefetch" href="/blog/assets/js/81.12c11cbc.js"><link rel="prefetch" href="/blog/assets/js/82.df4ae15b.js"><link rel="prefetch" href="/blog/assets/js/83.078b9ed6.js"><link rel="prefetch" href="/blog/assets/js/84.2d8ccb46.js"><link rel="prefetch" href="/blog/assets/js/85.4d5e44f4.js"><link rel="prefetch" href="/blog/assets/js/86.c32dda95.js"><link rel="prefetch" href="/blog/assets/js/87.c28d1f54.js"><link rel="prefetch" href="/blog/assets/js/88.c06457bb.js"><link rel="prefetch" href="/blog/assets/js/89.1febc082.js"><link rel="prefetch" href="/blog/assets/js/90.37985dbe.js"><link rel="prefetch" href="/blog/assets/js/91.9c3ebd93.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.02634ae8.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.56f5eb6c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="lun's blogs" class="logo"> <span class="site-name can-hide">lun's blogs</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/base/Exception.html" class="nav-link">
  异常
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Generics.html" class="nav-link">
  泛型
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Enum.html" class="nav-link">
  枚举
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Serialize.html" class="nav-link">
  Java序列化机制详解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Proxy.html" class="nav-link">
  动态代理
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Annotation.html" class="nav-link">
  深入理解Java注解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream1.html" class="nav-link">
  Stream源码分析(上)
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream2.html" class="nav-link">
  Stream源码分析(下)
</a></li></ul></div></div><div class="nav-item"><a href="/blog/java多线程/" class="nav-link">
  Java多线程
</a></div><div class="nav-item"><a href="/blog/jvm/" class="nav-link">
  JVM
</a></div><div class="nav-item"><a href="/blog/redis/" class="nav-link">
  Redis
</a></div><div class="nav-item"><a href="/blog/blogs/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="https://juejin.cn/user/2159878519134157" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/base/Exception.html" class="nav-link">
  异常
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Generics.html" class="nav-link">
  泛型
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Enum.html" class="nav-link">
  枚举
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Serialize.html" class="nav-link">
  Java序列化机制详解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Proxy.html" class="nav-link">
  动态代理
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Annotation.html" class="nav-link">
  深入理解Java注解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream1.html" class="nav-link">
  Stream源码分析(上)
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream2.html" class="nav-link">
  Stream源码分析(下)
</a></li></ul></div></div><div class="nav-item"><a href="/blog/java多线程/" class="nav-link">
  Java多线程
</a></div><div class="nav-item"><a href="/blog/jvm/" class="nav-link">
  JVM
</a></div><div class="nav-item"><a href="/blog/redis/" class="nav-link">
  Redis
</a></div><div class="nav-item"><a href="/blog/blogs/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="https://juejin.cn/user/2159878519134157" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" aria-current="page" class="sidebar-link">一、前言</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>二、Java并发基础知识</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>三、锁与同步器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>四、JUC</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java多线程/juc/Locks.html" class="active sidebar-link">透过 ReentrantLock 讲 AQS 的原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#为什么有synchronized还不够" class="sidebar-link">为什么有synchronized还不够</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#从高处看-locks-包的设计" class="sidebar-link">从高处看 locks 包的设计</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#lock接口" class="sidebar-link">Lock接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#condition接口-等待通知机制" class="sidebar-link">Condition接口：等待通知机制</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#不同的加锁方式" class="sidebar-link">不同的加锁方式</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#lock与trylock的区别" class="sidebar-link" style="padding-left:3rem;">lock与trylock的区别</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#lock与lockinterruptibly-的区别" class="sidebar-link" style="padding-left:3rem;">lock与lockInterruptibly()的区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#reentrantlock-可重入锁" class="sidebar-link">ReentrantLock：可重入锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#基本使用" class="sidebar-link" style="padding-left:3rem;">基本使用</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#核心字段" class="sidebar-link" style="padding-left:3rem;">核心字段</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#构造方法" class="sidebar-link" style="padding-left:3rem;">构造方法</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#实例方法" class="sidebar-link" style="padding-left:3rem;">实例方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#aos-独占锁的持有者" class="sidebar-link">AOS：独占锁的持有者</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#aqs-自定义同步器的框架" class="sidebar-link">AQS：自定义同步器的框架</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#内部类node-封装线程" class="sidebar-link">内部类Node：封装线程</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#node-waitstatus-线程状态" class="sidebar-link">Node.waitStatus：线程状态</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#核心字段-2" class="sidebar-link" style="padding-left:3rem;">核心字段</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#模板方法" class="sidebar-link" style="padding-left:3rem;">模板方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#aqs核心工作流程" class="sidebar-link">AQS核心工作流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#_1、独占模式" class="sidebar-link">1、独占模式</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#获取资源" class="sidebar-link" style="padding-left:3rem;">获取资源</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#释放资源" class="sidebar-link" style="padding-left:3rem;">释放资源</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#_2、共享模式" class="sidebar-link">2、共享模式</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#获取资源-2" class="sidebar-link" style="padding-left:3rem;">获取资源</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#释放资源-2" class="sidebar-link" style="padding-left:3rem;">释放资源</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#为什么采用双向链表" class="sidebar-link">为什么采用双向链表</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#共享与独占的区别" class="sidebar-link">共享与独占的区别</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#公平-or-非公平" class="sidebar-link">公平 or 非公平</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#aqs的等待通知机制-condition" class="sidebar-link">AQS的等待通知机制：Condition</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#回顾condition接口" class="sidebar-link">回顾Condition接口</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#核心字段-3" class="sidebar-link" style="padding-left:3rem;">核心字段</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#获取condition对象" class="sidebar-link" style="padding-left:3rem;">获取Condition对象</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#await方法" class="sidebar-link" style="padding-left:3rem;">await方法</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#signal方法" class="sidebar-link" style="padding-left:3rem;">signal方法</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#signalall方法" class="sidebar-link" style="padding-left:3rem;">signalAll方法</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#为什么condition不需要cas" class="sidebar-link">为什么Condition不需要CAS</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#笼统地看aqs行为模式" class="sidebar-link">笼统地看AQS行为模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#aqs和synchronized的行为模式对比" class="sidebar-link">AQS和synchronized的行为模式对比</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#基于aqs自定义同步器" class="sidebar-link">基于AQS自定义同步器</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#面试-讲讲aqs" class="sidebar-link">面试：讲讲AQS</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#熟悉aqs后再看reentrantlock原理" class="sidebar-link">熟悉AQS后再看ReentrantLock原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#抽象类sync" class="sidebar-link">抽象类Sync</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#公共的释放资源逻辑" class="sidebar-link" style="padding-left:3rem;">公共的释放资源逻辑</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#非公平sync" class="sidebar-link">非公平Sync</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#获取资源-3" class="sidebar-link" style="padding-left:3rem;">获取资源</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#加锁lock" class="sidebar-link" style="padding-left:3rem;">加锁lock</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#公平sync" class="sidebar-link">公平Sync</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#加锁lock-少做一次cas" class="sidebar-link" style="padding-left:3rem;">加锁lock：少做一次CAS</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#trylock-time-实现原理" class="sidebar-link">tryLock(time)实现原理</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#reentrantlock小结" class="sidebar-link">ReentrantLock小结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#synchronized和reentrantlock对比" class="sidebar-link">Synchronized和ReentrantLock对比</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#synchronized和reentrantlock怎么选" class="sidebar-link">Synchronized和ReentrantLock怎么选</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/juc/Locks.html#参考文档" class="sidebar-link">参考文档</a></li></ul></li></ul></li><li><a href="/blog/java多线程/juc/Tools1.html" class="sidebar-link">常见工具类：AQS 的应用</a></li><li><a href="/blog/java多线程/juc/Tools2.html" class="sidebar-link">CAS与锁的常见应用</a></li><li><a href="/blog/java多线程/juc/ConcurrentHashMap.html" class="sidebar-link">ConcurrentHashMap 源码剖析</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>五、线程池</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>六、补充</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="透过-reentrantlock-讲-aqs-的原理"><a href="#透过-reentrantlock-讲-aqs-的原理" class="header-anchor">#</a> 透过 ReentrantLock 讲 AQS 的原理</h1> <blockquote><p>ReentrantLock 和 AQS 是紧密联系的</p> <ul><li>要学好 AQS ，必须实战，ReentrantLock 就是 AQS 的一个典型的应用</li> <li>AQS 相对枯燥，理论，而 ReentrantLock 就有了实践意义</li> <li>要学好 ReentrantLock ，必须先学好 AQS ，AQS 是实现 ReentrantLock 的基本</li></ul> <p>因此，本文既涵盖 ReentrantLock ，也有 AQS，虽然篇幅较长，还是推荐一次性看完。</p></blockquote> <h2 id="为什么有synchronized还不够"><a href="#为什么有synchronized还不够" class="header-anchor">#</a> 为什么有synchronized还不够</h2> <ul><li>synchronized是「排他锁」，也就是：只有一个线程能够持有锁，无法满足我们需要多个线程同时持有锁的「共享锁」的需求</li> <li>synchronized虽然使用简单方便，但不够灵活，暴露的方法也比较少，比如：无法知道线程有没有成功获取到锁</li> <li>我们说过synchronized是「非公平锁」，很多场景需要「公平锁」，即先来的线程先拿到锁资源</li></ul> <p>java.util.concurrent.locks这个包就是为了提供不一样的锁的。</p> <h2 id="从高处看-locks-包的设计"><a href="#从高处看-locks-包的设计" class="header-anchor">#</a> 从高处看 locks 包的设计</h2> <p>我们现在需要能够提供各种各样功能的锁，目的是<strong>解决 synchronized 的不足</strong>，该如何设计呢？我们当然可以参考 synchronized 的实现原理：</p> <p>我们先回顾一下synchronized的锁结构</p> <p><img src="/blog/assets/img/image-20240122110600731.6e7fe6e4.png" alt="image-20240122110600731"></p> <p>synchronized 是<strong>独占</strong>的，我们希望我们的锁是能够共享的，可以分别实现两套API</p> <p>synchronized 是<strong>不公平</strong>的，我们希望我们的锁能够提供公平性：</p> <ul><li>那就不能上来直接自旋那么多次，如果发现竞争可能要直接陷入阻塞</li> <li>cxq的先进后出的结构不好用了</li></ul> <p>synchronized的 wait/notify 还不错，但局限性在于 WaitSet 只有一个，我们希望线程 await 去不同的 WaitSet。</p> <p>带着这样的思想，我们来看看 locks 包下的类都是如何设计的。</p> <h2 id="lock接口"><a href="#lock接口" class="header-anchor">#</a> Lock接口</h2> <p>直接看源码：可以看到提供了四种加锁的方式，以及一种解锁unlock，和一个newCondition方法。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Lock</span> <span class="token punctuation">{</span>
	<span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
	<span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>实际上 Condition 就是实现 Lock 的等待通知机制的关键，对标的是 wait/notify 机制，下面简单看一下这个接口</p> <h3 id="condition接口-等待通知机制"><a href="#condition接口-等待通知机制" class="header-anchor">#</a> Condition接口：等待通知机制</h3> <p>可以看到，提供了五种await方法，功能类似Object的wait方法，因此说是加强版的wait也没问题</p> <p>Condition功能上基于wait/notify提供了加强，实现上也十分类似，Condition会维护所有因调用await方法而阻塞的线程，这与WaitSet十分类似。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">awaitUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> <span class="token function">awaitNanos</span><span class="token punctuation">(</span><span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> <span class="token function">awaitUntil</span><span class="token punctuation">(</span><span class="token class-name">Date</span> deadline<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>实际上，实现Condition接口的类只有两个：AQS和AQLS。后文会详细阐述Condition在AQS中运用。</p> <h3 id="不同的加锁方式"><a href="#不同的加锁方式" class="header-anchor">#</a> 不同的加锁方式</h3> <h4 id="lock与trylock的区别"><a href="#lock与trylock的区别" class="header-anchor">#</a> lock与trylock的区别</h4> <ul><li>lock() : 一直阻塞，直到获得锁，且等待获取锁期间被interrupt不能中断</li> <li>trylock() : 不会阻塞，<strong>获取不到锁直接返回false</strong></li> <li>tryLock(10, TimeUnit.SECONDS) ：等待10s，被interrupt会中断等待，抛出InterruptedException，超时还没获取到锁会返回false</li></ul> <h4 id="lock与lockinterruptibly-的区别"><a href="#lock与lockinterruptibly-的区别" class="header-anchor">#</a> lock与lockInterruptibly()的区别</h4> <p>lockInterruptibly<strong>允许在等待时由其它线程调用等待线程的Thread.interrupt方法来中断等待线程的等待而直接返回</strong>，这时不用获取锁，而会抛出一个InterruptedException。</p> <p>lock方法不允许Thread.interrupt中断,<strong>即使检测到Thread.isInterrupted,一样会继续尝试获取锁，失败则继续休眠</strong>。<strong>只是在最后获取锁成功后再把当前线程置为interrupted状态,然后再中断线程</strong>。</p> <p>Lock接口下最重要的实现类就是ReentrantLock，也是被人们拿来和synchronized比较最多的锁，我们直接看ReentrantLock。</p> <h2 id="reentrantlock-可重入锁"><a href="#reentrantlock-可重入锁" class="header-anchor">#</a> ReentrantLock：可重入锁</h2> <p>ReentrantLock的中文译名就是可重入锁，同时支持公平和非公平，默认非公平。属于「排他锁」，不能共享</p> <p>类关系并不复杂，只实现了Lock接口，源码也很少</p> <h4 id="基本使用"><a href="#基本使用" class="header-anchor">#</a> 基本使用</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>注意：执行加锁必须在try代码块之外，避免异常时无故释放锁</p> <h4 id="核心字段"><a href="#核心字段" class="header-anchor">#</a> 核心字段</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Sync是一个抽象静态内部类，继承自 <code>AbstractQueuedSynchronizer</code>，这个玩意就是大名鼎鼎的 AQS，Sync 有两个实现类，分别对应是否公平。我们马上就会分析 AQS 的源码。</p> <h4 id="构造方法"><a href="#构造方法" class="header-anchor">#</a> 构造方法</h4> <p>提供两种，可以看到无参默认非公平，也可以指定公平</p> <p>而公不公平的区别仅仅是sync的实例对象不同</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="实例方法"><a href="#实例方法" class="header-anchor">#</a> 实例方法</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sync<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        sync<span class="token punctuation">.</span><span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>就暂时列这么多，要不然篇幅太长了。可以看到，其实几乎所有方法，都以委托的方式交给sync来执行，因此我们需要聚焦于sync才能明白ReentrantLock的实现原理了，而sync继承自AQS，AQS继承自AOS，我们一个个来看</p> <h2 id="aos-独占锁的持有者"><a href="#aos-独占锁的持有者" class="header-anchor">#</a> AOS：独占锁的持有者</h2> <p>AOS，AbstractOwnableSynchronizer，源码很简单</p> <p>只有一个字段，以及一对get/set方法，AOS就干了一件事：<strong>保存持有独占锁的线程</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Thread</span> exclusiveOwnerThread<span class="token punctuation">;</span>

    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        exclusiveOwnerThread <span class="token operator">=</span> thread<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">Thread</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> exclusiveOwnerThread<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p>AOS类比synchronized的话，就是monitor结构中的running thread</p></blockquote> <h2 id="aqs-自定义同步器的框架"><a href="#aqs-自定义同步器的框架" class="header-anchor">#</a> AQS：自定义同步器的框架</h2> <p><strong>AQS</strong>是<code>AbstractQueuedSynchronizer</code>的简称，中文名「抽象队列同步器」，是一个<strong>用来构建锁和同步器的框架</strong>，使用AQS能简单且高效地构造出应用广泛的同步器。</p> <h3 id="内部类node-封装线程"><a href="#内部类node-封装线程" class="header-anchor">#</a> 内部类Node：封装线程</h3> <p>Node是对竞争锁资源的线程的封装，用</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 线程状态</span>
<span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>
<span class="token comment">// 双向链表</span>
<span class="token keyword">volatile</span> <span class="token class-name">Node</span> prev<span class="token punctuation">;</span>
<span class="token keyword">volatile</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>
<span class="token comment">// 封装的线程</span>
<span class="token keyword">volatile</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>

<span class="token class-name">Node</span> nextWaiter<span class="token punctuation">;</span>
<span class="token comment">// 如果是独占模式，nextWaiter维护condition内的下一个节点</span>
<span class="token comment">// 如果是共享模式，nextWaiter为特殊值SHARED，SHARED是AQS的类变量</span>
<span class="token comment">// 这样做的意义是节约一个字段，保存了节点的</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token constant">SHARED</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 判断是否共享</span>
   <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> nextWaiter <span class="token operator">==</span> <span class="token constant">SHARED</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h3 id="node-waitstatus-线程状态"><a href="#node-waitstatus-线程状态" class="header-anchor">#</a> Node.waitStatus：线程状态</h3> <p>源码关于waitStatus的含义说的很清楚了：</p> <table><thead><tr><th>waitStatus值</th> <th>含义</th></tr></thead> <tbody><tr><td>0</td> <td>一个普通的在CLH队列的线程的WaitStatus值</td></tr> <tr><td>1</td> <td>CANCELLED，表示<strong>线程取消获取资源请求</strong>(可能是等待超时，或者被中断)</td></tr> <tr><td>-2</td> <td>CONDITION，表示线程调用了await方法，<strong>在Condition队列里阻塞</strong></td></tr> <tr><td>-3</td> <td>PROPAGATE，解决共享模式的一个没能顺利唤醒线程的Bug而有的，细节问题</td></tr> <tr><td>-1</td> <td>SIGNAL，表示<strong>后继结点阻塞了，此时你如果释放了资源，需要unpark它（唤醒）</strong></td></tr></tbody></table> <blockquote><p>-2和1很好理解，0和-1你可能会有点犯迷糊，在后面「获取资源」时会再详细分析的</p> <p>另外，Propagate是JDK6引入解决共享模式无法唤醒后续节点的。复现Bug的场景是：</p> <p>两个线程A、B，A首先释放锁，唤醒首节点，设置首节点状态为0。此时B也释放锁。发现首节点状态为0，不继续唤醒，并且修改状态为-1，此时回到A，A也不会继续唤醒了。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 这是JDK6的源码</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> propagate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">//将当前节点设置为头节点</span>
<span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>propagate <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">Node</span> s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token comment">//获取当前节点的后继节点,如果它为null或者它是共享节点，则唤醒头节点的后继节点</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">//唤醒后继节点</span>
<span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">//头节点不为空,且状态不为0时,调用唤醒节点方法</span>
   <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p><a href="https://blog.csdn.net/qq_33983753/article/details/129042579?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=doReleaseShared&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-129042579.nonecase&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener noreferrer">感兴趣的可以参考下这篇文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6801020" target="_blank" rel="noopener noreferrer">bug原地址<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h4 id="核心字段-2"><a href="#核心字段-2" class="header-anchor">#</a> 核心字段</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 双向链表 也叫CLH head节点一般指向null或者已经获取资源的Node</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> head<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> tail<span class="token punctuation">;</span>
<span class="token comment">// 锁同步的状态，state是控制同步的关键</span>
<span class="token comment">// 提供了三种读写API：</span>
<span class="token comment">// getState()、setState(int newState)和compareAndSetState(int expect,int update)）</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>
<span class="token comment">// spin 不就是自旋的意思么 最大自旋时间为1000纳秒</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> spinForTimeoutThreshold <span class="token operator">=</span> <span class="token number">1000L</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="模板方法"><a href="#模板方法" class="header-anchor">#</a> 模板方法</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>分别是：已独占的方式获取/释放资源；已共享的方式获取/释放资源；</p> <p>isHeldExclusively判断是否独占资源，只有用到condition才需要去实现它</p> <h2 id="aqs核心工作流程"><a href="#aqs核心工作流程" class="header-anchor">#</a> AQS核心工作流程</h2> <h3 id="_1、独占模式"><a href="#_1、独占模式" class="header-anchor">#</a> 1、独占模式</h3> <p>独占模式只有一个线程能够获取到资源</p> <h4 id="获取资源"><a href="#获取资源" class="header-anchor">#</a> 获取资源</h4> <blockquote><p>acquire方法在尝试获取资源的过程中，即使被interrupt，也仍然会继续运行直到获取到锁，相对的acquireInterruptibly方法一旦被interrupt，会立刻抛出中断异常，其它逻辑几乎完全一样</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// arg代表要获取资源的个数</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">EXCLUSIVE</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 获取资源的过程中被中断，在获取到以后才真正中断</span>
        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ol><li>调用tryAcquire方法尝试获取资源，如果成功直接返回，失败继续</li> <li>以自旋CAS的方式向CLH队列尾部插入线程（addWaiter方法）</li> <li>自旋（死循环）尝试获取资源，每次自旋检查自己是否需要阻塞，阻塞的条件是这样的：</li></ol> <ul><li>如果你的前驱节点状态为SIGNAL，阻塞；</li> <li>否则，不阻塞，并且用CAS的方式将前驱节点状态改为SIGNAL（然后再次循环）</li></ul> <blockquote><p>当前节点为SIGNAL表示，当 当前节点释放资源时，需要唤醒后继节点，因此CLH的线程不能那么自私的直接阻塞不管了。这就像排队，你要睡觉，你得告诉排在你前面的兄弟等轮到他了记得把自己叫醒。</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 只有当</span>
<span class="token comment">// selfInterrupt();就是中断线程自己</span>
<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="释放资源"><a href="#释放资源" class="header-anchor">#</a> 释放资源</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token comment">// 唤醒head的next节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>tryRelease释放资源</p> <ul><li>成功，唤醒CLH队列的下一个节点，返回true</li> <li>失败，返回false</li></ul> <h3 id="_2、共享模式"><a href="#_2、共享模式" class="header-anchor">#</a> 2、共享模式</h3> <h4 id="获取资源-2"><a href="#获取资源-2" class="header-anchor">#</a> 获取资源</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">doAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>doAcquireShared几乎和acquireQueued差不多，但可能会唤醒后续的节点</p> <p>当线程自旋成功获取到资源后，</p> <ul><li>首先调用tryAcquireShared，成功直接返回，失败继续</li> <li>以自旋CAS的方式插入CLH队列尾部</li> <li>陷入死循环，自旋获取锁，每次自旋检查自己是否需要阻塞</li></ul> <p>如果成功获取到锁，可能唤醒CLH的下一个节点（doReleaseShared方法）</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h <span class="token operator">!=</span> tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> ws <span class="token operator">=</span> h<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>
            <span class="token comment">// 这里就是需要我们唤醒后续节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">SIGNAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">SIGNAL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment">// loop to recheck cases</span>
                <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 这里ws=0，说明可能是别的线程CAS成功了，把状态设置为PROPAGATE</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
                     <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">PROPAGATE</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token comment">// loop on failed CAS</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果head没变 说明后续没有值得唤醒的线程了</span>
        <span class="token comment">// 唤醒成功，unparkSuccessor(h);会移动节点从而改变head的值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> head<span class="token punctuation">)</span>                   <span class="token comment">// loop if head changed</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h4 id="释放资源-2"><a href="#释放资源-2" class="header-anchor">#</a> 释放资源</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>就是释放资源成功，然后doReleaseShared，这个方法在获取资源的setHeadAndPropagate方法已经见到过，就是可能唤醒后续节点。</p> <h3 id="为什么采用双向链表"><a href="#为什么采用双向链表" class="header-anchor">#</a> 为什么采用双向链表</h3> <p>线程出现异常，不需要继续参与竞争资源，而是直接从CLH中删除，因此需要找到前驱节点，提高效率。</p> <h3 id="共享与独占的区别"><a href="#共享与独占的区别" class="header-anchor">#</a> 共享与独占的区别</h3> <p>在获取资源成功后，独占不需要考虑唤醒CLH的后续节点，但共享模式必须考虑虽然获取资源成功，但此时后续节点也完全有可能能够获取资源，因此需要doReleaseShared去唤醒</p> <p>在释放资源后，独占只需要唤醒一个节点，而共享模式唤醒的节点个数是不确定的</p> <h3 id="公平-or-非公平"><a href="#公平-or-非公平" class="header-anchor">#</a> 公平 or 非公平</h3> <p>AQS是完全保证自己的公平性的。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可以看到，在进入了CLH队列以后的自旋，尝试获取资源都需要做一个判断：<strong>前驱节点为head头节点</strong></p> <p>这是一个对公平性非常强有力的保证，因为所有尝试获取资源失败的节点都会通过addWaiter方法插入到CLH尾部，保证了CLH的顺序严格按照获取资源的顺序排序。</p> <p><strong>但是</strong></p> <p>自定义的tryAcquire方法保证吗？不知道，这取决于实现者。而AQS的acquire方法，首先会调用tryAcquire，失败才放入CLH，那么这一次调用tryAcquire一旦成功，就先于CLH队列中的线程拿到资源，因此不公平。</p> <p>所以，要想实现公平也很简单了：自定义tryAcquire时，也做一个<code>if (head == preNode)</code>的判断不就好了，当然我们还没插入CLH没有preNode，因此ReentrantLock是这样判断的：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 在try前需要!hasQueuedPredecessors() ，即下面表达式返回false</span>
<span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span> <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token class-name">Node</span> s<span class="token punctuation">;</span>
<span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// CLH队列还有别的节点在等待就返回true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="aqs的等待通知机制-condition"><a href="#aqs的等待通知机制-condition" class="header-anchor">#</a> AQS的等待通知机制：Condition</h2> <blockquote><p>因为Condition的基本使用和wait/notify完全一样，就不再赘述了</p></blockquote> <h3 id="回顾condition接口"><a href="#回顾condition接口" class="header-anchor">#</a> 回顾Condition接口</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">awaitUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> <span class="token function">awaitNanos</span><span class="token punctuation">(</span><span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> <span class="token function">awaitUntil</span><span class="token punctuation">(</span><span class="token class-name">Date</span> deadline<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>AQS的内部类 ConditionObject 实现了 Condition 接口，这个类只对外暴露了Condition接口的六个方法，所以核心逻辑就两大类：等待await，唤醒signal</p> <blockquote><p>注意：只有独占模式可以用Condition，共享模式不允许</p></blockquote> <p>下面我们直接来看 ConditionObject 的源码。</p> <h4 id="核心字段-3"><a href="#核心字段-3" class="header-anchor">#</a> 核心字段</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code>        <span class="token comment">/** First node of condition queue. */</span>
        <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Node</span> firstWaiter<span class="token punctuation">;</span>
        <span class="token comment">/** Last node of condition queue. */</span>
        <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Node</span> lastWaiter<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>可以看到，同样是个双向链表结构，注意：head节点为空不存储信息，而tail指向同步队列的尾部</p> <h4 id="获取condition对象"><a href="#获取condition对象" class="header-anchor">#</a> 获取Condition对象</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ConditionObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>虽然构造方法是public的，但ReentrantLock提供了newCondition方法获取Condition对象，尽管本质也是无参构造方法而已。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">ConditionObject</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConditionObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="await方法"><a href="#await方法" class="header-anchor">#</a> await方法</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 插入到Condition双向链表尾部</span>
    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 释放锁</span>
    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 死循环</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 阻塞当前线程</span>
        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 阻塞被中断 退出循环</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> <span class="token constant">THROW_IE</span><span class="token punctuation">)</span>
        interruptMode <span class="token operator">=</span> <span class="token constant">REINTERRUPT</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// clean up if cancelled</span>
        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><ol><li>插入到Condition双向链表尾部</li> <li>调用release方法释放资源</li> <li>陷入死循环阻塞，被唤醒时如果发现自己在CLH队列中，就退出循环</li> <li>调用acquireQueued方法，这个就是AQS的acquire的核心方法</li></ol> <blockquote><p>acquire方法是先执行tryAcquire然后acquireQueued</p> <p>acquireQueued就是自旋获取锁/阻塞。</p></blockquote> <h4 id="signal方法"><a href="#signal方法" class="header-anchor">#</a> signal方法</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 其实核心方法是doSignal 下面是doSignal方法</span>
             <span class="token keyword">do</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>firstWaiter <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    lastWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                 <span class="token comment">// 删除头节点</span>
                first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                 <span class="token comment">// transferForSignal 添加到CLH尾部...</span>
            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                     <span class="token punctuation">(</span>first <span class="token operator">=</span> firstWaiter<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>从Condition队列里将头节点移除，插入到CLH队列尾部</p> <blockquote><p>这里和synchronized的notify就不一样了，signal就是插入尾部，而notify至少会比cxq的线程更优先拿到锁</p></blockquote> <p>细节是：调用signal后，如果你是唯一的线程，你是需要被唤醒的，但这个属于实现的细节了，知道即可</p> <h4 id="signalall方法"><a href="#signalall方法" class="header-anchor">#</a> signalAll方法</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span> next <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">;</span>
    first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
    first <span class="token operator">=</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>可以看到，也是按顺序一个个唤醒，注意并不是无序的。</p> <p>那么至此，整个 AQS 源码就分析的差不多了，下面收个尾</p> <h3 id="为什么condition不需要cas"><a href="#为什么condition不需要cas" class="header-anchor">#</a> 为什么Condition不需要CAS</h3> <p>Condition的方法必须在拿到锁的情况才可以调用，也就是lock和unlock之间，并且Condition是独占锁特有的工具，至多只有一个线程会拿到锁。因此调用await/signal方法不需要CAS。</p> <h2 id="笼统地看aqs行为模式"><a href="#笼统地看aqs行为模式" class="header-anchor">#</a> 笼统地看AQS行为模式</h2> <p>AQS有两个自定义方法，分别代表获取/释放资源逻辑tryacquire，tryrelease</p> <p>AQS维护一个CLH队列，类似synchronized的Waiting Queue，但是严格保证顺序；有多个等待队列Condition，类似synchronized的WaitSet，但是数量可以根据需要来。</p> <ul><li>获取资源时，只调用一次tryacquire，失败就进CLH，自旋，通常自旋不了几次就会陷入阻塞</li> <li>释放资源时，只调用一次tryrelease，成功，唤醒CLH的头部节点</li> <li>调用await时，线程进Condition队列尾，释放锁资源，阻塞</li> <li>signal方法，将Condition队列的头放到CLH的尾</li></ul> <p>更多的细节就不在这里说了</p> <h3 id="aqs和synchronized的行为模式对比"><a href="#aqs和synchronized的行为模式对比" class="header-anchor">#</a> AQS和synchronized的行为模式对比</h3> <p>你会发现，AQS和synchronized的行为模式差不多</p> <p>在获取资源上：</p> <ul><li>synchronized会「自适应自旋」很多次（10000次左右），失败在进入cxq队列阻塞</li> <li>AQS只会<strong>自旋一次</strong>(先调用一次tryAcquire)，然后几乎直接阻塞</li></ul> <p>在唤醒线程上：</p> <p>synchronized中被notify的线程比起AQS中被signal的线程「优先级更高」，更确定地说，是更容易获取到资源/锁</p> <p>在释放资源和阻塞线程上区别不大</p> <h3 id="基于aqs自定义同步器"><a href="#基于aqs自定义同步器" class="header-anchor">#</a> 基于AQS自定义同步器</h3> <p>很显然，我们只需要继承 AbstractQueuedSynchronizer(AQS)，然后自定义获取/释放逻辑就行了</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span>
 <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span>
 <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span>
 <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span>
 <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>因为像 ReentrantLock，CountDownLatch 这些鼎鼎大名的工具类都是基于AQS写的，所以直接看它们的源码，就可以很好的理解如何自定义同步器了。</p> <h3 id="面试-讲讲aqs"><a href="#面试-讲讲aqs" class="header-anchor">#</a> 面试：讲讲AQS</h3> <p>是抽象队列同步器，抽象类，我们CountDownLatch，ReetrantLock都是基于它实现的。</p> <p>有两个<strong>核心属性</strong>：CLH队列，使用双向链表实现的。以及一个state状态，用volatile保证可见性。node双向链表节点是个内部类，有自己的状态 waitstate1表示 被删除  0默认  然后还有独占共享和传播Propagate。</p> <blockquote><p>获取锁成功， 什么也不干 ； 释放锁失败， 什么也不干</p></blockquote> <p>我先讲一下<strong>独占</strong>的：Acquire方法会先调用tryAcquire，那这是个模板方法，在AQS内部是直接抛异常处理的，我们常见的比如ReetrantLock就重写了这个方法，返回true代表获取资源成功，返回false会插入CLH尾部，自旋，判断是不是头节点，不是就阻塞。Release也是类似的，调用tryRelease尝试释放资源，如果false什么也不做，如果true，调用unparkSuccessor唤醒。</p> <p>然后这个unparkSuccessor是通过Lock Support实现的阻塞，这里再底层就是Unsafe类了。然后这个unparkSuccessor方法在共享模式也是用来实际唤醒节点的。</p> <p>然后<strong>共享</strong>的情况：获取资源差不多，tryAcquireShared成功直接返回，失败的话，也是自旋，但这里自旋成功以后的逻辑就不是unparkSuccessor，而是doReleaseShared。这个方法可以唤醒后续所有值得被唤醒的节点。release的话，失败也是什么都不做，成功的话，也是会doReleaseShared。</p> <p>这里核心的就是<strong>doReleaseShared</strong>方法，是死循环，如果head不变才会退出，那当唤醒成功，就会回到TryAcquire的那个循环里面，然后被唤醒的线程又会doReleaseShared，从而能够保证唤醒后续所有。</p> <p>然后<strong>关于State我补充一下</strong>，就是用来控制是否可以获取资源的。我这里拿CounDownLatch举个例子吧，这个类内部代码很短，就是一个Sync继承AQS，重写两个shared方法。它初始化State一个值，它就是 只有state=0才tryAcquire获取资源成功，其余情况都会进入阻塞状态。然后countdown方法是CAS让State-1，但是只有state=0才释放资源成功，从而唤醒所有被阻塞的线程。</p> <blockquote><p>大纲：</p> <p>先讲核心属性CLH 和 State</p> <p>然后讲acquire 和 release方法，共享和独占的区别</p> <p>亮点：共享如何唤醒后续线程</p> <p>最后举例说明state如何控制</p></blockquote> <h2 id="熟悉aqs后再看reentrantlock原理"><a href="#熟悉aqs后再看reentrantlock原理" class="header-anchor">#</a> 熟悉AQS后再看ReentrantLock原理</h2> <p>ReentrantLock是独占锁，可以公平/非公平，可重入。</p> <h3 id="抽象类sync"><a href="#抽象类sync" class="header-anchor">#</a> 抽象类Sync</h3> <p>独占锁要用Condition要实现isHeldExclusively这个方法</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="公共的释放资源逻辑"><a href="#公共的释放资源逻辑" class="header-anchor">#</a> 公共的释放资源逻辑</h4> <p>修改state（对volatile域的写）</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> free<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="非公平sync"><a href="#非公平sync" class="header-anchor">#</a> 非公平Sync</h3> <h4 id="获取资源-3"><a href="#获取资源-3" class="header-anchor">#</a> 获取资源</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h4 id="加锁lock"><a href="#加锁lock" class="header-anchor">#</a> 加锁lock</h4> <p>会先CAS一次，失败再acquire</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="公平sync"><a href="#公平sync" class="header-anchor">#</a> 公平Sync</h3> <p>在「公平 or 非公平」这个章节已经分析过公平 Sync 的原理了，核心就是<code>!hasQueuedPredecessors()</code>这个方法</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 在tryAcquire前做个判断</span>
<span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span> <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token class-name">Node</span> s<span class="token punctuation">;</span>
<span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 要么头节点的next为空，要么头节点的next就是线程自己</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="加锁lock-少做一次cas"><a href="#加锁lock-少做一次cas" class="header-anchor">#</a> 加锁lock：少做一次CAS</h4> <p>直接acquire，非公平会多一次CAS</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="trylock-time-实现原理"><a href="#trylock-time-实现原理" class="header-anchor">#</a> tryLock(time)实现原理</h3> <p>虽然sync写了lock方法，但是没写trylock方法呀，也就是除了lock其余的加锁方式是如何实现的？</p> <p>这些方法其实也被封装在AQS内部</p> <p>tryLock(time,unit)直接调用tryAcquireNanos，会先tryAcquire一次，失败再doAcquireNanos</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token function">doAcquireNanos</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>doAcquireNanos方法是不是很眼熟呢，实际上和acquireQueued差不多，只是自旋失败后阻塞前会检查是否超时，并且阻塞时也给了个时间避免一直阻塞下去</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">doAcquireNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanosTimeout<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">EXCLUSIVE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
                p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>
                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            nanosTimeout <span class="token operator">=</span> deadline <span class="token operator">-</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanosTimeout <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                nanosTimeout <span class="token operator">&gt;</span> spinForTimeoutThreshold<span class="token punctuation">)</span>
                <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>
            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h2 id="reentrantlock小结"><a href="#reentrantlock小结" class="header-anchor">#</a> ReentrantLock小结</h2> <p>特点：可选的公平性，可重入，排他锁，重，悲观锁</p> <p>原理：依托AQS实现，抽象Sync，对应两种公平/非公平Sync</p> <p>非公平：</p> <p>lock：</p> <ol><li>自旋一次，然后acquire方法（自旋就是指tryAcquire方法）</li> <li>acquire方法又会自旋一次，然后CAS加入CLH队列尾，CAS将前面节点改为SIGNAL然后阻塞</li></ol> <p>unlock：</p> <ol><li>修改state</li> <li>唤醒CLH队列头节点</li></ol> <p>await：</p> <ol><li>线程进Condition队列尾</li> <li>释放锁资源（unlock的逻辑一模一样走一遍）</li> <li>阻塞</li></ol> <p>signal：</p> <ol><li>将Condition队列的头放到CLH的尾</li> <li>没了</li></ol> <blockquote><p>当然signal的实现上还有其他细节，但细节是说不完的，理解核心就可以了</p></blockquote> <h3 id="synchronized和reentrantlock对比"><a href="#synchronized和reentrantlock对比" class="header-anchor">#</a> Synchronized和ReentrantLock对比</h3> <p>原理弄清楚了，顺便总结了几点Synchronized和ReentrantLock的区别：</p> <ol><li>Synchronized是JVM层次的锁实现，ReentrantLock是JDK层次的锁实现；</li> <li>Synchronized的锁状态是无法在代码中直接判断的，但是ReentrantLock可以通过<code>ReentrantLock#isLocked</code>判断；</li> <li>Synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的；</li> <li>Synchronized是不可以被中断的，而<code>ReentrantLock#lockInterruptibly</code>方法是可以被中断的；</li> <li>在发生异常时Synchronized会自动释放锁（由javac编译时自动实现），而ReentrantLock需要开发者在finally块中显示释放锁；</li> <li>ReentrantLock获取锁的形式有多种：如立即返回是否成功的tryLock(),以及等待指定时长的获取，更加灵活；</li> <li>Synchronized在特定的情况下<strong>对于已经在等待的线程</strong>是后来的线程先获得锁，而ReentrantLock对于<strong>已经在等待的线程</strong>一定是先来的线程先获得锁；</li></ol> <h3 id="synchronized和reentrantlock怎么选"><a href="#synchronized和reentrantlock怎么选" class="header-anchor">#</a> Synchronized和ReentrantLock怎么选</h3> <p>显然ReentrantLock是一把比Synchronized悲观的多的锁，但AQS为了能提供公平性这个特点，也是不得不悲观的。在有的场景下，这种悲观也不是坏事，反而Synchronized的接近万次的自旋在竞争激烈的场景下对CPU的计算资源是个不小的负担。因此能否说竞争激烈就用ReentrantLock呢？也仅仅是理论上可能优秀，还需要考虑的点有很多，实践才能出真知。</p> <h3 id="参考文档"><a href="#参考文档" class="header-anchor">#</a> 参考文档</h3> <p><a href="https://redspider.gitbook.io/concurrent/di-er-pian-yuan-li-pian/11" target="_blank" rel="noopener noreferrer">深入浅出Java多线程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html" target="_blank" rel="noopener noreferrer">JUC锁: 锁核心类AQS详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/java多线程/core/WaitNotify.html" class="prev">
        显示同步：wait/notify
      </a></span> <span class="next"><a href="/blog/java多线程/juc/Tools1.html">
        常见工具类：AQS 的应用
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.7b9df32b.js" defer></script><script src="/blog/assets/js/2.be714ec7.js" defer></script><script src="/blog/assets/js/1.26c7c9cc.js" defer></script><script src="/blog/assets/js/39.f04e5b6a.js" defer></script>
  </body>
</html>
