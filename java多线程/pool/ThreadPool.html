<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java线程池详解 | lun&#39;s blogs</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/blog/favicon.ico">
    <meta name="description" content="blog">
    
    <link rel="preload" href="/blog/assets/css/0.styles.56f5eb6c.css" as="style"><link rel="preload" href="/blog/assets/js/app.7b9df32b.js" as="script"><link rel="preload" href="/blog/assets/js/2.be714ec7.js" as="script"><link rel="preload" href="/blog/assets/js/1.26c7c9cc.js" as="script"><link rel="preload" href="/blog/assets/js/41.3c800d8a.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.0d71bf2e.js"><link rel="prefetch" href="/blog/assets/js/11.cc81c248.js"><link rel="prefetch" href="/blog/assets/js/12.5e69cd14.js"><link rel="prefetch" href="/blog/assets/js/13.f0bc7bf2.js"><link rel="prefetch" href="/blog/assets/js/14.0188e855.js"><link rel="prefetch" href="/blog/assets/js/15.48a1e71e.js"><link rel="prefetch" href="/blog/assets/js/16.0f4182c9.js"><link rel="prefetch" href="/blog/assets/js/17.ec7b8f9d.js"><link rel="prefetch" href="/blog/assets/js/18.776522e2.js"><link rel="prefetch" href="/blog/assets/js/19.26561e06.js"><link rel="prefetch" href="/blog/assets/js/20.3e42feda.js"><link rel="prefetch" href="/blog/assets/js/21.fd4e7a00.js"><link rel="prefetch" href="/blog/assets/js/22.b59f6079.js"><link rel="prefetch" href="/blog/assets/js/23.e6b2d3ec.js"><link rel="prefetch" href="/blog/assets/js/24.736cfa99.js"><link rel="prefetch" href="/blog/assets/js/25.91176041.js"><link rel="prefetch" href="/blog/assets/js/26.146e299c.js"><link rel="prefetch" href="/blog/assets/js/27.56a57551.js"><link rel="prefetch" href="/blog/assets/js/28.13a846a1.js"><link rel="prefetch" href="/blog/assets/js/29.f71b59d6.js"><link rel="prefetch" href="/blog/assets/js/3.f34ea2f7.js"><link rel="prefetch" href="/blog/assets/js/30.bf0626f9.js"><link rel="prefetch" href="/blog/assets/js/31.47592684.js"><link rel="prefetch" href="/blog/assets/js/32.63f20fc3.js"><link rel="prefetch" href="/blog/assets/js/33.4852d9ec.js"><link rel="prefetch" href="/blog/assets/js/34.4f467138.js"><link rel="prefetch" href="/blog/assets/js/35.17d26444.js"><link rel="prefetch" href="/blog/assets/js/36.d0059312.js"><link rel="prefetch" href="/blog/assets/js/37.fc856e5d.js"><link rel="prefetch" href="/blog/assets/js/38.dc6b373c.js"><link rel="prefetch" href="/blog/assets/js/39.f04e5b6a.js"><link rel="prefetch" href="/blog/assets/js/4.885368ff.js"><link rel="prefetch" href="/blog/assets/js/40.b378efa5.js"><link rel="prefetch" href="/blog/assets/js/42.8b804f0c.js"><link rel="prefetch" href="/blog/assets/js/43.832aa078.js"><link rel="prefetch" href="/blog/assets/js/44.d1121c11.js"><link rel="prefetch" href="/blog/assets/js/45.b3e8ede1.js"><link rel="prefetch" href="/blog/assets/js/46.01e4202b.js"><link rel="prefetch" href="/blog/assets/js/47.489850e9.js"><link rel="prefetch" href="/blog/assets/js/48.3bd88d5f.js"><link rel="prefetch" href="/blog/assets/js/49.08c6f759.js"><link rel="prefetch" href="/blog/assets/js/5.d1dbc0b1.js"><link rel="prefetch" href="/blog/assets/js/50.c900e52a.js"><link rel="prefetch" href="/blog/assets/js/51.a59d8fbf.js"><link rel="prefetch" href="/blog/assets/js/52.0c715d23.js"><link rel="prefetch" href="/blog/assets/js/53.07715a2f.js"><link rel="prefetch" href="/blog/assets/js/54.e0d8cc69.js"><link rel="prefetch" href="/blog/assets/js/55.1efa3b0b.js"><link rel="prefetch" href="/blog/assets/js/56.ace3e6e3.js"><link rel="prefetch" href="/blog/assets/js/57.221667c1.js"><link rel="prefetch" href="/blog/assets/js/58.a786e5bd.js"><link rel="prefetch" href="/blog/assets/js/59.8a6dde26.js"><link rel="prefetch" href="/blog/assets/js/6.7ee6eed6.js"><link rel="prefetch" href="/blog/assets/js/60.0192f277.js"><link rel="prefetch" href="/blog/assets/js/61.75813485.js"><link rel="prefetch" href="/blog/assets/js/62.d8de1a01.js"><link rel="prefetch" href="/blog/assets/js/63.a08485a4.js"><link rel="prefetch" href="/blog/assets/js/64.7d19f572.js"><link rel="prefetch" href="/blog/assets/js/65.3f290d9a.js"><link rel="prefetch" href="/blog/assets/js/66.73f49082.js"><link rel="prefetch" href="/blog/assets/js/67.cb22e678.js"><link rel="prefetch" href="/blog/assets/js/68.22dc7228.js"><link rel="prefetch" href="/blog/assets/js/69.1f450482.js"><link rel="prefetch" href="/blog/assets/js/7.153b9c62.js"><link rel="prefetch" href="/blog/assets/js/70.03205c0b.js"><link rel="prefetch" href="/blog/assets/js/71.5b98edf5.js"><link rel="prefetch" href="/blog/assets/js/72.8be00756.js"><link rel="prefetch" href="/blog/assets/js/73.5e60394c.js"><link rel="prefetch" href="/blog/assets/js/74.a1100b64.js"><link rel="prefetch" href="/blog/assets/js/75.b47153bc.js"><link rel="prefetch" href="/blog/assets/js/76.b881f0b9.js"><link rel="prefetch" href="/blog/assets/js/77.eef60dd8.js"><link rel="prefetch" href="/blog/assets/js/78.b52fa32f.js"><link rel="prefetch" href="/blog/assets/js/79.9adc486f.js"><link rel="prefetch" href="/blog/assets/js/80.10b21516.js"><link rel="prefetch" href="/blog/assets/js/81.12c11cbc.js"><link rel="prefetch" href="/blog/assets/js/82.df4ae15b.js"><link rel="prefetch" href="/blog/assets/js/83.078b9ed6.js"><link rel="prefetch" href="/blog/assets/js/84.2d8ccb46.js"><link rel="prefetch" href="/blog/assets/js/85.4d5e44f4.js"><link rel="prefetch" href="/blog/assets/js/86.c32dda95.js"><link rel="prefetch" href="/blog/assets/js/87.c28d1f54.js"><link rel="prefetch" href="/blog/assets/js/88.c06457bb.js"><link rel="prefetch" href="/blog/assets/js/89.1febc082.js"><link rel="prefetch" href="/blog/assets/js/90.37985dbe.js"><link rel="prefetch" href="/blog/assets/js/91.9c3ebd93.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.02634ae8.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.56f5eb6c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="lun's blogs" class="logo"> <span class="site-name can-hide">lun's blogs</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/base/Exception.html" class="nav-link">
  异常
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Generics.html" class="nav-link">
  泛型
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Enum.html" class="nav-link">
  枚举
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Serialize.html" class="nav-link">
  Java序列化机制详解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Proxy.html" class="nav-link">
  动态代理
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Annotation.html" class="nav-link">
  深入理解Java注解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream1.html" class="nav-link">
  Stream源码分析(上)
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream2.html" class="nav-link">
  Stream源码分析(下)
</a></li></ul></div></div><div class="nav-item"><a href="/blog/java多线程/" class="nav-link">
  Java多线程
</a></div><div class="nav-item"><a href="/blog/jvm/" class="nav-link">
  JVM
</a></div><div class="nav-item"><a href="/blog/redis/" class="nav-link">
  Redis
</a></div><div class="nav-item"><a href="/blog/blogs/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="https://juejin.cn/user/2159878519134157" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/base/Exception.html" class="nav-link">
  异常
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Generics.html" class="nav-link">
  泛型
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Enum.html" class="nav-link">
  枚举
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Serialize.html" class="nav-link">
  Java序列化机制详解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Proxy.html" class="nav-link">
  动态代理
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Annotation.html" class="nav-link">
  深入理解Java注解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream1.html" class="nav-link">
  Stream源码分析(上)
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream2.html" class="nav-link">
  Stream源码分析(下)
</a></li></ul></div></div><div class="nav-item"><a href="/blog/java多线程/" class="nav-link">
  Java多线程
</a></div><div class="nav-item"><a href="/blog/jvm/" class="nav-link">
  JVM
</a></div><div class="nav-item"><a href="/blog/redis/" class="nav-link">
  Redis
</a></div><div class="nav-item"><a href="/blog/blogs/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="https://juejin.cn/user/2159878519134157" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" aria-current="page" class="sidebar-link">一、前言</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>二、Java并发基础知识</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>三、锁与同步器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>四、JUC</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>五、线程池</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java多线程/pool/ThreadPool.html" class="active sidebar-link">Java线程池详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#什么是线程池" class="sidebar-link">什么是线程池</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#线程池的好处" class="sidebar-link">线程池的好处</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#java线程池快速开始" class="sidebar-link">Java线程池快速开始</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#线程池的创建方式" class="sidebar-link" style="padding-left:3rem;">线程池的创建方式</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#java线程池体系结构" class="sidebar-link">Java线程池体系结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#executor接口" class="sidebar-link" style="padding-left:3rem;">Executor接口</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#executorservice接口" class="sidebar-link" style="padding-left:3rem;">ExecutorService接口</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#abstractexecutorservice抽象类" class="sidebar-link" style="padding-left:3rem;">AbstractExecutorService抽象类</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#threadpoolexecutor源码剖析" class="sidebar-link">ThreadPoolExecutor源码剖析</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#核心字段" class="sidebar-link">核心字段</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#ctl-行为控制核心" class="sidebar-link">ctl：行为控制核心</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#主要字段" class="sidebar-link">主要字段</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#线程池工作原理概述" class="sidebar-link">线程池工作原理概述</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#threadfactory-线程工厂" class="sidebar-link">ThreadFactory：线程工厂</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#rejected-handler-拒绝策略" class="sidebar-link">Rejected...Handler：拒绝策略</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#在线程池中真正执行任务的worker" class="sidebar-link">在线程池中真正执行任务的Worker</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#addworker-新增worker" class="sidebar-link" style="padding-left:3rem;">addWorker：新增Worker</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#线程复用核心原理-start" class="sidebar-link" style="padding-left:3rem;">线程复用核心原理：start</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#重新审视线程池状态" class="sidebar-link">重新审视线程池状态</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#线程池状态的转换" class="sidebar-link">线程池状态的转换</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#shutdown-转化为shutdown" class="sidebar-link" style="padding-left:3rem;">shutdown：转化为SHUTDOWN</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#shutdownnow-转化为stop" class="sidebar-link" style="padding-left:3rem;">shutdownNow：转化为STOP</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#tryterminate-可能的终止" class="sidebar-link" style="padding-left:3rem;">tryTerminate：可能的终止</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#线程池的构造方法" class="sidebar-link">线程池的构造方法</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#核心方法-execute-主要工作原理" class="sidebar-link">核心方法：execute（主要工作原理）</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#线程池的其他细节" class="sidebar-link">线程池的其他细节</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#核心线程预热" class="sidebar-link">核心线程预热</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#线程池异常处理-线程回收" class="sidebar-link">线程池异常处理/线程回收</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#如何区分核心-非核心线程" class="sidebar-link">如何区分核心/非核心线程</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#线程过期回收的实现" class="sidebar-link">线程过期回收的实现</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#单线程线程池有什么用" class="sidebar-link">单线程线程池有什么用</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#自定义线程池实战" class="sidebar-link">自定义线程池实战</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#线程池的参数配置问题" class="sidebar-link">线程池的参数配置问题</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#参数配置解决方案" class="sidebar-link">参数配置解决方案</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#打破常规逻辑-tomcat线程池" class="sidebar-link">打破常规逻辑：Tomcat线程池</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#常见面试题" class="sidebar-link">常见面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#execute和submit的区别" class="sidebar-link">execute和submit的区别</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#为什么worker要继承aqs实现锁" class="sidebar-link">为什么Worker要继承AQS实现锁</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#提交任务的方式有哪些" class="sidebar-link">提交任务的方式有哪些</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#invokeall-执行所有任务" class="sidebar-link" style="padding-left:3rem;">invokeAll：执行所有任务</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#说一下线程池里面的几把锁" class="sidebar-link">说一下线程池里面的几把锁</a></li><li class="sidebar-sub-header"><a href="/blog/java多线程/pool/ThreadPool.html#线程池如何处理异常" class="sidebar-link">线程池如何处理异常</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>六、补充</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java线程池详解"><a href="#java线程池详解" class="header-anchor">#</a> Java线程池详解</h1> <blockquote></blockquote> <h2 id="什么是线程池"><a href="#什么是线程池" class="header-anchor">#</a> 什么是线程池</h2> <p>线程池是一种线程资源，我们通过把线程<strong>池化</strong>，可以带来许多好处</p> <h3 id="线程池的好处"><a href="#线程池的好处" class="header-anchor">#</a> 线程池的好处</h3> <ul><li>创建/销毁线程需要消耗系统资源，线程池可以<strong>复用已创建的线程</strong></li> <li><strong>控制并发的数量</strong>。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）</li> <li><strong>可以对线程做统一管理、监控、调优</strong>。</li></ul> <p>线程池的应用非常丰富，随便翻开一个开源项目都能看到线程池的身影。</p> <h2 id="java线程池快速开始"><a href="#java线程池快速开始" class="header-anchor">#</a> Java线程池快速开始</h2> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建线程池</span>
        <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 向线程池提交任务</span>
            executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 关闭线程池</span>
        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 等待所有任务完成</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>executor<span class="token punctuation">.</span><span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程池所有任务完成&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h4 id="线程池的创建方式"><a href="#线程池的创建方式" class="header-anchor">#</a> 线程池的创建方式</h4> <p>主要有两种：</p> <ol><li>new ThreadPoolExecutor</li> <li>通过Executors工具类创建线程池，这种方法本质是对第一种的封装</li></ol> <p>阿里规约禁止工程项目通过Executors工具类创建线程池，但规矩是死的人是活的，实际上像dubbo源码中也用到了Executors创建的线程池，但足以见得ThreadPoolExecutor的重要性。</p> <p>那现在的问题是：Java如何做到池化线程资源？我们知道一个线程只能被调用一次start方法，那么线程在执行完一个线程后，如何执行下一个任务？没有任务时线程就一直消耗资源吗？我们来扒一扒ThreadPoolExecutor源码</p> <h2 id="java线程池体系结构"><a href="#java线程池体系结构" class="header-anchor">#</a> Java线程池体系结构</h2> <p>!<img src="/blog/assets/img/image-20230921184819012.16df7706.png" alt="image-20230921184819012">
Java中的线程池顶层接口是<code>Executor</code>接口，<code>ThreadPoolExecutor</code>是这个接口的核心实现类， 我们从上往下慢慢看。</p> <h4 id="executor接口"><a href="#executor接口" class="header-anchor">#</a> Executor接口</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
    <span class="token comment">// 执行任务 Runnable是我们封装的线程体，是一段可执行的方法</span>
    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Executor往下走是ExecutorService</p> <h4 id="executorservice接口"><a href="#executorservice接口" class="header-anchor">#</a> ExecutorService接口</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ExecutorService</span> <span class="token keyword">extends</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
    <span class="token comment">// 关闭线程池</span>
    <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回未完成任务的列表</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> <span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 提供了3种submit，返回值都是Future</span>
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 共4种invoke 支持超时时间</span>
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Future</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">invokeAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> tasks<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">invokeAny</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> tasks<span class="token punctuation">,</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>ExecutorService是对Executor的增强，从提供执行任务的基础功能扩展：</p> <ul><li>增强了对线程池本身的管理功能，可以关闭线程池</li> <li>额外提供了3种有返回值的执行任务的方法，以及4种invoke的提交方法</li></ul> <p>关于invoke提交有啥用我们后面再聊，最核心的提交任务的方式是：execute &gt; submit</p> <p>在往下是AbstractExecutorService，看到是抽象类，那基本上就是对公共逻辑的实现封装了。</p> <h4 id="abstractexecutorservice抽象类"><a href="#abstractexecutorservice抽象类" class="header-anchor">#</a> AbstractExecutorService抽象类</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>AbstractExecutorService主要是对上面的3种submit和4种invoke的实现，提供了两个newTaskFor方法。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>FutureTask不陌生，我们知道要获取异步执行线程的结果，光有callable是不够的，需要用FutureTask做一层封装</p> <p>而submit方法最终还是调用了execute方法，只是在调用前将Callable封装成FutureTask而已。</p> <p>所以到这我们可以基本确定：<strong>执行任务的核心就是execute方法</strong>。</p> <p>那最后就是ThreadPoolExecutor了。</p> <p>ThreadPoolExecutor源码也并不多，只有2000行，作为比较，ConcurrentHashMap有6000行。</p> <p>那么线程复用的核心就藏在这2000行代码里了。</p> <h2 id="threadpoolexecutor源码剖析"><a href="#threadpoolexecutor源码剖析" class="header-anchor">#</a> ThreadPoolExecutor源码剖析</h2> <h2 id="核心字段"><a href="#核心字段" class="header-anchor">#</a> 核心字段</h2> <p>ctl和Worker是至关重要的两个字段</p> <h3 id="ctl-行为控制核心"><a href="#ctl-行为控制核心" class="header-anchor">#</a> ctl：行为控制核心</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token constant">RUNNING</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 32 - 3 = 29</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">COUNT_BITS</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">SIZE</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token comment">// 1 &lt;&lt; 29 - 1 ，即CAPACITY为 后29位全1</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CAPACITY</span>   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">// runState is stored in the high-order bits(前3位)</span>
<span class="token comment">// Accept new tasks and process queued tasks</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">RUNNING</span>    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token comment">// Don't accept new tasks, but process queued tasks</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SHUTDOWN</span>   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token comment">// Don't accept new tasks, don't process queued tasks, and interrupt in-progress tasks</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">STOP</span>       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token comment">// All tasks have terminated, workerCount is zero, the thread transitioning to state TIDYING will run the terminated() hook method</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TIDYING</span>    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token comment">// terminated() has completed</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TERMINATED</span> <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>源码上的注解非常长，也很详细，大致意思是这样的：</p> <p>ctl用一个字段封装了两个含义：</p> <ul><li>workerCount：the effective number of threads that have been permitted to start and not permitted to stop.</li> <li>runState：线程池的状态，共有5种，具体的含义已经在上方源码中注释</li></ul> <p>因为ctl有32位，因此：用3位表示runState（5种状态 &gt; 4），剩下的表示workerCount</p> <p>并且提供了取出这两个数据的方法：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token constant">CAPACITY</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token constant">CAPACITY</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="主要字段"><a href="#主要字段" class="header-anchor">#</a> 主要字段</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 1.2. 核心/最大线程数</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> corePoolSize<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">;</span>
<span class="token comment">// 3.4. 超时时间</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> allowCoreThreadTimeOut<span class="token punctuation">;</span>
<span class="token comment">// 5. 阻塞队列</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">;</span>
<span class="token comment">// 6. 线程工厂</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">;</span>
<span class="token comment">// 7. 拒绝策略</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">;</span>
<span class="token comment">// 锁 以及等待通知机制 线程池会添加/删除线程，就依赖mainLock来保证线程安全</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> termination <span class="token operator">=</span> mainLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 工作线程的集合</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Worker</span><span class="token punctuation">&gt;</span></span> workers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Worker</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>给它们进行了编号，实际上这些参数是可以通过构造方法自定义的。</p> <h3 id="线程池工作原理概述"><a href="#线程池工作原理概述" class="header-anchor">#</a> 线程池工作原理概述</h3> <p>现在有必要对这些字段有一些稍微的了解：</p> <p><strong>线程池的线程分为两种：核心线程，和非核心线程</strong>。用了两个字段维护它们的最大值，但需要注意：maximumPoolSize是所有线程数量的上限，而不单单是非核心线程的。</p> <p><strong>超时时间</strong>：线程是会占用资源的，瞬间的大量请求可能会导致线程池线程数量很多，但又回归平静没啥请求了，就会导致大量线程白白占用资源，尽管可以阻塞但仍然不够优雅。因此我们需要在空闲时能够释放它们。并且用allowCoreThreadTimeOut来控制是否核心线程允许超时过期，默认不允许。</p> <p><strong>阻塞队列</strong>：线程池在极端情况下会被提交很多任务，靠线程来不及一下子执行完，当然需要一个数据结构来存储这些线程，同时是个多线程场景，因此用了阻塞队列。</p> <p><strong>主锁mainLock</strong>：线程池在管理（创建和删除）线程时，也是会面临线程安全问题的，因此用这把锁来保证。</p> <p>对于一个新来的任务：</p> <ul><li>如果核心线程数量都还没满，就创建一个线程来执行；</li> <li>如果核心线程数满了，就放入阻塞队列中存储任务</li> <li>阻塞队列也满了，就尝试创建非核心线程来执行任务</li> <li>非核心线程数量也满了，只能触发拒绝策略</li></ul> <p>现在上面的字段会让你陌生的可能有ThreadFactory，RejectedExecutionHandler，Worker。我们依次来看：</p> <h3 id="threadfactory-线程工厂"><a href="#threadfactory-线程工厂" class="header-anchor">#</a> ThreadFactory：线程工厂</h3> <p>ThreadFactory比较好猜：就是工厂模式嘛</p> <p>源码也非常短，ThreadFactory接口只规定了一个方法：newThread</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> poolNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ThreadGroup</span> group<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> threadNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> namePrefix<span class="token punctuation">;</span>

    <span class="token class-name">DefaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SecurityManager</span> s <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        group <span class="token operator">=</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> s<span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>
                              <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        namePrefix <span class="token operator">=</span> <span class="token string">&quot;pool-&quot;</span> <span class="token operator">+</span>
                      poolNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                     <span class="token string">&quot;-thread-&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>group<span class="token punctuation">,</span> r<span class="token punctuation">,</span>
                              namePrefix <span class="token operator">+</span> threadNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                              <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token constant">NORM_PRIORITY</span><span class="token punctuation">)</span>
            t<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token constant">NORM_PRIORITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>这就解释了线程池中线程名字的由来，并且：非守护线程，优先级为5。当然ThreadFactory我们是可以自定义修改的，实际上在项目中也大都需要自定义，修改线程名字便于定位和排查问题。</p> <h3 id="rejected-handler-拒绝策略"><a href="#rejected-handler-拒绝策略" class="header-anchor">#</a> Rejected...Handler：拒绝策略</h3> <p>RejectedExecutionHandler是拒绝策略，即线程池不再允许放入任务时的行为。RejectedExecutionHandler是个接口，就一个方法。</p> <p>ThreadPoolExecutor提供四种拒绝处理的策略（RejectedExecutionHandler的实现类）为：</p> <ul><li><strong>ThreadPoolExecutor.AbortPolicy</strong>：<strong>默认拒绝处理策略</strong>，丢弃任务并抛出RejectedExecutionException</li> <li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：丢弃新来的任务，但是不抛出异常。</li> <li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</li> <li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：由调用线程处理该任务。</li></ul> <p>来看一下AbortPolicy的源码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionException</span><span class="token punctuation">(</span><span class="token string">&quot;Task &quot;</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                                         <span class="token string">&quot; rejected from &quot;</span> <span class="token operator">+</span>
                                         e<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>题外话：如果采取DiscardPolicy，一旦出现了有task被拒绝后再调用线程池的shutdownnow方法，无法使程序正常退出return 0;可以参考：<a href="https://juejin.cn/post/7118971011625648136" target="_blank" rel="noopener noreferrer">看起来是线程池的BUG，但是我认为是源码设计不合理。<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>但一般也没人会用DiscardPolicy吧</p></blockquote> <p>下面再看一下Worker</p> <h2 id="在线程池中真正执行任务的worker"><a href="#在线程池中真正执行任务的worker" class="header-anchor">#</a> 在线程池中真正执行任务的Worker</h2> <p>Worker是个内部类。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> 
    <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>
    <span class="token class-name">Runnable</span> firstTask<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>发现Worker居然继承了AQS，是个独占的锁</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>源码注释说到：这个锁是为了说明线程工作状态，无锁代表空闲，有锁代表正在工作，当然细节远不止这么一些，但我们主线任务是线程池的原理，这个稍后说。</p> <p><strong>构造方法</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// inhibit interrupts until runWorker</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>
    <span class="token comment">// 线程用ThreadFactory生成</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>发现构造方法仅在一处被调用，那就是addWorker。</p> <h4 id="addworker-新增worker"><a href="#addworker-新增worker" class="header-anchor">#</a> addWorker：新增Worker</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1. CAS自旋尝试将Ctl的workerCount + 1  </span>
         <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果超过线程数直接add失败</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">&gt;=</span> <span class="token constant">CAPACITY</span> <span class="token operator">||</span>
                    wc <span class="token operator">&gt;=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
   <span class="token comment">// 因为判断比较多 写的比较长 省略部分</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建Worker</span>
        w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">Thread</span> t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 获取锁</span>
            <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
            mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// Recheck 线程池状态，线程是否存活等</span>
                <span class="token comment">// 插入set集合</span>
                    workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;</span> largestPoolSize<span class="token punctuation">)</span>
                        largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>
                    workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 添加成功 启动线程</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>
            <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><p>正常情况：就是new一个Worker，维护一下HashSet，然后启动线程。</p> <h4 id="线程复用核心原理-start"><a href="#线程复用核心原理-start" class="header-anchor">#</a> 线程复用核心原理：start</h4> <p>其实要做到线程复用，因为start方法确定只能调用一次，那么问题肯定是处在start方法上，也就是Worker的run方法，而run直接调用runWorker方法。我们不妨来看一下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> wt <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Runnable</span> task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>
    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// allow interrupts</span>
    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 先执行firstTask，getTask方法就是从阻塞队列里取任务</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 检查是否需要中断自己，比如线程池状态变了</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 这是一个空方法，是一个扩展点，源码的注解是:</span>
                <span class="token comment">// may be used to re-initialize ThreadLocals, or to perform logging</span>
                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Throwable</span> thrown <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 执行任务</span>
                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>  <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 和beforeExecute一样是个空方法</span>
                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                task <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>
                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这个方法就是线程出现异常如何处理的关键，我们稍后单独分析</span>
        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>总之，先执行Worker创建时绑定的方法，然后死循环从阻塞队列中取任务并执行。</p> <p>Worker的start并不是单单执行一个任务，而是不断获取任务来执行，这就是线程复用的核心。</p> <p>Worker就差不多讲完了，当然还有很多细节我们后面再讲，线程池更多的就是对Worker的管理和调度。现在把目光重新聚焦于ThreadPoolExecutor本身：</p> <h2 id="重新审视线程池状态"><a href="#重新审视线程池状态" class="header-anchor">#</a> 重新审视线程池状态</h2> <p>虽然源码上有注解，但不了解线程池大致工作原理容易看不明白，现在了解了大致工作原理了，我们可以重新看线程池状态会有一个更清晰的认知。我们再回顾一下源码的注释：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// runState is stored in the high-order bits(前3位)</span>
<span class="token comment">// Accept new tasks and process queued tasks</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">RUNNING</span>    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token comment">// Don't accept new tasks, but process queued tasks</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SHUTDOWN</span>   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token comment">// Don't accept new tasks, don't process queued tasks, and interrupt in-progress tasks</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">STOP</span>       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token comment">// All tasks have terminated, workerCount is zero, the thread transitioning to state TIDYING will run the terminated() hook method</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TIDYING</span>    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token comment">// terminated() has completed</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TERMINATED</span> <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>我列了一张表格，会更加直观：</p> <table><thead><tr><th>线程池状态</th> <th>新来的任务</th> <th>阻塞队列中的任务</th> <th>执行任务中的线程</th> <th>空闲的线程</th></tr></thead> <tbody><tr><td>RUNNING</td> <td>接受</td> <td>正常执行</td> <td>正常执行</td> <td>阻塞</td></tr> <tr><td>SHUTDOWN</td> <td>拒绝</td> <td>正常执行</td> <td>正常执行</td> <td>中断</td></tr> <tr><td>STOP</td> <td>拒绝</td> <td>丢弃</td> <td>中断</td> <td>中断</td></tr> <tr><td>TIDYING</td> <td>拒绝</td> <td>没有任务</td> <td>没有线程</td> <td>没有线程</td></tr> <tr><td>TERMINATED</td> <td>拒绝</td> <td>没有任务</td> <td>没有线程</td> <td>没有线程</td></tr></tbody></table> <p>TIDYING和TERMINATED有啥区别？源码注释说的很清楚了：the thread transitioning to state TIDYING will run the terminated() hook method，大概就是：一旦到了TIDYING状态，就会调用terminated()方法，这个方法调用完，线程池就变为TERMINATED状态。</p> <h3 id="线程池状态的转换"><a href="#线程池状态的转换" class="header-anchor">#</a> 线程池状态的转换</h3> <p>我们new出来的线程池初始当然是RUNNING状态</p> <ul><li>一旦手动调用shutdown，就会转化为SHUTDOWN；</li> <li>一旦手动调用shutdownNow，就会转化为STOP；</li></ul> <p>等到SHUTDOWN或是STOP忙完了自己的事，线程池会自己陷入TIDYING，最后是TERMINATED。</p> <h4 id="shutdown-转化为shutdown"><a href="#shutdown-转化为shutdown" class="header-anchor">#</a> shutdown：转化为SHUTDOWN</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">checkShutdownAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// CAS 修改状态为shutdown</span>
        <span class="token function">advanceRunState</span><span class="token punctuation">(</span><span class="token constant">SHUTDOWN</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 中断空闲线程</span>
        <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">onShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hook for ScheduledThreadPoolExecutor </span>
        <span class="token comment">// 在ThreadPoolExecutor 这是个空方法</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h4 id="shutdownnow-转化为stop"><a href="#shutdownnow-转化为stop" class="header-anchor">#</a> shutdownNow：转化为STOP</h4> <p>大部分源码都和shutdown差不多，下面列出不同点：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// CAS的目标为 STOP 状态</span>
<span class="token function">advanceRunState</span><span class="token punctuation">(</span><span class="token constant">STOP</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 会中断所有线程</span>
<span class="token function">interruptWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将阻塞队列所有未完成的任务返回</span>
tasks <span class="token operator">=</span> <span class="token function">drainQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>返回的类型是<code>List&lt;Runnable&gt;</code>，实际类型是<code>ArrayList</code>。</p> <p>这两个方法的共同点是：最后都调用了<code>tryTerminate();</code>方法</p> <h4 id="tryterminate-可能的终止"><a href="#tryterminate-可能的终止" class="header-anchor">#</a> tryTerminate：可能的终止</h4> <p><code>tryTerminate();</code>方法被调用的地方很多，源码的注释是这样说的：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>This method must be called following any action that might make termination possible -- reducing worker count or removing tasks from the queue during shutdown.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>tryTerminate();</code>方法必须在任何可能导致线程池termination的地方被调用，比如：减少Worker数，在shutdown时删除阻塞队列中的任务。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">||</span>
            <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token constant">TIDYING</span><span class="token punctuation">)</span> <span class="token operator">||</span>
            <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token comment">// 中断一个空闲的线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Eligible to terminate</span>
            <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token constant">ONLY_ONE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// Worker数为0</span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
        mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 先转化为TIDYING</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token constant">TIDYING</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 空方法 </span>
                    <span class="token function">terminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 最后转化为TERMINATED</span>
                    ctl<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token constant">TERMINATED</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    termination<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// else retry on failed CAS</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><h2 id="线程池的构造方法"><a href="#线程池的构造方法" class="header-anchor">#</a> 线程池的构造方法</h2> <p>以下是<code>ThreadPoolExecutor</code>构造函数需要的参数，共7个：</p> <ul><li><strong>int corePoolSize</strong>：该线程池中<strong>核心线程数最大值</strong></li> <li><strong>int maximumPoolSize</strong>：该线程池中<strong>线程总数最大值</strong></li> <li><strong>long keepAliveTime</strong>：<strong>非核心线程闲置超时时长</strong></li> <li><strong>TimeUnit unit</strong>：keepAliveTime的单位</li> <li><strong>BlockingQueue workQueue</strong>：阻塞队列，维护着<strong>等待执行的Runnable任务对象</strong></li></ul> <blockquote><p>以上五个是必选项，剩下两个是可选项</p></blockquote> <ul><li><strong>ThreadFactory threadFactory</strong>创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。</li> <li><strong>RejectedExecutionHandler handler拒绝处理策略</strong>，线程数量大于最大线程数就会采用拒绝处理策略。</li></ul> <p>可选项默认的构造方法如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>
         <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> defaultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="核心方法-execute-主要工作原理"><a href="#核心方法-execute-主要工作原理" class="header-anchor">#</a> 核心方法：execute（主要工作原理）</h2> <p>线程池最重要的功能当然是执行任务，我们直接看execute方法</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 1.当前活跃的线程数小于corePoolSize,则调用addWorker创建核心线程执行任务</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
           <span class="token keyword">return</span><span class="token punctuation">;</span>
       c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 2.如果不小于corePoolSize，则将任务添加到workQueue队列(阻塞队列)</span>
    <span class="token comment">// 这里调用offer方法而非put，因为阻塞队列满了需要特殊处理，而不是像get阻塞等待消费者唤醒</span>
    <span class="token comment">// offer方法，要是竞争锁失败，不会等待直接返回false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2.1 如果线程池状态以及不是Running了，则remove这个任务，然后执行拒绝策略。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2.2 核心线程数为0的特殊情况</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 3.如果放入workQueue失败(workQueue满了)，则创建非核心线程执行任务，</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token comment">// 如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。</span>
         <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// addWorker(command, true) 第二个参数true表示核心线程，false表示非核心 </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>文字小结一下：</p> <ol><li>线程总数量 &lt; corePoolSize，无论是否有线程空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时）。</li> <li>线程总数量 &gt;= corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去阻塞队列中取任务来执行（体现了<strong>线程复用</strong>）。</li> <li>当阻塞队列满了，说明这个时候任务已经很多了，会创建非核心线程去执行这个任务。</li> <li>阻塞队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理</li></ol> <p>整个execute方法还是很清晰的，如果忘记了addWorker方法可以回顾一下上文。</p> <p>好，那么线程池最核心的部分就讲完了，是不是有点突然，才只看了一个execute方法，但那也是因为前文我们铺垫的足够久。当然从剖析源码的角度，我们还需要关注一下别的细节：</p> <h2 id="线程池的其他细节"><a href="#线程池的其他细节" class="header-anchor">#</a> 线程池的其他细节</h2> <h3 id="核心线程预热"><a href="#核心线程预热" class="header-anchor">#</a> 核心线程预热</h3> <ul><li>prestartCoreThread 创建一个核心线程</li> <li>prestartAllCoreThreads 创建核心线程直到满</li></ul> <p>其实就是调用了addWorker方法</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">prestartCoreThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize <span class="token operator">&amp;&amp;</span>
        <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="线程池异常处理-线程回收"><a href="#线程池异常处理-线程回收" class="header-anchor">#</a> 线程池异常处理/线程回收</h3> <p>在Worker线程的runWorker方法中，退出「不断从阻塞队列取任务并执行的循环」后，会执行processWorkerExit，要不是线程空闲太久了退出，要不是线程异常了退出，我们来看一下这个方法：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processWorkerExit</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">,</span> <span class="token keyword">boolean</span> completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 线程异常退出时 completedAbruptly为true</span>
    <span class="token comment">// CAS WorkerCount - 1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>completedAbruptly<span class="token punctuation">)</span> <span class="token comment">// If abrupt, then workerCount wasn't adjusted</span>
        <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 从HashSet中移除这个Worker对象</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        completedTaskCount <span class="token operator">+=</span> w<span class="token punctuation">.</span>completedTasks<span class="token punctuation">;</span>
        <span class="token comment">// 删除掉 这个Worker对象</span>
        workers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 可能终止线程池</span>
    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateLessThan</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 涉及极端情况的细节考虑 但如果是正常的线程过期 就直接return</span>
            <span class="token keyword">int</span> min <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> corePoolSize<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                min <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> min<span class="token punctuation">)</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// replacement not needed</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 重新添加一个Worker，非核心线程</span>
        <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>因此，如果线程池中的线程抛出异常没有处理，会把它移除掉，再添加一个新的线程进去。</p> <h3 id="如何区分核心-非核心线程"><a href="#如何区分核心-非核心线程" class="header-anchor">#</a> 如何区分核心/非核心线程</h3> <p>这里我们要提一个细节:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> corePoolSize<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>字段中有两个值，分别是核心线程数，和最大线程数，但只用了一个WorkerCount（ctl维护）统计线程数量，线程池是如何区分核心线程和非核心线程的？</p> <p>实际上线程池并不严格区分核心线程和非核心线程，因为从Worker的角度来说它们没有什么区别，因此线程池只在乎数量。下面马上来看一下回收线程时的判断：</p> <h3 id="线程过期回收的实现"><a href="#线程过期回收的实现" class="header-anchor">#</a> 线程过期回收的实现</h3> <p>我们之前在分析线程复用核心原理start的方法时，getTask方法是个黑盒，并且getTask返回null时Worker线程就会退出循环并执行<code>processWorkerExit(w, completedAbruptly);</code>，现在我们来看一下getTask这个方法：</p> <p>getTask()方法返回null的时机如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">&gt;</span> corePoolSize<span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Runnable</span> r <span class="token operator">=</span> timed <span class="token operator">?</span>
                    workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">NANOSECONDS</span><span class="token punctuation">)</span> <span class="token operator">:</span>
                    workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> r<span class="token punctuation">;</span>
                timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>allowsCoreThreadTimeOut：是否允许核心线程过期被回收</p></blockquote> <p>因此，要么允许核心线程过期，要么线程数超过了核心线程数，此时才会执行poll方法，可能返回null，因为：</p> <ul><li>take阻塞直到获取到任务</li> <li>poll(time,unit) ：阻塞一段时间，还没获取到任务，返回null</li></ul> <p>用了<code>allowCoreThreadTimeOut || wc &gt; corePoolSize;</code>这个判断，因此线程池不需要严格区分核心线程和非核心线程。</p> <p>那一旦返回了null，就可以用上文提到的processWorkerExit来处理。</p> <h3 id="单线程线程池有什么用"><a href="#单线程线程池有什么用" class="header-anchor">#</a> 单线程线程池有什么用</h3> <p>单线程线程池，再加上阻塞队列的FIFO特性，可以保证提交到该线程池的任务的有序性。</p> <h2 id="自定义线程池实战"><a href="#自定义线程池实战" class="header-anchor">#</a> 自定义线程池实战</h2> <p>熟悉了线程池工作原理，就可以自定义线程池并应用了，那么问题在于，线程池的构造函数复杂，该如何配置线程池的参数呢？</p> <h3 id="线程池的参数配置问题"><a href="#线程池的参数配置问题" class="header-anchor">#</a> 线程池的参数配置问题</h3> <p><strong>线程池的参数并不好配置</strong>。最核心的三个：corePoolSize、maximumPoolSize，workQueue</p> <p>IO密集型和CPU密集型运行起来的情况差异非常大。</p> <blockquote><p>CPU密集型：线程数等于CPU核数+1</p> <p>IO密集型：线程数可以多一些，来充分利用CPU资源</p> <p>像这个方案是太笼统了。</p></blockquote> <h3 id="参数配置解决方案"><a href="#参数配置解决方案" class="header-anchor">#</a> 参数配置解决方案</h3> <p>比较知名的有：disruptor、动态线程池等，也可以自己根据业务不断改善和调整。想了解动态线程池的可以参考：<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener noreferrer">Java线程池实现原理及其在美团业务中的实践<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="打破常规逻辑-tomcat线程池"><a href="#打破常规逻辑-tomcat线程池" class="header-anchor">#</a> 打破常规逻辑：Tomcat线程池</h2> <p>JAVA JDK线程池策略，比较适合处理 CPU 密集型任务，但是对于 I/O 密集型任务，如数据库查询，rpc 请求调用等，不是很友好，所以Tomcat在其基础上进行了扩展。</p> <p><strong>它里面的线程池的运行过程是先把最大线程数用完，然后再提交任务到队列里面去的。</strong></p> <p>tomcat的阻塞队列workqueue重写了<code>offer</code>（排队任务的方法），（还记得怎么回收非核心线程吗，getTask方法如果超过核心线程数，会调用offer而不是task，因此可能被回收）该方法中，当当前线程数大于核心线程数，小于最大线程数时，返回<code>false</code>，导致<code>workQueue.offer(command)</code>为<code>false</code>，进而导致该分支代码不被执行，执行<code>addWorker(command, false)</code>方法，创建新线程。</p> <p>核心源码offer方法如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 对offer方法的包装  </span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">force</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> parent<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionException</span><span class="token punctuation">(</span>sm<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">&quot;taskQueue.notRunning&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token comment">//forces the item onto the queue, to be used if the task is rejected</span>
    <span class="token punctuation">}</span>
<span class="token comment">// 重写offer方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//we can't do any checks</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//getPoolSize 方法是获取线程池中当前运行的线程数量</span>
        <span class="token comment">//也就是所有线程都创建完了，放入阻塞队列</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> parent<span class="token punctuation">.</span><span class="token function">getMaximumPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// getSubmittedCount 获取的是当前已经提交但是还未完成的任务的数量</span>
        <span class="token comment">// 其值是队列中的数量加上正在运行的任务的数量。</span>
        <span class="token comment">// 这块逻辑可能的情况就是，有些线程执行完了，空闲，那么我把任务放入队列里，就能立刻执行</span>
        <span class="token comment">// 没有必要再创建线程了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">getSubmittedCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//if we have less threads than maximum force creation of a new thread</span>
        <span class="token comment">// 这里就是实现创建线程的关键，return false就会去创建新线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>parent<span class="token punctuation">.</span><span class="token function">getMaximumPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//if we reached here, we need to add it to the queue</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>上文源码的parent是什么？</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>taskqueue<span class="token punctuation">.</span><span class="token function">setParent</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>构造线程池处有一行代码，设置了阻塞队列的parent为线程池</p> <p>更详细可以参考：<a href="https://juejin.cn/post/6844904138795401224" target="_blank" rel="noopener noreferrer">每天都在用，但你知道 Tomcat 的线程池有多努力吗？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="常见面试题"><a href="#常见面试题" class="header-anchor">#</a> 常见面试题</h2> <h3 id="execute和submit的区别"><a href="#execute和submit的区别" class="header-anchor">#</a> execute和submit的区别</h3> <p>submit本质只是将线程体（可能是callable，可能是runnable）封装成FutureTask再去执行execute方法</p> <ul><li>execute只能提交Runnable类型的任务，没有返回值；</li> <li>submit既能提交Runnable类型任务也能提交Callable类型任务，返回Future类型。</li> <li>execute方法提交的任务异常是直接抛出的；</li> <li>submit方法是是捕获了异常的，当调用FutureTask的get方法时，才会抛出异常。</li></ul> <blockquote><p>这种处理异常的方式不是被线程池所决定的，而是被FutureTask在try块捕获并封装到结果中，从而在get时才抛出。</p></blockquote> <h3 id="为什么worker要继承aqs实现锁"><a href="#为什么worker要继承aqs实现锁" class="header-anchor">#</a> 为什么Worker要继承AQS实现锁</h3> <p>这个锁是为了说明线程工作状态，无锁代表空闲，有锁代表正在执行任务。并且Worker是不可重入的。目的是不希望正在工作中的线程被中断。</p> <h3 id="提交任务的方式有哪些"><a href="#提交任务的方式有哪些" class="header-anchor">#</a> 提交任务的方式有哪些</h3> <p>有4种invoke，3种submit，和一个execute。</p> <p>submit是对execute的增强，主要是用FutureTask对线程体做了封装从而能够获取异步执行的结果。</p> <p>invoke是对功能的扩展，支持提交多个任务，并且所有（All）/某个（Any）任务执行完毕才返回，它们也都用FutureTask做了封装，支持获取执行结果。</p> <h4 id="invokeall-执行所有任务"><a href="#invokeall-执行所有任务" class="header-anchor">#</a> invokeAll：执行所有任务</h4> <p>线程池会把 list 里面的任务一个个的去执行，执行完成后返回一个 Futures 列表。</p> <p>invokeAll方法：</p> <ol><li>把传入进来的任务<strong>封装为一个 FutureTask 对象</strong>，先放到一个 ArrayList 里面，然后<strong>调用 execute 方法</strong>，也就是扔到线程池里面去执行。</li> <li>遍历每个Future 对象，调用get方法阻塞直到得到Future的结果</li></ol> <p><strong>invokeAll与shutdownNow潜在的bug</strong></p> <ul><li>在invokeAll期间执行shutdownNow方法，会导致有的任务阻塞在Future.get。因此程序无法退出。</li></ul> <p>shutdownNow返回未完成任务的列表，我们对list内的每个FutureTask执行cancel方法，从而使程序正常退出。</p> <p>但采用了DiscardPolicy，你没有任何地方让这个被静默处理的 Future 抛出异常，也没用任何地方能调用它的 cancel 方法，所以这里就会一直阻塞。</p> <h3 id="说一下线程池里面的几把锁"><a href="#说一下线程池里面的几把锁" class="header-anchor">#</a> 说一下线程池里面的几把锁</h3> <p>这个问题来自：<a href="https://juejin.cn/post/7025456717055918094" target="_blank" rel="noopener noreferrer">面试官：你给我说一下线程池里面的几把锁。<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>除了mainlock和Worker，阻塞队列里也有两把锁</p> <h3 id="线程池如何处理异常"><a href="#线程池如何处理异常" class="header-anchor">#</a> 线程池如何处理异常</h3> <p>首先，是线程任务自己可以用try catch把异常处理掉；如果任务没有处理异常，有线程自己的异常处理器来处理，当然这需要自定义线程工厂ThreadFactory，可以参考：<a href="https://juejin.cn/post/7281459744602587190" target="_blank" rel="noopener noreferrer">Java线程异常处理器<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。第三如果是execute方法提交，会直接抛出异常，submit会封装到FutureTask的结果中，等到get时才抛出。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/java多线程/juc/ConcurrentHashMap.html" class="prev">
        ConcurrentHashMap 源码剖析
      </a></span> <span class="next"><a href="/blog/java多线程/other/ThreadLocal.html">
        ThreadLocal：线程本地变量
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.7b9df32b.js" defer></script><script src="/blog/assets/js/2.be714ec7.js" defer></script><script src="/blog/assets/js/1.26c7c9cc.js" defer></script><script src="/blog/assets/js/41.3c800d8a.js" defer></script>
  </body>
</html>
