<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>GC 方法论 | lun&#39;s blogs</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/blog/favicon.ico">
    <meta name="description" content="blog">
    
    <link rel="preload" href="/blog/assets/css/0.styles.56f5eb6c.css" as="style"><link rel="preload" href="/blog/assets/js/app.7b9df32b.js" as="script"><link rel="preload" href="/blog/assets/js/2.be714ec7.js" as="script"><link rel="preload" href="/blog/assets/js/1.26c7c9cc.js" as="script"><link rel="preload" href="/blog/assets/js/70.03205c0b.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.0d71bf2e.js"><link rel="prefetch" href="/blog/assets/js/11.cc81c248.js"><link rel="prefetch" href="/blog/assets/js/12.5e69cd14.js"><link rel="prefetch" href="/blog/assets/js/13.f0bc7bf2.js"><link rel="prefetch" href="/blog/assets/js/14.0188e855.js"><link rel="prefetch" href="/blog/assets/js/15.48a1e71e.js"><link rel="prefetch" href="/blog/assets/js/16.0f4182c9.js"><link rel="prefetch" href="/blog/assets/js/17.ec7b8f9d.js"><link rel="prefetch" href="/blog/assets/js/18.776522e2.js"><link rel="prefetch" href="/blog/assets/js/19.26561e06.js"><link rel="prefetch" href="/blog/assets/js/20.3e42feda.js"><link rel="prefetch" href="/blog/assets/js/21.fd4e7a00.js"><link rel="prefetch" href="/blog/assets/js/22.b59f6079.js"><link rel="prefetch" href="/blog/assets/js/23.e6b2d3ec.js"><link rel="prefetch" href="/blog/assets/js/24.736cfa99.js"><link rel="prefetch" href="/blog/assets/js/25.91176041.js"><link rel="prefetch" href="/blog/assets/js/26.146e299c.js"><link rel="prefetch" href="/blog/assets/js/27.56a57551.js"><link rel="prefetch" href="/blog/assets/js/28.13a846a1.js"><link rel="prefetch" href="/blog/assets/js/29.f71b59d6.js"><link rel="prefetch" href="/blog/assets/js/3.f34ea2f7.js"><link rel="prefetch" href="/blog/assets/js/30.bf0626f9.js"><link rel="prefetch" href="/blog/assets/js/31.47592684.js"><link rel="prefetch" href="/blog/assets/js/32.63f20fc3.js"><link rel="prefetch" href="/blog/assets/js/33.4852d9ec.js"><link rel="prefetch" href="/blog/assets/js/34.4f467138.js"><link rel="prefetch" href="/blog/assets/js/35.17d26444.js"><link rel="prefetch" href="/blog/assets/js/36.d0059312.js"><link rel="prefetch" href="/blog/assets/js/37.fc856e5d.js"><link rel="prefetch" href="/blog/assets/js/38.dc6b373c.js"><link rel="prefetch" href="/blog/assets/js/39.f04e5b6a.js"><link rel="prefetch" href="/blog/assets/js/4.885368ff.js"><link rel="prefetch" href="/blog/assets/js/40.b378efa5.js"><link rel="prefetch" href="/blog/assets/js/41.3c800d8a.js"><link rel="prefetch" href="/blog/assets/js/42.8b804f0c.js"><link rel="prefetch" href="/blog/assets/js/43.832aa078.js"><link rel="prefetch" href="/blog/assets/js/44.d1121c11.js"><link rel="prefetch" href="/blog/assets/js/45.b3e8ede1.js"><link rel="prefetch" href="/blog/assets/js/46.01e4202b.js"><link rel="prefetch" href="/blog/assets/js/47.489850e9.js"><link rel="prefetch" href="/blog/assets/js/48.3bd88d5f.js"><link rel="prefetch" href="/blog/assets/js/49.08c6f759.js"><link rel="prefetch" href="/blog/assets/js/5.d1dbc0b1.js"><link rel="prefetch" href="/blog/assets/js/50.c900e52a.js"><link rel="prefetch" href="/blog/assets/js/51.a59d8fbf.js"><link rel="prefetch" href="/blog/assets/js/52.0c715d23.js"><link rel="prefetch" href="/blog/assets/js/53.07715a2f.js"><link rel="prefetch" href="/blog/assets/js/54.e0d8cc69.js"><link rel="prefetch" href="/blog/assets/js/55.1efa3b0b.js"><link rel="prefetch" href="/blog/assets/js/56.ace3e6e3.js"><link rel="prefetch" href="/blog/assets/js/57.221667c1.js"><link rel="prefetch" href="/blog/assets/js/58.a786e5bd.js"><link rel="prefetch" href="/blog/assets/js/59.8a6dde26.js"><link rel="prefetch" href="/blog/assets/js/6.7ee6eed6.js"><link rel="prefetch" href="/blog/assets/js/60.0192f277.js"><link rel="prefetch" href="/blog/assets/js/61.75813485.js"><link rel="prefetch" href="/blog/assets/js/62.d8de1a01.js"><link rel="prefetch" href="/blog/assets/js/63.a08485a4.js"><link rel="prefetch" href="/blog/assets/js/64.7d19f572.js"><link rel="prefetch" href="/blog/assets/js/65.3f290d9a.js"><link rel="prefetch" href="/blog/assets/js/66.73f49082.js"><link rel="prefetch" href="/blog/assets/js/67.cb22e678.js"><link rel="prefetch" href="/blog/assets/js/68.22dc7228.js"><link rel="prefetch" href="/blog/assets/js/69.1f450482.js"><link rel="prefetch" href="/blog/assets/js/7.153b9c62.js"><link rel="prefetch" href="/blog/assets/js/71.5b98edf5.js"><link rel="prefetch" href="/blog/assets/js/72.8be00756.js"><link rel="prefetch" href="/blog/assets/js/73.5e60394c.js"><link rel="prefetch" href="/blog/assets/js/74.a1100b64.js"><link rel="prefetch" href="/blog/assets/js/75.b47153bc.js"><link rel="prefetch" href="/blog/assets/js/76.b881f0b9.js"><link rel="prefetch" href="/blog/assets/js/77.eef60dd8.js"><link rel="prefetch" href="/blog/assets/js/78.b52fa32f.js"><link rel="prefetch" href="/blog/assets/js/79.9adc486f.js"><link rel="prefetch" href="/blog/assets/js/80.10b21516.js"><link rel="prefetch" href="/blog/assets/js/81.12c11cbc.js"><link rel="prefetch" href="/blog/assets/js/82.df4ae15b.js"><link rel="prefetch" href="/blog/assets/js/83.078b9ed6.js"><link rel="prefetch" href="/blog/assets/js/84.2d8ccb46.js"><link rel="prefetch" href="/blog/assets/js/85.4d5e44f4.js"><link rel="prefetch" href="/blog/assets/js/86.c32dda95.js"><link rel="prefetch" href="/blog/assets/js/87.c28d1f54.js"><link rel="prefetch" href="/blog/assets/js/88.c06457bb.js"><link rel="prefetch" href="/blog/assets/js/89.1febc082.js"><link rel="prefetch" href="/blog/assets/js/90.37985dbe.js"><link rel="prefetch" href="/blog/assets/js/91.9c3ebd93.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.02634ae8.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.56f5eb6c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="lun's blogs" class="logo"> <span class="site-name can-hide">lun's blogs</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/base/Exception.html" class="nav-link">
  异常
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Generics.html" class="nav-link">
  泛型
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Enum.html" class="nav-link">
  枚举
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Serialize.html" class="nav-link">
  Java序列化机制详解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Proxy.html" class="nav-link">
  动态代理
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Annotation.html" class="nav-link">
  深入理解Java注解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream1.html" class="nav-link">
  Stream源码分析(上)
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream2.html" class="nav-link">
  Stream源码分析(下)
</a></li></ul></div></div><div class="nav-item"><a href="/blog/java多线程/" class="nav-link">
  Java多线程
</a></div><div class="nav-item"><a href="/blog/jvm/" class="nav-link router-link-active">
  JVM
</a></div><div class="nav-item"><a href="/blog/redis/" class="nav-link">
  Redis
</a></div><div class="nav-item"><a href="/blog/blogs/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="https://juejin.cn/user/2159878519134157" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/base/Exception.html" class="nav-link">
  异常
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Generics.html" class="nav-link">
  泛型
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Enum.html" class="nav-link">
  枚举
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Serialize.html" class="nav-link">
  Java序列化机制详解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Proxy.html" class="nav-link">
  动态代理
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Annotation.html" class="nav-link">
  深入理解Java注解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream1.html" class="nav-link">
  Stream源码分析(上)
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream2.html" class="nav-link">
  Stream源码分析(下)
</a></li></ul></div></div><div class="nav-item"><a href="/blog/java多线程/" class="nav-link">
  Java多线程
</a></div><div class="nav-item"><a href="/blog/jvm/" class="nav-link router-link-active">
  JVM
</a></div><div class="nav-item"><a href="/blog/redis/" class="nav-link">
  Redis
</a></div><div class="nav-item"><a href="/blog/blogs/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="https://juejin.cn/user/2159878519134157" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/jvm/" aria-current="page" class="sidebar-link">一、前言</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>二、认识Java类和对象</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>三、类加载子系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>四、垃圾回收子系统</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/jvm/gc/GCMethodology.html" aria-current="page" class="active sidebar-link">GC 方法论</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#gc进化史" class="sidebar-link">GC进化史</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#jdk8的gc器的争议" class="sidebar-link" style="padding-left:3rem;">JDK8的GC器的争议</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#稳定的g1" class="sidebar-link">稳定的G1</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#陨落的cms" class="sidebar-link">陨落的CMS</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#新兴的zgc、shenandoahgc" class="sidebar-link">新兴的ZGC、ShenandoahGC</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#a-no-op-gc-epsilon" class="sidebar-link">A No_Op GC：Epsilon</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#查看你的gc器" class="sidebar-link">查看你的GC器</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#gc基础知识" class="sidebar-link">GC基础知识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#gc的主要区域" class="sidebar-link">GC的主要区域</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#gc发生的时机" class="sidebar-link">GC发生的时机</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#判断对象是否可被回收" class="sidebar-link">判断对象是否可被回收</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#_1、引用计数法" class="sidebar-link">1、引用计数法</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#_2、可达性分析算法" class="sidebar-link">2、可达性分析算法</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#扫描栈的概念" class="sidebar-link" style="padding-left:3rem;">扫描栈的概念</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#gc-roots有哪些" class="sidebar-link" style="padding-left:3rem;">GC Roots有哪些</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#如何找到gc-roots" class="sidebar-link" style="padding-left:3rem;">如何找到GC Roots</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#stw-stop-the-world" class="sidebar-link">STW：stop the world</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#安全点的概念" class="sidebar-link">安全点的概念</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#如何通知线程暂停" class="sidebar-link" style="padding-left:3rem;">如何通知线程暂停</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#安全区域-对安全点的补充" class="sidebar-link">安全区域：对安全点的补充</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#并发的可达性分析-三色标记法" class="sidebar-link">并发的可达性分析：三色标记法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#错标问题-无需额外处理" class="sidebar-link">错标问题：无需额外处理</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#漏标问题-重要" class="sidebar-link">漏标问题（重要）</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#漏标问题发生的场景" class="sidebar-link" style="padding-left:3rem;">漏标问题发生的场景：</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#漏标问题解决方案" class="sidebar-link">漏标问题解决方案</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#_1、增量更新" class="sidebar-link" style="padding-left:3rem;">1、增量更新</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#_2、satb-snapshot-at-the-beginning" class="sidebar-link" style="padding-left:3rem;">2、SATB：snapshot at the beginning</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#记忆集-帮助partial-gc找gc-root" class="sidebar-link">记忆集：帮助Partial GC找GC Root</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#rset-抽象概念" class="sidebar-link">RSet：抽象概念</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#rset的实现" class="sidebar-link">RSet的实现</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#card-table-仅仅是特殊的实现" class="sidebar-link" style="padding-left:3rem;">Card Table：仅仅是特殊的实现</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#常见误区" class="sidebar-link" style="padding-left:4rem;">常见误区</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#g1-per-region-remembered-set" class="sidebar-link" style="padding-left:3rem;">G1：per-region remembered set</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#rset写屏障-维护rset" class="sidebar-link" style="padding-left:3rem;">RSet写屏障：维护RSet</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#特殊的大对象" class="sidebar-link">特殊的大对象</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#判断常量是否可回收" class="sidebar-link">判断常量是否可回收</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#判断类class是否可回收" class="sidebar-link">判断类Class是否可回收</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#类加载器是否会被回收" class="sidebar-link">类加载器是否会被回收</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#gc算法-如何真正回收内存" class="sidebar-link">GC算法：如何真正回收内存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#_1、标记-清除算法" class="sidebar-link">1、标记-清除算法</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#_2、标记-复制算法" class="sidebar-link">2、标记-复制算法</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#_3、标记-整理算法" class="sidebar-link">3、标记-整理算法</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#分代收集基本思想" class="sidebar-link">分代收集基本思想</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#如何分代" class="sidebar-link">如何分代</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#如何确定对象所属的代" class="sidebar-link">如何确定对象所属的代</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#年龄-age-计数器" class="sidebar-link" style="padding-left:4rem;">年龄（Age）计数器</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#分代gc的类型" class="sidebar-link">分代GC的类型</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#minorgc-younggc-新生代gc" class="sidebar-link" style="padding-left:4rem;">MinorGC/YoungGC：新生代GC</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#major-gc-old-gc-老年代gc" class="sidebar-link" style="padding-left:4rem;">Major GC/Old GC：老年代GC</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#mixedgc-混合gc" class="sidebar-link" style="padding-left:4rem;">MixedGC：混合GC</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#fullgc-全面gc" class="sidebar-link" style="padding-left:4rem;">FullGC：全面GC</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#分配担保机制" class="sidebar-link">分配担保机制</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#minor-gc触发条件" class="sidebar-link">Minor GC触发条件</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#full-gc触发条件" class="sidebar-link">Full GC触发条件</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#lab-本地缓存区" class="sidebar-link">LAB：本地缓存区</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#用户线程-tlab" class="sidebar-link" style="padding-left:4rem;">用户线程：TLAB</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#gc线程-gclab-plab" class="sidebar-link" style="padding-left:4rem;">GC线程：GCLAB/PLAB</a></li><li class="sidebar-sub-header"><a href="/blog/jvm/gc/GCMethodology.html#参考文档" class="sidebar-link">参考文档</a></li></ul></li></ul></li><li><a href="/blog/jvm/gc/G1.html" class="sidebar-link">彻底搞懂 G1 的工作原理</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="gc-方法论"><a href="#gc-方法论" class="header-anchor">#</a> GC 方法论</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <ul><li>所有GC器都有RSet吗？存在部分垃圾收集的GC器几乎都有RSet</li> <li>Card Table和RSet是什么关系？
Card Table与Remembered Set的关系更像是HashMap与Map的关系。</li> <li>三色标记的漏标问题怎么解决？</li></ul> <p>如果关于以上问题有所疑问，相信看完这篇文章能够解答这些疑问。</p> <p>GC的具体实现是取决于垃圾回收器的。垃圾回收器同时也决定了堆内存空间如何被划分。那么不妨先来看一看各个版本的JDK默认的垃圾回收器是什么，有个整体的概念</p> <h2 id="gc进化史"><a href="#gc进化史" class="header-anchor">#</a> GC进化史</h2> <p>JDK8 之前属于古早版本</p> <p>JDK8 默认垃圾收集器是 Parallel Scavenge（新生代）+Parallel Old（老年代）</p> <p>JDK9 ~ 17 默认垃圾收集器仍然是G1</p> <h4 id="jdk8的gc器的争议"><a href="#jdk8的gc器的争议" class="header-anchor">#</a> JDK8的GC器的争议</h4> <blockquote><p>《深入理解 Java 虚拟机》中提到 JDK 9 之前的Server默认GC器是：</p> <p><code>Parallel Scavenge + Serial Old(PS MarkSweep)</code></p> <p>实际上JDK 7U4，由于 <code>Parallel</code> 的成熟，直接替换了Serial，所以 JDK 7u4 以后的 7 和 JDK 8 老年代默认使用的都是 <code>Parallel</code> 收集器。</p> <p>具体可以看这篇文章：<a href="https://blog.csdn.net/csdn_life18/article/details/129358752" target="_blank" rel="noopener noreferrer">研究了 2 天，终于知道 JDK 8 默认 GC 收集器了<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h3 id="稳定的g1"><a href="#稳定的g1" class="header-anchor">#</a> 稳定的G1</h3> <p>可以看到，G1 在大多数时间都是默认的GC器，看似是 GC 器的老大，但G1实际上也经过很多版本的优化</p> <p>JDK10：</p> <p>新增了Full GC （1）。采用<strong>并行化</strong>标记扫描压缩（mark-sweep-compact）GC算法，并使用与年轻代回收和混合回收相同数量的线程</p> <blockquote><p>G1的JDK10之前是 基于<strong>单线程</strong>标记扫描压缩算法（mark-sweep-compact）</p> <p>（1）：在以前G1的Full GC是直接交给serial old做的</p></blockquote> <p>JDK12:</p> <p>G1的可中断 mixed GC；G1能够立即归还未使用的部分Java堆内存给操作系统</p> <p>JDK14:</p> <p>Java 14 改进非一致性内存访问（NUMA）系统上的 G1 垃圾收集器的整体性能</p> <h3 id="陨落的cms"><a href="#陨落的cms" class="header-anchor">#</a> 陨落的CMS</h3> <p><strong>CMS从未被JDK采取为默认的GC，并且在JDK14被彻底废除了</strong>。</p> <blockquote><p>JDK14 同时弃用 ParallelScavenge 和 SerialOld GC 的组合</p></blockquote> <p>当然CMS在参数配置足够优秀契合的情况，还是不错的，只是配置太复杂了：CMS 的参数有 72 个，而 G1 的参数只有 26 个。</p> <h3 id="新兴的zgc、shenandoahgc"><a href="#新兴的zgc、shenandoahgc" class="header-anchor">#</a> 新兴的ZGC、ShenandoahGC</h3> <p>JDK11：首次推出ZGC</p> <p>JDK12：首次推出ShenandoahGC</p> <p>JDK15：ZGC正式作为新特性，但仍属于实验阶段</p> <p>看下表就知道他们的强悍了。</p> <table><thead><tr><th>对比项</th> <th>G1</th> <th>ZGC</th> <th>ShenandoahGC</th></tr></thead> <tbody><tr><td>是否支持并发回收</td> <td>不支持</td> <td>支持</td> <td>支持</td></tr> <tr><td>最大堆空间大小</td> <td>达到上百GB停顿时间会很长</td> <td>16TB</td> <td>256TB</td></tr> <tr><td>平均停顿</td> <td>500ms以内</td> <td>10ms以内</td> <td>1~20ms左右</td></tr> <tr><td>是否支持指针压缩</td> <td>支持</td> <td>不支持</td> <td>支持</td></tr></tbody></table> <h3 id="a-no-op-gc-epsilon"><a href="#a-no-op-gc-epsilon" class="header-anchor">#</a> A No_Op GC：Epsilon</h3> <p>JDK11推出。</p> <p>Epsilon被描述为<code>A No_Op GC</code>。是指不会对内存进行回收。实际上<strong>任何GC器都要负责分配和管理堆内存</strong>。</p> <p>Epsilon的由来：</p> <p>JVM的架构是三个系统：类加载，运行时数据区，和执行引擎。但是GC器实际上决定了运行时数据区的堆的内存划分，并且还要负责与执行引擎的协作，这导致了实现GC的耦合度较高。 因此需要剥离出这样一个**『自动内存管理系统』**接口。Epsilon是对这个接口的实现。</p> <p>Epsilon本身不进行任何GC操作，它在启动时速度快，运行负载小，在测试环境有它的用武之地。</p> <h3 id="查看你的gc器"><a href="#查看你的gc器" class="header-anchor">#</a> 查看你的GC器</h3> <p>输入如下命令</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>java -XX:+PrintCommandLineFlags -version
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>会得到这样一行代表GC参数，对应你具体使用的GC器</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UseParallelGC</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>还有一种方法：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">GarbageCollectorMXBean</span><span class="token punctuation">&gt;</span></span> beans <span class="token operator">=</span>                                                            <span class="token class-name">ManagementFactory</span><span class="token punctuation">.</span><span class="token function">getGarbageCollectorMXBeans</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">GarbageCollectorMXBean</span> bean <span class="token operator">:</span> beans<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="gc基础知识"><a href="#gc基础知识" class="header-anchor">#</a> GC基础知识</h2> <p>这部分是讲具体GC器的基础，所有GC通用，必须掌握。</p> <h3 id="gc的主要区域"><a href="#gc的主要区域" class="header-anchor">#</a> GC的主要区域</h3> <p>主要是堆。栈和PC不会被GC，方法区的Class信息几乎不会被GC（详见类的卸载，条件很苛刻）</p> <p>JDK11的ZGC更是直接不支持类的卸载了，并且JVM规范不要求必须对方法区GC</p> <h3 id="gc发生的时机"><a href="#gc发生的时机" class="header-anchor">#</a> GC发生的时机</h3> <p>一般取决于具体的GC器</p> <h2 id="判断对象是否可被回收"><a href="#判断对象是否可被回收" class="header-anchor">#</a> 判断对象是否可被回收</h2> <h3 id="_1、引用计数法"><a href="#_1、引用计数法" class="header-anchor">#</a> 1、引用计数法</h3> <p>每个对象自身都携带一个引用计数器，被引用计数器+1</p> <p>实现简单，但无法解决循环引用问题，维护计数器的资源开销大。</p> <p>当然引用计数法存在的价值还是有的。</p> <blockquote><p>Python、Redis、Perl、PHP等，它们的对象都是采用该算法进行存活判定。</p> <p>Java的Netty的位于直接内存的Bytebuf也用的是引用计数法。</p></blockquote> <h3 id="_2、可达性分析算法"><a href="#_2、可达性分析算法" class="header-anchor">#</a> 2、可达性分析算法</h3> <p>通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p> <h4 id="扫描栈的概念"><a href="#扫描栈的概念" class="header-anchor">#</a> 扫描栈的概念</h4> <p>扫描栈用于存储所有待搜索的对象。也有paper叫它标记栈。</p> <h4 id="gc-roots有哪些"><a href="#gc-roots有哪些" class="header-anchor">#</a> GC Roots有哪些</h4> <p><strong>哪些对象可以作为 GC Roots 呢？</strong></p> <ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li> <li>本地方法栈 JNI (Native 方法)中引用的对象</li> <li>方法区中类静态属性引用的对象</li> <li>方法区中运行时常量池中常量引用的对象，字符串常量池里的引用也是</li> <li>所有被同步锁持有的对象</li> <li>系统对象：系统的三个类加载器，基本数据类型的class</li></ul> <p><strong>除此以外，在部分GC/分代GC时，还会有一些对象加入作为GC Roots，但这就取决于具体的GC器/JVM了</strong></p> <blockquote><p><strong>对象可以被回收，就代表一定会被回收吗？</strong></p> <p>不是。要真正宣告一个对象死亡，至少要经历两次标记过程。</p></blockquote> <h4 id="如何找到gc-roots"><a href="#如何找到gc-roots" class="header-anchor">#</a> 如何找到GC Roots</h4> <blockquote><p>这一步一定是STW的。否则会导致结果的不准确。</p></blockquote> <p>虽然我们明确知道哪些对象可以作为 GC Roots ，但是遍历整个方法区，栈，常量池等，显然效率太低。</p> <p>HotSpot使用OopMap来实现，他将所有可能的GC Roots记录下来，这样直接从OopMap里就可以拿到GC Roots</p> <p>但是，会导致OopMap变化的操作太多了，因此，只会在安全点记录OopMap</p> <h3 id="stw-stop-the-world"><a href="#stw-stop-the-world" class="header-anchor">#</a> STW：stop the world</h3> <p><strong>STW</strong>：暂停所有用户线程</p> <p>在找到GC Roots的这个过程，是一定会导致STW的。</p> <p>暂停所有线程是需要一个合适的时机的，执行代码不是说停就能停的，至于原因涉及到了RSet的维护等等，比较复杂。总之专门有<strong>安全点和安全区域</strong>两个概念作为线程由于某种原因需要暂停的暂停点。当用户线程执行到安全点或安全区域的代码处才可以被暂停。</p> <h3 id="安全点的概念"><a href="#安全点的概念" class="header-anchor">#</a> 安全点的概念</h3> <p>安全点是一个线程可以放心地在此处暂停的位置。</p> <blockquote><p>安全点不仅仅与GC有关，还在别的方面影响着程序的运行</p></blockquote> <p>HotSpot中，安全点位置主要在：</p> <ol><li>方法返回之前</li> <li>方法调用之后</li> <li>抛出异常的位置</li> <li>循环的末尾</li></ol> <blockquote><p>『循环的末尾』这里又涉及到了一个可数/不可数循环的事情，具体可以看：</p> <p><a href="https://juejin.cn/post/7139741080597037063?searchId=202308281010178331533A3EFB14720017" target="_blank" rel="noopener noreferrer">Thread.sleep(0) - by why技术<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>关于安全点的进一步深入可以结合两篇文章一起看：</p> <p><a href="https://blog.csdn.net/zyqytsoft/article/details/131075899" target="_blank" rel="noopener noreferrer">深入浅出解析JVM中的Safepoint，可以入个门<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h4 id="如何通知线程暂停"><a href="#如何通知线程暂停" class="header-anchor">#</a> 如何通知线程暂停</h4> <p>实际上，JVM并不主动通知，而是设置一个标志。</p> <p>每条线程执行时主动轮询这个标志，当一个线程到达安全点后，发现中断标志为<code>true</code>时就自己中断挂起。</p> <p>JVM还会周期性地让所有线程进入安全点，由 <code>-XX:GuaranteedSafepointInterval</code>选项控制，该选项默认为 1000ms。由于各种各样的优化</p> <h3 id="安全区域-对安全点的补充"><a href="#安全区域-对安全点的补充" class="header-anchor">#</a> 安全区域：对安全点的补充</h3> <p>安全区域是对安全点的补充，处于安全区域的线程被视为进入安全点。想一下这样一个场景：发生了STW，但有些线程已经处于中断或者休眠状态，比如<code>Thread.sleep(1000)</code>。此时该线程需要告知JVM自己进入了安全区域，在该线程醒来时，需要判断自己是否可以退出安全区域，比如可达性分析算法是否执行完毕，然后才能正式醒来。</p> <h2 id="并发的可达性分析-三色标记法"><a href="#并发的可达性分析-三色标记法" class="header-anchor">#</a> 并发的可达性分析：三色标记法</h2> <p>CMS和G1在并发标记阶段，都采用了这个算法。</p> <p>首先，对象被分为三类：</p> <blockquote><ul><li>黑色：根对象，或者该对象与它的子对象都被扫描了</li> <li>灰色：对象本身被扫描，但还没扫描完该对象中的子对象</li> <li>白色：未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象</li></ul></blockquote> <p>三色标记流程：</p> <ol><li>起初所有对象为白色</li> <li>短暂的STW，找出所有GC Roots，标记为黑色，与GC Roots相连的为灰色</li> <li>遍历所有灰色点扫描直至没有灰色点/扫描栈为空</li> <li>短暂STW，纠正<strong>漏标问题</strong></li></ol> <p>三色标记的过程中，是并发的，即GC线程与用户线程同时工作，用户线程可能会导致对象的引用被改变，因此在并发标记结束后需要修正这一部分。</p> <h3 id="错标问题-无需额外处理"><a href="#错标问题-无需额外处理" class="header-anchor">#</a> 错标问题：无需额外处理</h3> <p>错标问题是：<strong>一个本该是白色的对象被标记为了黑色</strong>。</p> <p>一个原本被引用的对象，引用消失了，但已经被标记为黑色了。这会导致回收不及时，但这个对象在下次GC时也是大概率会被回收的。因此不需要额外关注。</p> <h3 id="漏标问题-重要"><a href="#漏标问题-重要" class="header-anchor">#</a> 漏标问题（重要）</h3> <p>漏标问题是：<strong>一个本该是黑色的对象被标记为了白色</strong>。</p> <p>漏标问题发生，会导致你的访问报出空指针异常。</p> <h4 id="漏标问题发生的场景"><a href="#漏标问题发生的场景" class="header-anchor">#</a> <strong>漏标问题发生的场景</strong>：</h4> <p>原本一个灰色指向一个白色，但这个引用消失了，与此同时，有一个黑色指向了这个白色。而黑色的点不会再扫描它指向的节点，这就导致了虽然黑色指向白色，但这个白色无法变为黑色。</p> <h3 id="漏标问题解决方案"><a href="#漏标问题解决方案" class="header-anchor">#</a> <strong>漏标问题解决方案</strong></h3> <p>漏标问题发生的必要条件：</p> <ul><li>灰色对象断开了与白色对象的引用</li> <li>已经标为黑色的对象重新与白色对象建立了引用关系</li></ul> <p>打破任一即可解决。</p> <p>因此，漏标问题有两种解决方案：</p> <ul><li><strong>增量更新：关注黑指向白的引用新增</strong></li> <li><strong>快照：关注灰指向白的引用减少</strong></li></ul> <h4 id="_1、增量更新"><a href="#_1、增量更新" class="header-anchor">#</a> 1、<strong>增量更新</strong></h4> <p><strong>跟踪黑指向白的增加</strong></p> <p>但新增黑指向白，记录这些黑色，并发标记完成后，重新标记为灰色，下次重新扫描属性。</p> <p>CMS采用增量更新的方案</p> <h4 id="_2、satb-snapshot-at-the-beginning"><a href="#_2、satb-snapshot-at-the-beginning" class="header-anchor">#</a> 2、SATB：snapshot at the beginning</h4> <p>顾名思义：就是<strong>在开始标记的时候生成一个存活对象的快照图</strong>。</p> <p>SATB关注灰–&gt;白的消失</p> <p>G1、ZGC采用了SATB，具体的实现取决于GC器</p> <h2 id="记忆集-帮助partial-gc找gc-root"><a href="#记忆集-帮助partial-gc找gc-root" class="header-anchor">#</a> 记忆集：帮助Partial GC找GC Root</h2> <p>在做Young GC时，我们只对新生代清理，因此不希望扫描老年代，避免整堆扫描，从而提高效率。但可达性分析法的GC Roots可能在老年代，也可能在新生代。</p> <p><strong>如果从在老年代的GC Roots直接开始可达性分析，那必然会导致整堆扫描。</strong></p> <p>因此我们需要记录<strong>哪些新生代是被老年代引用的</strong></p> <blockquote><p>一个作为GC Root的老年代，可能引用另一个老年代，从而引用一个新生代</p> <p>一个本该被GC的对象没有被GC是允许的，但<strong>一个不该被GC的对象被GC了就会带来空指针异常等糟糕情况</strong></p> <p>因此：所有被老年代引用的新生代，都可以作为Young GC的GC Roots。</p></blockquote> <p>前面分代的例子只是为了让你更好的理解记忆集的作用。那实际上，不仅仅是分代需要记忆集，所有涉及到<strong>部分GC</strong>的垃圾收集器都需要记忆集来避免整堆扫描。</p> <h3 id="rset-抽象概念"><a href="#rset-抽象概念" class="header-anchor">#</a> RSet：抽象概念</h3> <p><strong>Remembered Set是一种抽象概念</strong>。Remembered Set是在实现部分垃圾收集（partial GC）时用于记录从非收集部分指向收集部分的指针的<strong>集合</strong>的抽象数据结构。</p> <blockquote><p>R大说的：<a href="https://hllvm-group.iteye.com/group/topic/21468#post-272070" target="_blank" rel="noopener noreferrer">https://hllvm-group.iteye.com/group/topic/21468#post-272070<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h3 id="rset的实现"><a href="#rset的实现" class="header-anchor">#</a> RSet的实现</h3> <p>那到底怎么记录分区的引用情况？一般有三种：</p> <ul><li>字粒度：记录每一个老年代到新生代的引用，精确到字宽</li> <li>对象粒度：记录被老年代引用的新生代的对象</li> <li>card粒度：记录一块内存区域，只知道这个区域内有这样的指针</li></ul> <p>那具体的实现就取决于所有有分代概念的GC器了。但一般不会是字粒度。</p> <h4 id="card-table-仅仅是特殊的实现"><a href="#card-table-仅仅是特殊的实现" class="header-anchor">#</a> Card Table：仅仅是特殊的实现</h4> <h5 id="常见误区"><a href="#常见误区" class="header-anchor">#</a> 常见误区</h5> <p>很多文章都提及了Card Table。很多资料也直接把Card Table当作了Remembered Set。实际上Card Table，仅仅是对Card粒度的RSet的一种实现。这是一处常见误区。Card Table与Remembered Set的关系更像是HashMap与Map的关系。</p> <p>Card Table：使用字节数组来实现card的记录，每个card对应该数组里的一个bit或一个byte，用c语言实现是这样</p> <div class="language-C line-numbers-mode"><pre class="language-c"><code>    <span class="token keyword">struct</span> <span class="token class-name">CardTable</span> <span class="token punctuation">{</span>  
      byte table<span class="token punctuation">[</span>MAX_CARDTABLE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span><span class="token punctuation">;</span>  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>很多文章作者都有一个误区：就是但凡是个RSet，就一定会有这样一个字节数组，实际是不对的。</p> <blockquote><p>CMS以及之前的大部分的分代收集器为Card Table</p></blockquote> <h4 id="g1-per-region-remembered-set"><a href="#g1-per-region-remembered-set" class="header-anchor">#</a> G1：per-region remembered set</h4> <p>G1采用了per-region remembered set实现记忆集，per-region remembered set也简称RSet，因此这个RSet的概念也是经常被混淆。具体后面讲到G1再说。</p> <h4 id="rset写屏障-维护rset"><a href="#rset写屏障-维护rset" class="header-anchor">#</a> RSet写屏障：维护RSet</h4> <p>写屏障可以看做是对引用的修改的AOP。</p> <p>写前屏障：Pre-Write Barrier</p> <p>写后屏障：Post-Write Barrier</p> <p>写前屏障是关注引用的删除；写后屏障则是关注引用的新增。</p> <h3 id="特殊的大对象"><a href="#特殊的大对象" class="header-anchor">#</a> 特殊的大对象</h3> <p>大对象是指需要<strong>连续</strong>内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p> <p>分代的GC：大对象通常直接放在老年代，从而避免在 Eden 区和 Survivor 区之间的大量内存复制。</p> <p>分区的GC：G1专门有个区域存放大对象</p> <h3 id="判断常量是否可回收"><a href="#判断常量是否可回收" class="header-anchor">#</a> 判断常量是否可回收</h3> <p>假如在字符串常量池中存在字符串 &quot;abc&quot;，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 &quot;abc&quot; 就是废弃常量，如果这时发生内存回收的话而且有必要的话，&quot;abc&quot; 就会被系统清理出常量池了。</p> <h3 id="判断类class是否可回收"><a href="#判断类class是否可回收" class="header-anchor">#</a> 判断类Class是否可回收</h3> <p>必须同时满足以下三点，也<strong>仅仅是可以</strong>回收</p> <ol><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li> <li>加载该类的 <code>ClassLoader</code> 已经被回收。</li> <li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol> <h3 id="类加载器是否会被回收"><a href="#类加载器是否会被回收" class="header-anchor">#</a> 类加载器是否会被回收</h3> <p>java自带的，ext，bootstrap，app，不会被回收。</p> <p>自定义的，和普通类Class一样。</p> <h2 id="gc算法-如何真正回收内存"><a href="#gc算法-如何真正回收内存" class="header-anchor">#</a> GC算法：如何真正回收内存</h2> <h3 id="_1、标记-清除算法"><a href="#_1、标记-清除算法" class="header-anchor">#</a> 1、标记-清除算法</h3> <p>首先标记出所有不需要回收的对象，将他们的GC标记置为1，在标记完成后统一回收掉所有GC标记为0的对象。</p> <blockquote><p>标记-清除完成后会将所有GC标记复位为0，GC标记在markword中</p></blockquote> <p>缺点：</p> <ol><li>效率问题，搜索所有可达节点时间长</li> <li>空间问题（标记清除后会产生大量不连续的碎片）</li></ol> <h3 id="_2、标记-复制算法"><a href="#_2、标记-复制算法" class="header-anchor">#</a> 2、标记-复制算法</h3> <p>它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。主要不足是只使用了内存的一半。</p> <blockquote><p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p> <p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p></blockquote> <h3 id="_3、标记-整理算法"><a href="#_3、标记-整理算法" class="header-anchor">#</a> 3、标记-整理算法</h3> <p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p> <h2 id="分代收集基本思想"><a href="#分代收集基本思想" class="header-anchor">#</a> 分代收集基本思想</h2> <blockquote><p>JDK1.8普遍采用分代收集算法，但G1仅仅逻辑分代，物理不分代。</p> <p>JDK10以后的GC更是彻底抹去了分代的概念。</p></blockquote> <p>分代收集算法使得我们可以<strong>针对不同代选择更加合适的垃圾收集算法</strong>。</p> <h3 id="如何分代"><a href="#如何分代" class="header-anchor">#</a> 如何分代</h3> <p>一般将 java 堆分为<strong>新生代和老年代</strong>。</p> <p>新生代又分为Eden，s0，s1，比例为8:1:1。</p> <h3 id="如何确定对象所属的代"><a href="#如何确定对象所属的代" class="header-anchor">#</a> 如何确定对象所属的代</h3> <p>通过：年龄计数器</p> <h5 id="年龄-age-计数器"><a href="#年龄-age-计数器" class="header-anchor">#</a> 年龄（Age）计数器</h5> <p>虚拟机给每个对象一个对象年龄（Age）计数器。</p> <p>大部分情况，<strong>对象都会首先在 Eden 区域分配</strong>。</p> <p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。</p> <p>对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，<strong>当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中</strong>。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p> <h3 id="分代gc的类型"><a href="#分代gc的类型" class="header-anchor">#</a> 分代GC的类型</h3> <h5 id="minorgc-younggc-新生代gc"><a href="#minorgc-younggc-新生代gc" class="header-anchor">#</a> MinorGC/YoungGC：新生代GC</h5> <p><strong>只收集新生代</strong>。</p> <h5 id="major-gc-old-gc-老年代gc"><a href="#major-gc-old-gc-老年代gc" class="header-anchor">#</a> Major GC/Old GC：老年代GC</h5> <p><strong>只收集老年代</strong>。只有CMS有</p> <h5 id="mixedgc-混合gc"><a href="#mixedgc-混合gc" class="header-anchor">#</a> MixedGC：混合GC</h5> <p>对<strong>整个新生代空间及部分老年代</strong>的GC，只在G1有</p> <h5 id="fullgc-全面gc"><a href="#fullgc-全面gc" class="header-anchor">#</a> FullGC：全面GC</h5> <p>涵盖新生代、年老代以及<strong>元数据空间</strong></p> <h3 id="分配担保机制"><a href="#分配担保机制" class="header-anchor">#</a> <strong>分配担保机制</strong></h3> <p>意义：确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p> <p>只要<strong>老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小</strong>，就会进行 Minor GC，否则将进行 Full GC。</p> <h3 id="minor-gc触发条件"><a href="#minor-gc触发条件" class="header-anchor">#</a> Minor GC触发条件</h3> <p>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。（就是Eden区满了）</p> <h3 id="full-gc触发条件"><a href="#full-gc触发条件" class="header-anchor">#</a> Full GC触发条件</h3> <ol><li><strong>老年代满了</strong>，可能原因是大对象直接进入老年代、长期存活的对象进入老年代</li> <li><strong>元空间满了</strong>，Class加载太多</li> <li><strong>分配担保机制</strong>触发</li> <li>程序调用<code>System.gc()</code>，会<strong>建议JVM进行一次Full GC</strong>，但只有JVM发现内存占用较多时才会接受建议</li></ol> <h3 id="lab-本地缓存区"><a href="#lab-本地缓存区" class="header-anchor">#</a> LAB：本地缓存区</h3> <h5 id="用户线程-tlab"><a href="#用户线程-tlab" class="header-anchor">#</a> 用户线程：TLAB</h5> <p>new对象时，每个线程都有自己的TLAB，属于Eden区，可以直接在线程自己的TLAB分配对象</p> <h5 id="gc线程-gclab-plab"><a href="#gc线程-gclab-plab" class="header-anchor">#</a> GC线程：GCLAB/PLAB</h5> <p>GC线程的缓冲区，标记复制时，GC线程要把存活对象拷贝到一个Region，如果是新生代，则要放入Survivor区，这个提前分配的区域就叫<strong>GCLAB</strong>；</p> <p>如果是从新生代晋升到老年代，也有一个分配的Region叫<strong>PLAB</strong>。</p> <h3 id="参考文档"><a href="#参考文档" class="header-anchor">#</a> 参考文档</h3> <p><a href="https://www.pdai.tech/md/java/jvm/java-jvm-gc-g1.html" target="_blank" rel="noopener noreferrer">pdai.tech.GC - Java 垃圾回收器之G1详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/column/7057537880624726053" target="_blank" rel="noopener noreferrer">JVM成神路 - 竹子爱熊猫<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>周志明 《深入理解Java虚拟机》</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/jvm/architecture/ClassLoader2.html" class="prev">
        自定义类加载器的应用场景
      </a></span> <span class="next"><a href="/blog/jvm/gc/G1.html">
        彻底搞懂 G1 的工作原理
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.7b9df32b.js" defer></script><script src="/blog/assets/js/2.be714ec7.js" defer></script><script src="/blog/assets/js/1.26c7c9cc.js" defer></script><script src="/blog/assets/js/70.03205c0b.js" defer></script>
  </body>
</html>
