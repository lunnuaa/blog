<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis 事务 vs Lua | lun&#39;s blogs</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/blog/favicon.ico">
    <meta name="description" content="blog">
    
    <link rel="preload" href="/blog/assets/css/0.styles.56f5eb6c.css" as="style"><link rel="preload" href="/blog/assets/js/app.7b9df32b.js" as="script"><link rel="preload" href="/blog/assets/js/2.be714ec7.js" as="script"><link rel="preload" href="/blog/assets/js/1.26c7c9cc.js" as="script"><link rel="preload" href="/blog/assets/js/33.4852d9ec.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.0d71bf2e.js"><link rel="prefetch" href="/blog/assets/js/11.cc81c248.js"><link rel="prefetch" href="/blog/assets/js/12.5e69cd14.js"><link rel="prefetch" href="/blog/assets/js/13.f0bc7bf2.js"><link rel="prefetch" href="/blog/assets/js/14.0188e855.js"><link rel="prefetch" href="/blog/assets/js/15.48a1e71e.js"><link rel="prefetch" href="/blog/assets/js/16.0f4182c9.js"><link rel="prefetch" href="/blog/assets/js/17.ec7b8f9d.js"><link rel="prefetch" href="/blog/assets/js/18.776522e2.js"><link rel="prefetch" href="/blog/assets/js/19.26561e06.js"><link rel="prefetch" href="/blog/assets/js/20.3e42feda.js"><link rel="prefetch" href="/blog/assets/js/21.fd4e7a00.js"><link rel="prefetch" href="/blog/assets/js/22.b59f6079.js"><link rel="prefetch" href="/blog/assets/js/23.e6b2d3ec.js"><link rel="prefetch" href="/blog/assets/js/24.736cfa99.js"><link rel="prefetch" href="/blog/assets/js/25.91176041.js"><link rel="prefetch" href="/blog/assets/js/26.146e299c.js"><link rel="prefetch" href="/blog/assets/js/27.56a57551.js"><link rel="prefetch" href="/blog/assets/js/28.13a846a1.js"><link rel="prefetch" href="/blog/assets/js/29.f71b59d6.js"><link rel="prefetch" href="/blog/assets/js/3.f34ea2f7.js"><link rel="prefetch" href="/blog/assets/js/30.bf0626f9.js"><link rel="prefetch" href="/blog/assets/js/31.47592684.js"><link rel="prefetch" href="/blog/assets/js/32.63f20fc3.js"><link rel="prefetch" href="/blog/assets/js/34.4f467138.js"><link rel="prefetch" href="/blog/assets/js/35.17d26444.js"><link rel="prefetch" href="/blog/assets/js/36.d0059312.js"><link rel="prefetch" href="/blog/assets/js/37.fc856e5d.js"><link rel="prefetch" href="/blog/assets/js/38.dc6b373c.js"><link rel="prefetch" href="/blog/assets/js/39.f04e5b6a.js"><link rel="prefetch" href="/blog/assets/js/4.885368ff.js"><link rel="prefetch" href="/blog/assets/js/40.b378efa5.js"><link rel="prefetch" href="/blog/assets/js/41.3c800d8a.js"><link rel="prefetch" href="/blog/assets/js/42.8b804f0c.js"><link rel="prefetch" href="/blog/assets/js/43.832aa078.js"><link rel="prefetch" href="/blog/assets/js/44.d1121c11.js"><link rel="prefetch" href="/blog/assets/js/45.b3e8ede1.js"><link rel="prefetch" href="/blog/assets/js/46.01e4202b.js"><link rel="prefetch" href="/blog/assets/js/47.489850e9.js"><link rel="prefetch" href="/blog/assets/js/48.3bd88d5f.js"><link rel="prefetch" href="/blog/assets/js/49.08c6f759.js"><link rel="prefetch" href="/blog/assets/js/5.d1dbc0b1.js"><link rel="prefetch" href="/blog/assets/js/50.c900e52a.js"><link rel="prefetch" href="/blog/assets/js/51.a59d8fbf.js"><link rel="prefetch" href="/blog/assets/js/52.0c715d23.js"><link rel="prefetch" href="/blog/assets/js/53.07715a2f.js"><link rel="prefetch" href="/blog/assets/js/54.e0d8cc69.js"><link rel="prefetch" href="/blog/assets/js/55.1efa3b0b.js"><link rel="prefetch" href="/blog/assets/js/56.ace3e6e3.js"><link rel="prefetch" href="/blog/assets/js/57.221667c1.js"><link rel="prefetch" href="/blog/assets/js/58.a786e5bd.js"><link rel="prefetch" href="/blog/assets/js/59.8a6dde26.js"><link rel="prefetch" href="/blog/assets/js/6.7ee6eed6.js"><link rel="prefetch" href="/blog/assets/js/60.0192f277.js"><link rel="prefetch" href="/blog/assets/js/61.75813485.js"><link rel="prefetch" href="/blog/assets/js/62.d8de1a01.js"><link rel="prefetch" href="/blog/assets/js/63.a08485a4.js"><link rel="prefetch" href="/blog/assets/js/64.7d19f572.js"><link rel="prefetch" href="/blog/assets/js/65.3f290d9a.js"><link rel="prefetch" href="/blog/assets/js/66.73f49082.js"><link rel="prefetch" href="/blog/assets/js/67.cb22e678.js"><link rel="prefetch" href="/blog/assets/js/68.22dc7228.js"><link rel="prefetch" href="/blog/assets/js/69.1f450482.js"><link rel="prefetch" href="/blog/assets/js/7.153b9c62.js"><link rel="prefetch" href="/blog/assets/js/70.03205c0b.js"><link rel="prefetch" href="/blog/assets/js/71.5b98edf5.js"><link rel="prefetch" href="/blog/assets/js/72.8be00756.js"><link rel="prefetch" href="/blog/assets/js/73.5e60394c.js"><link rel="prefetch" href="/blog/assets/js/74.a1100b64.js"><link rel="prefetch" href="/blog/assets/js/75.b47153bc.js"><link rel="prefetch" href="/blog/assets/js/76.b881f0b9.js"><link rel="prefetch" href="/blog/assets/js/77.eef60dd8.js"><link rel="prefetch" href="/blog/assets/js/78.b52fa32f.js"><link rel="prefetch" href="/blog/assets/js/79.9adc486f.js"><link rel="prefetch" href="/blog/assets/js/80.10b21516.js"><link rel="prefetch" href="/blog/assets/js/81.12c11cbc.js"><link rel="prefetch" href="/blog/assets/js/82.df4ae15b.js"><link rel="prefetch" href="/blog/assets/js/83.078b9ed6.js"><link rel="prefetch" href="/blog/assets/js/84.2d8ccb46.js"><link rel="prefetch" href="/blog/assets/js/85.4d5e44f4.js"><link rel="prefetch" href="/blog/assets/js/86.c32dda95.js"><link rel="prefetch" href="/blog/assets/js/87.c28d1f54.js"><link rel="prefetch" href="/blog/assets/js/88.c06457bb.js"><link rel="prefetch" href="/blog/assets/js/89.1febc082.js"><link rel="prefetch" href="/blog/assets/js/90.37985dbe.js"><link rel="prefetch" href="/blog/assets/js/91.9c3ebd93.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.02634ae8.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.56f5eb6c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="lun's blogs" class="logo"> <span class="site-name can-hide">lun's blogs</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/base/Exception.html" class="nav-link">
  异常
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Generics.html" class="nav-link">
  泛型
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Enum.html" class="nav-link">
  枚举
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Serialize.html" class="nav-link">
  Java序列化机制详解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Proxy.html" class="nav-link">
  动态代理
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Annotation.html" class="nav-link">
  深入理解Java注解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream1.html" class="nav-link">
  Stream源码分析(上)
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream2.html" class="nav-link">
  Stream源码分析(下)
</a></li></ul></div></div><div class="nav-item"><a href="/blog/java多线程/" class="nav-link">
  Java多线程
</a></div><div class="nav-item"><a href="/blog/jvm/" class="nav-link">
  JVM
</a></div><div class="nav-item"><a href="/blog/redis/" class="nav-link router-link-active">
  Redis
</a></div><div class="nav-item"><a href="/blog/blogs/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="https://juejin.cn/user/2159878519134157" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/base/Exception.html" class="nav-link">
  异常
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Generics.html" class="nav-link">
  泛型
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Enum.html" class="nav-link">
  枚举
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Serialize.html" class="nav-link">
  Java序列化机制详解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Proxy.html" class="nav-link">
  动态代理
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Annotation.html" class="nav-link">
  深入理解Java注解
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream1.html" class="nav-link">
  Stream源码分析(上)
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/base/Stream2.html" class="nav-link">
  Stream源码分析(下)
</a></li></ul></div></div><div class="nav-item"><a href="/blog/java多线程/" class="nav-link">
  Java多线程
</a></div><div class="nav-item"><a href="/blog/jvm/" class="nav-link">
  JVM
</a></div><div class="nav-item"><a href="/blog/redis/" class="nav-link router-link-active">
  Redis
</a></div><div class="nav-item"><a href="/blog/blogs/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="https://juejin.cn/user/2159878519134157" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/redis/" aria-current="page" class="sidebar-link">一、前言</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>二、Redis数据类型</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>三、Redis功能特性</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/redis/feature/PubSub.html" class="sidebar-link">Redis 发布订阅：PubSub</a></li><li><a href="/blog/redis/feature/KeySpaceNotification.html" class="sidebar-link">监控 key 变化：Keyspace Notifications</a></li><li><a href="/blog/redis/feature/Persistence.html" class="sidebar-link">Redis 持久化：RDB &amp; AOF</a></li><li><a href="/blog/redis/feature/Lua.html" aria-current="page" class="active sidebar-link">Redis 事务 vs Lua</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#redis-事务基本使用" class="sidebar-link">Redis 事务基本使用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#_1、开启事务-multi" class="sidebar-link">1、开启事务：multi</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#_2、命令入列" class="sidebar-link">2、命令入列</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#_3、执行事务-exec" class="sidebar-link">3、执行事务：exec</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#_4、放弃事务-discard" class="sidebar-link">4、放弃事务：discard</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#redis-事务有acid吗" class="sidebar-link">Redis 事务有ACID吗</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#_1、原子性" class="sidebar-link">1、原子性</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#不支持回滚" class="sidebar-link" style="padding-left:3rem;">不支持回滚</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#_2、隔离性" class="sidebar-link">2、隔离性</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#监控-watch-乐观锁" class="sidebar-link" style="padding-left:3rem;">监控 watch：乐观锁</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#_3、持久性" class="sidebar-link">3、持久性</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#_4、一致性" class="sidebar-link">4、一致性</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#redis-事务的不足" class="sidebar-link">Redis 事务的不足</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#lua-脚本的基本使用" class="sidebar-link">Lua 脚本的基本使用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#执行脚本-eval" class="sidebar-link" style="padding-left:3rem;">执行脚本：EVAL</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#lua-操作-key-必须来自-keys" class="sidebar-link" style="padding-left:3rem;">Lua 操作 Key：必须来自 KEYS</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#lua-脚本执行-redis-命令-redis-call" class="sidebar-link" style="padding-left:3rem;">Lua 脚本执行 redis 命令：redis.call</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#不同的错误处理-redis-pcall" class="sidebar-link" style="padding-left:3rem;">不同的错误处理：redis.pcall</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#脚本缓存-sha1" class="sidebar-link">脚本缓存：SHA1</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#redis-7-0-新特性-eval-flags" class="sidebar-link">Redis 7.0 新特性：Eval flags</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#集群对-lua-的限制" class="sidebar-link">集群对 Lua 的限制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#为什么是-slot-而非-node" class="sidebar-link">为什么是 slot 而非 node</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#解决方案" class="sidebar-link">解决方案</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#_1、hashtags-保证-key-在同一节点" class="sidebar-link" style="padding-left:3rem;">1、HashTags：保证 key 在同一节点</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#_2、考虑数据类型的设计" class="sidebar-link" style="padding-left:3rem;">2、考虑数据类型的设计</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#_3、eval-flags-allow-cross-slot-keys" class="sidebar-link" style="padding-left:3rem;">3、Eval Flags：allow-cross-slot-keys</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#lua-的其它限制" class="sidebar-link">Lua 的其它限制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#执行时长限制" class="sidebar-link">执行时长限制</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#主从模式下-lua-的数据同步" class="sidebar-link">主从模式下 Lua 的数据同步</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#lua-常见命令" class="sidebar-link">Lua 常见命令</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#载入并执行脚本-eval" class="sidebar-link" style="padding-left:3rem;">载入并执行脚本：EVAL</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#执行载入的脚本-evalsha" class="sidebar-link" style="padding-left:3rem;">执行载入的脚本：EVALSHA</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#查询脚本是否已载入-exists" class="sidebar-link" style="padding-left:3rem;">查询脚本是否已载入：EXISTS</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#载入脚本-load" class="sidebar-link" style="padding-left:3rem;">载入脚本：LOAD</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#清除载入的脚本-flush" class="sidebar-link" style="padding-left:3rem;">清除载入的脚本：FLUSH</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#终止脚本的执行-script-kill" class="sidebar-link" style="padding-left:3rem;">终止脚本的执行：SCRIPT KILL</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#性能比较" class="sidebar-link">性能比较</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#使用成本" class="sidebar-link">使用成本</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#应用场景" class="sidebar-link">应用场景</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#什么时候该用事务" class="sidebar-link">什么时候该用事务</a></li><li class="sidebar-sub-header"><a href="/blog/redis/feature/Lua.html#参考文档" class="sidebar-link" style="padding-left:3rem;">参考文档</a></li></ul></li></ul></li><li><a href="/blog/redis/feature/Rollback.html" class="sidebar-link">为什么 Redis 不支持事务回滚</a></li><li><a href="/blog/redis/feature/DistributedLock.html" class="sidebar-link">基于 Redis 实现分布式锁</a></li><li><a href="/blog/redis/feature/Problems.html" class="sidebar-link">Redis 常见问题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>四、Redis高可用</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="redis-事务-vs-lua"><a href="#redis-事务-vs-lua" class="header-anchor">#</a> Redis 事务 vs Lua</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>Lua 脚本也能保证一定的原子性，这与 Redis 事务机制十分类似，为啥 Redis 会支持两种类似的机制呢？</p> <p>另外，在 stackoverflow 十几年前的远古帖子上还能看到有人引用官网的话如下：</p> <blockquote><p>&quot;we may deprecate and finally remove transactions&quot;</p></blockquote> <p><img src="/blog/assets/img/image-20240114164201804.3658ef09.png" alt="image-20240114164201804"></p> <p>但直至 Redis 7.0 版本，Redis 事务功能依然健在，而新版本的官网也找不到这句话了。</p> <p>所以，事务和 Lua 到底有何区别？我们应该如何做选择呢？</p> <p>我们先分别介绍一下事务 与 Lua 机制。</p> <h1 id="redis-事务简介"><a href="#redis-事务简介" class="header-anchor">#</a> Redis 事务简介</h1> <h2 id="redis-事务基本使用"><a href="#redis-事务基本使用" class="header-anchor">#</a> Redis 事务基本使用</h2> <p>Redis 事务基本可以分为如下几个步骤：</p> <h3 id="_1、开启事务-multi"><a href="#_1、开启事务-multi" class="header-anchor">#</a> 1、开启事务：multi</h3> <p>让客户端Client变为事务模式状态</p> <h3 id="_2、命令入列"><a href="#_2、命令入列" class="header-anchor">#</a> 2、命令入列</h3> <p>输入multi后的所有命令会被存储在一个命令队列中，作为事务的一部分</p> <p>此时，所有命令返回值均为 <code>QUEUED</code>。</p> <h3 id="_3、执行事务-exec"><a href="#_3、执行事务-exec" class="header-anchor">#</a> 3、执行事务：exec</h3> <p>执行exec，执行事务</p> <h3 id="_4、放弃事务-discard"><a href="#_4、放弃事务-discard" class="header-anchor">#</a> 4、放弃事务：discard</h3> <p>不会执行事务</p> <h2 id="redis-事务有acid吗"><a href="#redis-事务有acid吗" class="header-anchor">#</a> Redis 事务有ACID吗</h2> <h3 id="_1、原子性"><a href="#_1、原子性" class="header-anchor">#</a> 1、原子性</h3> <p>原子性的描述是：一个事务的操作要么全部成功，要么全部失败。Redis 事务是否有原子性这个问题，需要分类讨论，但我们需要先明确一点：Redis 事务不支持回滚。</p> <h4 id="不支持回滚"><a href="#不支持回滚" class="header-anchor">#</a> 不支持回滚</h4> <p>Redis 事务并不支持回滚，这与许多关系型数据库截然相反，关于这个问题我找到了一篇官方回答：《为什么 Redis 不支持事务回滚》，非常推荐。简单说就是，Redis 事务的所有命令会被一起执行，并且事务的执行期间，别的客户端发送的命令需要等待事务执行完毕才去执行。加之 Redis 单线程的特性，可以理解为事务获取到了Redis 全局锁。换句话说，只要编码正确，<strong>事务总会成功，不会失败</strong>。</p> <p>现在再回到Redis 事务原子性的讨论中：</p> <ul><li>当事务存在「语法错误」，能够被 Redis <strong>在命令入队时</strong>检测出，执行EXEC会失败，有原子性</li> <li>当事务存在「运行时错误」，比如命令和操作的数据类型不匹配，此时事务中其它正确的命令仍然会被按序执行，此时无原子性，即上述编码错误的情况</li> <li>当事务正常执行，无任何错误时，有原子性</li></ul> <p>因此，只要编码正确，Redis 事务总能保证原子性。</p> <h3 id="_2、隔离性"><a href="#_2、隔离性" class="header-anchor">#</a> 2、隔离性</h3> <p>既然 Redis 单线程执行命令，并且「事务的所有命令会被一起执行」，其它客户端的命令此时会被阻塞，因此 Redis 事务执行过程中能保证天然的隔离性。</p> <p>但是，一个 Redis 事务的生命周期包含两部分：开启到执行前，和执行过程中。</p> <p>事务开启到正式执行前，可能会存在隔离性问题，Redis 提供了  watch 机制来解决这个问题。</p> <h4 id="监控-watch-乐观锁"><a href="#监控-watch-乐观锁" class="header-anchor">#</a> 监控 watch：乐观锁</h4> <blockquote><p>watch使用在 multi 事务开启之前</p></blockquote> <p>watch 可以保证 EXEC 前的隔离性，可以理解为一把乐观锁。</p> <p>使用watch监控若干个key，如果在事务 EXEC 前，某个监控项被修改了，那么在执行 EXEC 命令时，会放弃事务</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>WATCH <span class="token punctuation">[</span>key<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>使用unwatch可以清除所有监控。</p> <p>因此，合理地使用 watch 机制，Redis 事务也能保证隔离性。</p> <h3 id="_3、持久性"><a href="#_3、持久性" class="header-anchor">#</a> 3、持久性</h3> <p>这取决于 Redis 的持久化配置模式。</p> <p>但不管 Redis 采用什么持久化模式，都可能出现数据丢失的情况，所以无法保证事务的持久性。</p> <h3 id="_4、一致性"><a href="#_4、一致性" class="header-anchor">#</a> 4、一致性</h3> <p>Redis 事务机制对一致性属性是有保证的。</p> <h2 id="redis-事务的不足"><a href="#redis-事务的不足" class="header-anchor">#</a> Redis 事务的不足</h2> <p>一旦事务需要依赖于一个 get 操作的结果，就非常不方便。因为事务是一起执行的，我们没办法将一个操作的结果作为命令的一部分进行执行。</p> <p>这么说可能有些抽象，举个例子，假如没有 incrby 命令，要使用事务保证原子性，需要这样执行：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>WATCH counter
GET counter
MULTI
SET counter &lt;the value obtained from GET + any increment&gt;
EXEC
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>即在事务开始前，先获取事务依赖的操作结果，然后执行事务。那要保证线程安全，就必须引入乐观锁机制，使用 WATCH 命令，而当多个客户端都并发执行这段逻辑时，事务执行失败的概率就非常高，容易不断再次 get ，再次执行事务，再次事务被放弃，陷入循环。</p> <h1 id="lua-脚本简介"><a href="#lua-脚本简介" class="header-anchor">#</a> Lua 脚本简介</h1> <p>Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。</p> <h2 id="lua-脚本的基本使用"><a href="#lua-脚本的基本使用" class="header-anchor">#</a> Lua 脚本的基本使用</h2> <h4 id="执行脚本-eval"><a href="#执行脚本-eval" class="header-anchor">#</a> 执行脚本：EVAL</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># [script] 是要执行的脚本,用&quot;&quot;包裹</span>
<span class="token comment"># [numkeys] 代表 key 的数量 </span>
<span class="token comment"># [key ...] key 的名称 [numkeys]个 Lua操作的 Key 的名称必须来自于此。</span>
<span class="token comment"># [arg ...] 其它参数</span>
EVAL <span class="token string">&quot;[script]&quot;</span> <span class="token punctuation">[</span>numkeys<span class="token punctuation">]</span> <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token punctuation">[</span>arg <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>EVAL 不仅仅会执行脚本，还会载入脚本，后续会介绍 Redis 的 Lua 缓存</p></blockquote> <h4 id="lua-操作-key-必须来自-keys"><a href="#lua-操作-key-必须来自-keys" class="header-anchor">#</a> Lua 操作 Key：必须来自 KEYS</h4> <p>Lua 脚本操作的 Key 的来源，必须来自于 KEYS[x]</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>EVAL <span class="token string">&quot;return { KEYS[1], KEYS[2], ARGV[1], ARGV[2], ARGV[3] }&quot;</span> <span class="token number">2</span> key1 key2 arg1 arg2 arg3
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;key1&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;key2&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;arg1&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;arg2&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;arg3&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="lua-脚本执行-redis-命令-redis-call"><a href="#lua-脚本执行-redis-命令-redis-call" class="header-anchor">#</a> Lua 脚本执行 redis 命令：redis.call</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>  EVAL <span class="token string">&quot;return redis.call('GET','mystring')&quot;</span> <span class="token number">0</span>
 <span class="token string">&quot;hello world&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>redis.call</code> 如果发生错误，会立即返回错误，并终止 Lua 脚本的执行</p> <h4 id="不同的错误处理-redis-pcall"><a href="#不同的错误处理-redis-pcall" class="header-anchor">#</a> 不同的错误处理：redis.pcall</h4> <p><code>redis.pcall</code> 和 <code>redis.call</code> 唯一的区别是出错时的处理。</p> <p><code>redis.pcall</code> 并不会终止，而是返回一个带err域的Lua表？</p> <h3 id="脚本缓存-sha1"><a href="#脚本缓存-sha1" class="header-anchor">#</a> 脚本缓存：SHA1</h3> <p>单纯的 EVAL 命令存在一个问题，即每次都需要将完整的 Lua 脚本传送给 Redis。</p> <p>为了解决这个问题，Redis 专门有一个缓存区，存放 Lua 脚本的内容以及 SHA1的值。</p> <p>EVAL 命令既会执行命令，也会载入缓存，<code>SCRIPT LOAD</code> 是纯粹的载入缓存，在 Redis 持有缓存后，只需要<code>EVALSHA</code> 命令，即可不传输完整的 Lua 脚本，只传输 SHA1 的值来执行脚本。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#  加载脚本</span>
redis<span class="token operator">&gt;</span> SCRIPT LOAD <span class="token string">&quot;return 'Immabe a cached script'&quot;</span>
<span class="token string">&quot;c664a3bf70bd1d45c4284ffebb65a6f2299bfc9f&quot;</span>
<span class="token comment">#  执行脚本</span>
redis<span class="token operator">&gt;</span> EVALSHA c664a3bf70bd1d45c4284ffebb65a6f2299bfc9f <span class="token number">0</span>
<span class="token string">&quot;Immabe a cached script&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>脚本缓存本身不会持久化，重启 Redis，主从故障转移等等情况，脚本缓存都会丢失，此时 <code>EVALSHA</code> 命令会返回</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>(error) NOSCRIPT No matching script
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在客户端层面需要对缓存丢失的情况做进一步保证，如 <code>EVALSHA</code> 报错后执行 <code>EVAL</code> 命令 。</p> <h2 id="redis-7-0-新特性-eval-flags"><a href="#redis-7-0-新特性-eval-flags" class="header-anchor">#</a> Redis 7.0 新特性：Eval flags</h2> <p>Redis 7.0 前，Redis 假设所有的脚本都会进行数据的读和写操作。但 Redis 7.0 提供了 <code>Eval flags</code> 可以告知 Redis 脚本的行为。</p> <div class="language-lua line-numbers-mode"><pre class="language-lua"><code><span class="token comment">#!lua flags=no-writes,allow-stale</span>
<span class="token keyword">local</span> x <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span><span class="token string">'x'</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> x
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p>只要 Redis 发现 <code>#!</code> ，就会获得一些默认的 lua flags，这和没有 <code>#!</code> 的 Lua 脚本不同</p></blockquote> <p>没有 <code>#!</code> 的 Lua 脚本可以访问集群中的所有节点，但是由于 <code>#!</code> 默认继承了一些flags，所以不能。</p> <p>Redis 默认脚本有如下特性：</p> <ol><li>既有读操作，又有写操作</li> <li>可以运行在集群模式下，但不能跨 slots 访问数据</li> <li>从节点数据可能过时，会被拒绝操作从节点</li> <li>内存空间小时，会拒绝执行来避免内存溢出</li></ol> <p>下面列出部分参数及含义：</p> <table><thead><tr><th style="text-align:center;">参数</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;">allow-cross-slot-keys</td> <td style="text-align:center;">允许脚本访问来自不同slots的keys（尽管应该尽量避免这样做）</td></tr> <tr><td style="text-align:center;">no-cluster</td> <td style="text-align:center;">如果Redis在集群模式下运行，执行脚本会返回错误</td></tr> <tr><td style="text-align:center;">no-writes</td> <td style="text-align:center;">脚本只有读操作，没有写操作</td></tr></tbody></table> <h2 id="集群对-lua-的限制"><a href="#集群对-lua-的限制" class="header-anchor">#</a> 集群对 Lua 的限制</h2> <p>默认情况下，集群模式的 Lua 不能够跨 slots 访问数据，否则会得到如下错误：</p> <blockquote><p>Lua script attempted to access keys of different hash slots</p></blockquote> <p>集群下，Lua 脚本默认有一个限制，即一个 Lua 脚本操作的所有 key 必须在同一个slot上。</p> <h3 id="为什么是-slot-而非-node"><a href="#为什么是-slot-而非-node" class="header-anchor">#</a> 为什么是 slot 而非 node</h3> <p>即：为什么 Lua 不能够在同一个 node 的不同 slots 上操作多个 key 呢？</p> <p>因为，slot 的目的就是为了解耦 Redis 实例与数据的关系的。slot 应该可以在不同分片节点上进行切换以实现负载均衡。如果是分片而非 slot ，那么很有可能，你的代码今天能运行，明天就会爆炸。</p> <p>有意思的是，在以前的官方文档上，也误使用了 node 而非 slot 表达，因此在此强调一下。</p> <p><img src="/blog/assets/img/image-20240114163115469.32dfeaa6.png" alt="image-20240114163115469"></p> <h3 id="解决方案"><a href="#解决方案" class="header-anchor">#</a> 解决方案</h3> <h4 id="_1、hashtags-保证-key-在同一节点"><a href="#_1、hashtags-保证-key-在同一节点" class="header-anchor">#</a> 1、HashTags：保证 key 在同一节点</h4> <p>如果键中的{}括号之间有子串，则只对字符串内的内容进行哈希处理，这个子串叫做「哈希标签」。</p> <p>例如：Redis 保证 <code>user:{123}:profile</code> 和 <code>user:{123}:account</code> 会在同一个哈希槽中，因为它们的「哈希标签」是相同的。</p> <p>通过 <code>CLUSTER KEYSLOT</code> 命令获取目标Key的哈希槽（Hash Slot）进行确认。</p> <h4 id="_2、考虑数据类型的设计"><a href="#_2、考虑数据类型的设计" class="header-anchor">#</a> 2、考虑数据类型的设计</h4> <p>我们可以使用 hashes, lists, or sets 等数据结构来保存有关联的数据，使得 Lua 无需跨 slots 访问数据，一个 Key 即可解决。</p> <h4 id="_3、eval-flags-allow-cross-slot-keys"><a href="#_3、eval-flags-allow-cross-slot-keys" class="header-anchor">#</a> 3、Eval Flags：allow-cross-slot-keys</h4> <p>利用 Redis 7.0 新特性 Eval flags，允许脚本访问来自不同slots的keys，尽管这种做法是不推荐的。</p> <div class="language-lua line-numbers-mode"><pre class="language-lua"><code><span class="token comment">#!lua flags=allow-cross-slot-keys</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="lua-的其它限制"><a href="#lua-的其它限制" class="header-anchor">#</a> Lua 的其它限制</h2> <h3 id="执行时长限制"><a href="#执行时长限制" class="header-anchor">#</a> 执行时长限制</h3> <p>lua 脚本如果执行时长超过 5 s，Redis 会自动终止该脚本</p> <h2 id="主从模式下-lua-的数据同步"><a href="#主从模式下-lua-的数据同步" class="header-anchor">#</a> 主从模式下 Lua 的数据同步</h2> <p>Redis 7.0 只有一种同步方案：Effects replication。</p> <p>主节点会将 Lua 脚本中，实际修改数据的命令封装成「MULTI/EXEC 的事务」并同步给从节点（以及AOF）。</p> <p>从节点无需将这些命令当作脚本执行，便可以保证主从节点的数据一致。</p> <blockquote><p>在 Redis 5.0 之后默认的方案即为 Effects replication。</p> <p>另一个方案叫 Verbatim replication，需要从节点与主节点完全执行相同的工作，在 Redis 7.0 被废弃。</p></blockquote> <h2 id="lua-常见命令"><a href="#lua-常见命令" class="header-anchor">#</a> Lua 常见命令</h2> <h4 id="载入并执行脚本-eval"><a href="#载入并执行脚本-eval" class="header-anchor">#</a> 载入并执行脚本：EVAL</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># [script] 是要执行的脚本,用&quot;&quot;包裹</span>
<span class="token comment"># [numkeys] 代表 key 的数量 </span>
<span class="token comment"># [key ...] key 的名称 [numkeys]个 Lua操作的 Key 的名称必须来自于此。</span>
<span class="token comment"># [arg ...] 其它参数</span>
EVAL <span class="token string">&quot;[script]&quot;</span> <span class="token punctuation">[</span>numkeys<span class="token punctuation">]</span> <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token punctuation">[</span>arg <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="执行载入的脚本-evalsha"><a href="#执行载入的脚本-evalsha" class="header-anchor">#</a> 执行载入的脚本：EVALSHA</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>EVALSHA sha1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="查询脚本是否已载入-exists"><a href="#查询脚本是否已载入-exists" class="header-anchor">#</a> 查询脚本是否已载入：EXISTS</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>SCRIPT EXISTS <span class="token punctuation">[</span>SHA1 <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 0 不存在 1 存在</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="载入脚本-load"><a href="#载入脚本-load" class="header-anchor">#</a> 载入脚本：LOAD</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 不会执行脚本</span>
SCRIPT LOAD
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="清除载入的脚本-flush"><a href="#清除载入的脚本-flush" class="header-anchor">#</a> 清除载入的脚本：FLUSH</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>SCRIPT FLUSH
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="终止脚本的执行-script-kill"><a href="#终止脚本的执行-script-kill" class="header-anchor">#</a> 终止脚本的执行：SCRIPT KILL</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 一旦 lua 脚本存在写入操作,就无法终止</span>
SCRIPT KILL
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h1 id="lua-vs-事务"><a href="#lua-vs-事务" class="header-anchor">#</a> Lua vs 事务</h1> <p>最后，我们来对比 Lua 和 事务的主要区别。</p> <h3 id="性能比较"><a href="#性能比较" class="header-anchor">#</a> 性能比较</h3> <p>根据官方文档，Lua 的理论效率要高于事务，但实际运行过程中也可能比较接近。Lua 略胜。</p> <h3 id="使用成本"><a href="#使用成本" class="header-anchor">#</a> 使用成本</h3> <p>尽管 Redis 事务相关的命令非常少，但 Lua 脚本的编写也十分简单，入门门槛低。Redis 事务略胜，但不关键。</p> <h3 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h3> <p>Lua 更灵活，在 Lua 脚本内，可以通过 if then 语句做逻辑控制，而事务不行。</p> <p>另外一旦事务需要依赖于一个 get 操作的结果，Redis 事务就很难做到了。在灵活度上 Lua 完胜。</p> <h3 id="什么时候该用事务"><a href="#什么时候该用事务" class="header-anchor">#</a> 什么时候该用事务</h3> <p>总结是，能用 Lua ，就用 Lua，实在用不了才用事务。</p> <ul><li>您的事务所依赖的键不会被频繁修改，这意味着您确信乐观锁定几乎永远不会中止事务。</li> <li>可能是，第三方服务编写的大量逻辑，因此没有简单的方法可以将该逻辑移动到 Lua 脚本。</li></ul> <p>除非这两点同时满足，否则都更推荐使用 Lua。</p> <h4 id="参考文档"><a href="#参考文档" class="header-anchor">#</a> 参考文档</h4> <p>《Redis 核心技术与实战》</p> <p><a href="https://redis.io/docs/interact/transactions/" target="_blank" rel="noopener noreferrer">Redis 官网<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://redis.com/blog/you-dont-need-transaction-rollbacks-in-redis/" target="_blank" rel="noopener noreferrer">You Don’t Need Transaction Rollbacks in Redis<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://www.dragonflydb.io/error-solutions/crossslot-keys-in-request-dont-hash-to-the-same-slot" target="_blank" rel="noopener noreferrer">Error: crossslot keys in request don't hash to the same slot<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://github.com/redis/redis/issues/5118" target="_blank" rel="noopener noreferrer">CROSSSLOT error on single-shard cluster<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/redis/feature/Persistence.html" class="prev">
        Redis 持久化：RDB &amp; AOF
      </a></span> <span class="next"><a href="/blog/redis/feature/Rollback.html">
        为什么 Redis 不支持事务回滚
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.7b9df32b.js" defer></script><script src="/blog/assets/js/2.be714ec7.js" defer></script><script src="/blog/assets/js/1.26c7c9cc.js" defer></script><script src="/blog/assets/js/33.4852d9ec.js" defer></script>
  </body>
</html>
